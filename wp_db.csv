"1","siteurl","http://euler.lvtran.com/","yes"
"2","blogname","Project Euler | Long Tran","yes"
"3","blogdescription","Project Euler - A Taste of Number Theory","yes"
"4","users_can_register","0","yes"
"5","admin_email","you@example.com","yes"
"6","start_of_week","1","yes"
"7","use_balanceTags","0","yes"
"8","use_smilies","1","yes"
"9","require_name_email","1","yes"
"10","comments_notify","1","yes"
"11","posts_per_rss","10","yes"
"12","rss_use_excerpt","0","yes"
"13","mailserver_url","mail.example.com","yes"
"14","mailserver_login","login@example.com","yes"
"15","mailserver_pass","password","yes"
"16","mailserver_port","110","yes"
"17","default_category","1","yes"
"18","default_comment_status","open","yes"
"19","default_ping_status","open","yes"
"20","default_pingback_flag","1","yes"
"21","posts_per_page","10","yes"
"22","date_format","F j, Y","yes"
"23","time_format","g:i a","yes"
"24","links_updated_date_format","F j, Y g:i a","yes"
"25","comment_moderation","0","yes"
"26","moderation_notify","1","yes"
"27","permalink_structure","/%postname%/","yes"
"29","hack_file","0","yes"
"30","blog_charset","UTF-8","yes"
"31","moderation_keys",,"no"
"32","active_plugins","a:6:{i:0;s:19:""akismet/akismet.php"";i:1;s:9:""hello.php"";i:2;s:19:""jetpack/jetpack.php"";i:3;s:47:""mojo-marketplace-wp-plugin/mojo-marketplace.php"";i:4;s:41:""syntax-highlighter/syntax_highlighter.php"";i:5;s:20:""visualizer/index.php"";}","yes"
"33","home","http://euler.lvtran.com","yes"
"34","category_base",,"yes"
"35","ping_sites","http://rpc.pingomatic.com/","yes"
"37","comment_max_links","2","yes"
"38","gmt_offset","0","yes"
"39","default_email_category","1","yes"
"40","recently_edited","a:5:{i:0;s:73:""/home5/lvtranco/public_html/euler/wp-content/plugins/visualizer/index.php"";i:1;s:73:""/home5/lvtranco/public_html/euler/wp-content/themes/dw-timeline/style.css"";i:2;s:78:""/home5/lvtranco/public_html/euler/wp-content/themes/dw-timeline/lib/titles.php"";i:3;s:77:""/home5/lvtranco/public_html/euler/wp-content/themes/dw-timeline/functions.php"";i:4;s:73:""/home5/lvtranco/public_html/euler/wp-content/themes/dw-timeline/index.php"";}","no"
"41","template","dw-timeline","yes"
"42","stylesheet","dw-timeline","yes"
"43","comment_whitelist","1","yes"
"44","blacklist_keys",,"no"
"45","comment_registration","0","yes"
"46","html_type","text/html","yes"
"47","use_trackback","0","yes"
"48","default_role","subscriber","yes"
"49","db_version","35700","yes"
"50","uploads_use_yearmonth_folders","1","yes"
"51","upload_path",,"yes"
"52","blog_public","1","yes"
"53","default_link_category","2","yes"
"54","show_on_front","posts","yes"
"55","tag_base",,"yes"
"56","show_avatars","1","yes"
"57","avatar_rating","G","yes"
"58","upload_url_path",,"yes"
"59","thumbnail_size_w","150","yes"
"60","thumbnail_size_h","150","yes"
"61","thumbnail_crop","1","yes"
"62","medium_size_w","300","yes"
"63","medium_size_h","300","yes"
"64","avatar_default","mystery","yes"
"65","large_size_w","1024","yes"
"66","large_size_h","1024","yes"
"67","image_default_link_type","file","yes"
"68","image_default_size",,"yes"
"69","image_default_align",,"yes"
"70","close_comments_for_old_posts","0","yes"
"71","close_comments_days_old","14","yes"
"72","thread_comments","1","yes"
"73","thread_comments_depth","5","yes"
"74","page_comments","0","yes"
"75","comments_per_page","50","yes"
"76","default_comments_page","newest","yes"
"77","comment_order","asc","yes"
"78","sticky_posts","a:0:{}","yes"
"79","widget_categories","a:2:{i:2;a:4:{s:5:""title"";s:0:"""";s:5:""count"";i:0;s:12:""hierarchical"";i:0;s:8:""dropdown"";i:0;}s:12:""_multiwidget"";i:1;}","yes"
"80","widget_text","a:2:{i:1;a:0:{}s:12:""_multiwidget"";i:1;}","yes"
"81","widget_rss","a:2:{i:1;a:0:{}s:12:""_multiwidget"";i:1;}","yes"
"82","uninstall_plugins","a:0:{}","no"
"83","timezone_string",,"yes"
"84","page_for_posts","0","yes"
"85","page_on_front","0","yes"
"86","default_post_format","0","yes"
"87","link_manager_enabled","0","yes"
"88","initial_db_version","27916","yes"
"89","wp_veqn_user_roles","a:5:{s:13:""administrator"";a:2:{s:4:""name"";s:13:""Administrator"";s:12:""capabilities"";a:61:{s:13:""switch_themes"";b:1;s:11:""edit_themes"";b:1;s:16:""activate_plugins"";b:1;s:12:""edit_plugins"";b:1;s:10:""edit_users"";b:1;s:10:""edit_files"";b:1;s:14:""manage_options"";b:1;s:17:""moderate_comments"";b:1;s:17:""manage_categories"";b:1;s:12:""manage_links"";b:1;s:12:""upload_files"";b:1;s:6:""import"";b:1;s:15:""unfiltered_html"";b:1;s:10:""edit_posts"";b:1;s:17:""edit_others_posts"";b:1;s:20:""edit_published_posts"";b:1;s:13:""publish_posts"";b:1;s:10:""edit_pages"";b:1;s:4:""read"";b:1;s:8:""level_10"";b:1;s:7:""level_9"";b:1;s:7:""level_8"";b:1;s:7:""level_7"";b:1;s:7:""level_6"";b:1;s:7:""level_5"";b:1;s:7:""level_4"";b:1;s:7:""level_3"";b:1;s:7:""level_2"";b:1;s:7:""level_1"";b:1;s:7:""level_0"";b:1;s:17:""edit_others_pages"";b:1;s:20:""edit_published_pages"";b:1;s:13:""publish_pages"";b:1;s:12:""delete_pages"";b:1;s:19:""delete_others_pages"";b:1;s:22:""delete_published_pages"";b:1;s:12:""delete_posts"";b:1;s:19:""delete_others_posts"";b:1;s:22:""delete_published_posts"";b:1;s:20:""delete_private_posts"";b:1;s:18:""edit_private_posts"";b:1;s:18:""read_private_posts"";b:1;s:20:""delete_private_pages"";b:1;s:18:""edit_private_pages"";b:1;s:18:""read_private_pages"";b:1;s:12:""delete_users"";b:1;s:12:""create_users"";b:1;s:17:""unfiltered_upload"";b:1;s:14:""edit_dashboard"";b:1;s:14:""update_plugins"";b:1;s:14:""delete_plugins"";b:1;s:15:""install_plugins"";b:1;s:13:""update_themes"";b:1;s:14:""install_themes"";b:1;s:11:""update_core"";b:1;s:10:""list_users"";b:1;s:12:""remove_users"";b:1;s:13:""promote_users"";b:1;s:18:""edit_theme_options"";b:1;s:13:""delete_themes"";b:1;s:6:""export"";b:1;}}s:6:""editor"";a:2:{s:4:""name"";s:6:""Editor"";s:12:""capabilities"";a:34:{s:17:""moderate_comments"";b:1;s:17:""manage_categories"";b:1;s:12:""manage_links"";b:1;s:12:""upload_files"";b:1;s:15:""unfiltered_html"";b:1;s:10:""edit_posts"";b:1;s:17:""edit_others_posts"";b:1;s:20:""edit_published_posts"";b:1;s:13:""publish_posts"";b:1;s:10:""edit_pages"";b:1;s:4:""read"";b:1;s:7:""level_7"";b:1;s:7:""level_6"";b:1;s:7:""level_5"";b:1;s:7:""level_4"";b:1;s:7:""level_3"";b:1;s:7:""level_2"";b:1;s:7:""level_1"";b:1;s:7:""level_0"";b:1;s:17:""edit_others_pages"";b:1;s:20:""edit_published_pages"";b:1;s:13:""publish_pages"";b:1;s:12:""delete_pages"";b:1;s:19:""delete_others_pages"";b:1;s:22:""delete_published_pages"";b:1;s:12:""delete_posts"";b:1;s:19:""delete_others_posts"";b:1;s:22:""delete_published_posts"";b:1;s:20:""delete_private_posts"";b:1;s:18:""edit_private_posts"";b:1;s:18:""read_private_posts"";b:1;s:20:""delete_private_pages"";b:1;s:18:""edit_private_pages"";b:1;s:18:""read_private_pages"";b:1;}}s:6:""author"";a:2:{s:4:""name"";s:6:""Author"";s:12:""capabilities"";a:10:{s:12:""upload_files"";b:1;s:10:""edit_posts"";b:1;s:20:""edit_published_posts"";b:1;s:13:""publish_posts"";b:1;s:4:""read"";b:1;s:7:""level_2"";b:1;s:7:""level_1"";b:1;s:7:""level_0"";b:1;s:12:""delete_posts"";b:1;s:22:""delete_published_posts"";b:1;}}s:11:""contributor"";a:2:{s:4:""name"";s:11:""Contributor"";s:12:""capabilities"";a:5:{s:10:""edit_posts"";b:1;s:4:""read"";b:1;s:7:""level_1"";b:1;s:7:""level_0"";b:1;s:12:""delete_posts"";b:1;}}s:10:""subscriber"";a:2:{s:4:""name"";s:10:""Subscriber"";s:12:""capabilities"";a:2:{s:4:""read"";b:1;s:7:""level_0"";b:1;}}}","yes"
"90","_transient_random_seed","bb08b6ed4c2c33b07681c8db206bb868","yes"
"91","widget_search","a:2:{i:2;a:1:{s:5:""title"";s:0:"""";}s:12:""_multiwidget"";i:1;}","yes"
"92","widget_recent-posts","a:2:{i:2;a:2:{s:5:""title"";s:0:"""";s:6:""number"";i:5;}s:12:""_multiwidget"";i:1;}","yes"
"93","widget_recent-comments","a:2:{i:2;a:2:{s:5:""title"";s:0:"""";s:6:""number"";i:5;}s:12:""_multiwidget"";i:1;}","yes"
"94","widget_archives","a:2:{i:2;a:3:{s:5:""title"";s:0:"""";s:5:""count"";i:0;s:8:""dropdown"";i:0;}s:12:""_multiwidget"";i:1;}","yes"
"95","widget_meta","a:2:{i:2;a:1:{s:5:""title"";s:0:"""";}s:12:""_multiwidget"";i:1;}","yes"
"96","sidebars_widgets","a:3:{s:19:""wp_inactive_widgets"";a:0:{}s:18:""orphaned_widgets_1"";a:6:{i:0;s:8:""search-2"";i:1;s:14:""recent-posts-2"";i:2;s:17:""recent-comments-2"";i:3;s:10:""archives-2"";i:4;s:12:""categories-2"";i:5;s:6:""meta-2"";}s:13:""array_version"";i:3;}","yes"
"97","jetpack_activated","1","yes"
"98","jetpack_options","a:2:{s:7:""version"";s:16:""2.9.3:1401879627"";s:11:""old_version"";s:16:""2.9.3:1401879627"";}","yes"
"99","cron","a:6:{i:1458003754;a:1:{s:20:""jetpack_clean_nonces"";a:1:{s:32:""40cd750bba9870f18aada2478b24840a"";a:3:{s:8:""schedule"";s:6:""hourly"";s:4:""args"";a:0:{}s:8:""interval"";i:3600;}}}i:1458003781;a:1:{s:14:""mm_cron_hourly"";a:1:{s:32:""40cd750bba9870f18aada2478b24840a"";a:3:{s:8:""schedule"";s:6:""hourly"";s:4:""args"";a:0:{}s:8:""interval"";i:3600;}}}i:1458039754;a:3:{s:16:""wp_version_check"";a:1:{s:32:""40cd750bba9870f18aada2478b24840a"";a:3:{s:8:""schedule"";s:10:""twicedaily"";s:4:""args"";a:0:{}s:8:""interval"";i:43200;}}s:17:""wp_update_plugins"";a:1:{s:32:""40cd750bba9870f18aada2478b24840a"";a:3:{s:8:""schedule"";s:10:""twicedaily"";s:4:""args"";a:0:{}s:8:""interval"";i:43200;}}s:16:""wp_update_themes"";a:1:{s:32:""40cd750bba9870f18aada2478b24840a"";a:3:{s:8:""schedule"";s:10:""twicedaily"";s:4:""args"";a:0:{}s:8:""interval"";i:43200;}}}i:1458039781;a:3:{s:19:""wp_scheduled_delete"";a:1:{s:32:""40cd750bba9870f18aada2478b24840a"";a:3:{s:8:""schedule"";s:5:""daily"";s:4:""args"";a:0:{}s:8:""interval"";i:86400;}}s:13:""mm_cron_daily"";a:1:{s:32:""40cd750bba9870f18aada2478b24840a"";a:3:{s:8:""schedule"";s:5:""daily"";s:4:""args"";a:0:{}s:8:""interval"";i:86400;}}s:18:""mm_cron_twicedaily"";a:1:{s:32:""40cd750bba9870f18aada2478b24840a"";a:3:{s:8:""schedule"";s:10:""twicedaily"";s:4:""args"";a:0:{}s:8:""interval"";i:43200;}}}i:1458040009;a:1:{s:30:""wp_scheduled_auto_draft_delete"";a:1:{s:32:""40cd750bba9870f18aada2478b24840a"";a:3:{s:8:""schedule"";s:5:""daily"";s:4:""args"";a:0:{}s:8:""interval"";i:86400;}}}s:7:""version"";i:2;}","yes"
"110","mm_master_aff",,"yes"
"16859","_site_transient_timeout_theme_roots","1459031624","yes"
"16860","_site_transient_theme_roots","a:4:{s:11:""dw-timeline"";s:7:""/themes"";s:13:""twentyfifteen"";s:7:""/themes"";s:14:""twentyfourteen"";s:7:""/themes"";s:13:""twentysixteen"";s:7:""/themes"";}","yes"
"142","_site_transient_update_themes","O:8:""stdClass"":4:{s:12:""last_checked"";i:1459029860;s:7:""checked"";a:4:{s:11:""dw-timeline"";s:5:""1.0.9"";s:13:""twentyfifteen"";s:3:""1.4"";s:14:""twentyfourteen"";s:3:""1.6"";s:13:""twentysixteen"";s:3:""1.1"";}s:8:""response"";a:0:{}s:12:""translations"";a:0:{}}","yes"
"111","mm_install_date","Jun 04, 2014","yes"
"363","nav_menu_options","a:2:{i:0;b:0;s:8:""auto_add"";a:0:{}}","yes"
"252","recently_activated","a:0:{}","yes"
"143","theme_mods_twentyfourteen","a:1:{s:16:""sidebars_widgets"";a:2:{s:4:""time"";i:1401879830;s:4:""data"";a:4:{s:19:""wp_inactive_widgets"";a:0:{}s:9:""sidebar-1"";a:6:{i:0;s:8:""search-2"";i:1;s:14:""recent-posts-2"";i:2;s:17:""recent-comments-2"";i:3;s:10:""archives-2"";i:4;s:12:""categories-2"";i:5;s:6:""meta-2"";}s:9:""sidebar-2"";a:0:{}s:9:""sidebar-3"";a:0:{}}}}","yes"
"144","current_theme","DW Timeline","yes"
"145","theme_mods_dw-timeline","a:2:{i:0;b:0;s:18:""nav_menu_locations"";a:1:{s:18:""primary_navigation"";i:2;}}","yes"
"146","theme_switched",,"yes"
"192","category_children","a:0:{}","yes"
"347","syntax-highlighter Options","a:2:{s:7:""version"";s:6:""3.0.83"";s:5:""theme"";s:8:""Midnight"";}","yes"
"185","widget_pages","a:2:{i:1;a:0:{}s:12:""_multiwidget"";i:1;}","yes"
"186","widget_calendar","a:2:{i:1;a:0:{}s:12:""_multiwidget"";i:1;}","yes"
"187","widget_tag_cloud","a:2:{i:1;a:0:{}s:12:""_multiwidget"";i:1;}","yes"
"188","widget_nav_menu","a:2:{i:1;a:0:{}s:12:""_multiwidget"";i:1;}","yes"
"189","widget_akismet_widget","a:2:{i:1;a:0:{}s:12:""_multiwidget"";i:1;}","yes"
"190","widget_mojo_widget","a:2:{i:1;a:0:{}s:12:""_multiwidget"";i:1;}","yes"
"191","dw_timeline_theme_options","a:10:{s:9:""get_start"";s:0:"""";s:7:""favicon"";s:62:""http://euler.lvtran.com/wp-content/uploads/2014/06/favicon.png"";s:23:""header_background_image"";s:100:""http://euler.lvtran.com/wp-content/uploads/2014/06/clear-sky-nature-hd-wallpaper-1920x1080-38291.jpg"";s:17:""header_mask_start"";s:7:""#b8d1d6"";s:15:""header_mask_end"";s:7:""#0060b5"";s:21:""site_title_backgournd"";b:0;s:12:""heading_font"";s:91:""Lora:dw:http://themes.googleusercontent.com/static/fonts/lora/v5/enKND5SfzQKkggBA_VnT1A.ttf"";s:9:""body_font"";s:91:""Lora:dw:http://themes.googleusercontent.com/static/fonts/lora/v5/aXJ7KVIGcejEy1abawZazg.ttf"";s:11:""header_code"";s:72:"" <style>
a {color: #3280b1;}
a:hover, a:focus {color: #56aaca;}
</style>"";s:11:""footer_code"";s:408:""<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48211346-1', 'auto');
  ga('send', 'pageview');

</script>"";}","yes"
"11977","rewrite_rules","a:82:{s:47:""category/(.+?)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:52:""index.php?category_name=$matches[1]&feed=$matches[2]"";s:42:""category/(.+?)/(feed|rdf|rss|rss2|atom)/?$"";s:52:""index.php?category_name=$matches[1]&feed=$matches[2]"";s:35:""category/(.+?)/page/?([0-9]{1,})/?$"";s:53:""index.php?category_name=$matches[1]&paged=$matches[2]"";s:17:""category/(.+?)/?$"";s:35:""index.php?category_name=$matches[1]"";s:44:""tag/([^/]+)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:42:""index.php?tag=$matches[1]&feed=$matches[2]"";s:39:""tag/([^/]+)/(feed|rdf|rss|rss2|atom)/?$"";s:42:""index.php?tag=$matches[1]&feed=$matches[2]"";s:32:""tag/([^/]+)/page/?([0-9]{1,})/?$"";s:43:""index.php?tag=$matches[1]&paged=$matches[2]"";s:14:""tag/([^/]+)/?$"";s:25:""index.php?tag=$matches[1]"";s:45:""type/([^/]+)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:50:""index.php?post_format=$matches[1]&feed=$matches[2]"";s:40:""type/([^/]+)/(feed|rdf|rss|rss2|atom)/?$"";s:50:""index.php?post_format=$matches[1]&feed=$matches[2]"";s:33:""type/([^/]+)/page/?([0-9]{1,})/?$"";s:51:""index.php?post_format=$matches[1]&paged=$matches[2]"";s:15:""type/([^/]+)/?$"";s:33:""index.php?post_format=$matches[1]"";s:38:""visualizer/[^/]+/attachment/([^/]+)/?$"";s:32:""index.php?attachment=$matches[1]"";s:48:""visualizer/[^/]+/attachment/([^/]+)/trackback/?$"";s:37:""index.php?attachment=$matches[1]&tb=1"";s:68:""visualizer/[^/]+/attachment/([^/]+)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:49:""index.php?attachment=$matches[1]&feed=$matches[2]"";s:63:""visualizer/[^/]+/attachment/([^/]+)/(feed|rdf|rss|rss2|atom)/?$"";s:49:""index.php?attachment=$matches[1]&feed=$matches[2]"";s:63:""visualizer/[^/]+/attachment/([^/]+)/comment-page-([0-9]{1,})/?$"";s:50:""index.php?attachment=$matches[1]&cpage=$matches[2]"";s:31:""visualizer/([^/]+)/trackback/?$"";s:37:""index.php?visualizer=$matches[1]&tb=1"";s:39:""visualizer/([^/]+)/page/?([0-9]{1,})/?$"";s:50:""index.php?visualizer=$matches[1]&paged=$matches[2]"";s:46:""visualizer/([^/]+)/comment-page-([0-9]{1,})/?$"";s:50:""index.php?visualizer=$matches[1]&cpage=$matches[2]"";s:31:""visualizer/([^/]+)(/[0-9]+)?/?$"";s:49:""index.php?visualizer=$matches[1]&page=$matches[2]"";s:27:""visualizer/[^/]+/([^/]+)/?$"";s:32:""index.php?attachment=$matches[1]"";s:37:""visualizer/[^/]+/([^/]+)/trackback/?$"";s:37:""index.php?attachment=$matches[1]&tb=1"";s:57:""visualizer/[^/]+/([^/]+)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:49:""index.php?attachment=$matches[1]&feed=$matches[2]"";s:52:""visualizer/[^/]+/([^/]+)/(feed|rdf|rss|rss2|atom)/?$"";s:49:""index.php?attachment=$matches[1]&feed=$matches[2]"";s:52:""visualizer/[^/]+/([^/]+)/comment-page-([0-9]{1,})/?$"";s:50:""index.php?attachment=$matches[1]&cpage=$matches[2]"";s:12:""robots\.txt$"";s:18:""index.php?robots=1"";s:48:"".*wp-(atom|rdf|rss|rss2|feed|commentsrss2)\.php$"";s:18:""index.php?feed=old"";s:20:"".*wp-app\.php(/.*)?$"";s:19:""index.php?error=403"";s:18:"".*wp-register.php$"";s:23:""index.php?register=true"";s:32:""feed/(feed|rdf|rss|rss2|atom)/?$"";s:27:""index.php?&feed=$matches[1]"";s:27:""(feed|rdf|rss|rss2|atom)/?$"";s:27:""index.php?&feed=$matches[1]"";s:20:""page/?([0-9]{1,})/?$"";s:28:""index.php?&paged=$matches[1]"";s:41:""comments/feed/(feed|rdf|rss|rss2|atom)/?$"";s:42:""index.php?&feed=$matches[1]&withcomments=1"";s:36:""comments/(feed|rdf|rss|rss2|atom)/?$"";s:42:""index.php?&feed=$matches[1]&withcomments=1"";s:44:""search/(.+)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:40:""index.php?s=$matches[1]&feed=$matches[2]"";s:39:""search/(.+)/(feed|rdf|rss|rss2|atom)/?$"";s:40:""index.php?s=$matches[1]&feed=$matches[2]"";s:32:""search/(.+)/page/?([0-9]{1,})/?$"";s:41:""index.php?s=$matches[1]&paged=$matches[2]"";s:14:""search/(.+)/?$"";s:23:""index.php?s=$matches[1]"";s:47:""author/([^/]+)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:50:""index.php?author_name=$matches[1]&feed=$matches[2]"";s:42:""author/([^/]+)/(feed|rdf|rss|rss2|atom)/?$"";s:50:""index.php?author_name=$matches[1]&feed=$matches[2]"";s:35:""author/([^/]+)/page/?([0-9]{1,})/?$"";s:51:""index.php?author_name=$matches[1]&paged=$matches[2]"";s:17:""author/([^/]+)/?$"";s:33:""index.php?author_name=$matches[1]"";s:69:""([0-9]{4})/([0-9]{1,2})/([0-9]{1,2})/feed/(feed|rdf|rss|rss2|atom)/?$"";s:80:""index.php?year=$matches[1]&monthnum=$matches[2]&day=$matches[3]&feed=$matches[4]"";s:64:""([0-9]{4})/([0-9]{1,2})/([0-9]{1,2})/(feed|rdf|rss|rss2|atom)/?$"";s:80:""index.php?year=$matches[1]&monthnum=$matches[2]&day=$matches[3]&feed=$matches[4]"";s:57:""([0-9]{4})/([0-9]{1,2})/([0-9]{1,2})/page/?([0-9]{1,})/?$"";s:81:""index.php?year=$matches[1]&monthnum=$matches[2]&day=$matches[3]&paged=$matches[4]"";s:39:""([0-9]{4})/([0-9]{1,2})/([0-9]{1,2})/?$"";s:63:""index.php?year=$matches[1]&monthnum=$matches[2]&day=$matches[3]"";s:56:""([0-9]{4})/([0-9]{1,2})/feed/(feed|rdf|rss|rss2|atom)/?$"";s:64:""index.php?year=$matches[1]&monthnum=$matches[2]&feed=$matches[3]"";s:51:""([0-9]{4})/([0-9]{1,2})/(feed|rdf|rss|rss2|atom)/?$"";s:64:""index.php?year=$matches[1]&monthnum=$matches[2]&feed=$matches[3]"";s:44:""([0-9]{4})/([0-9]{1,2})/page/?([0-9]{1,})/?$"";s:65:""index.php?year=$matches[1]&monthnum=$matches[2]&paged=$matches[3]"";s:26:""([0-9]{4})/([0-9]{1,2})/?$"";s:47:""index.php?year=$matches[1]&monthnum=$matches[2]"";s:43:""([0-9]{4})/feed/(feed|rdf|rss|rss2|atom)/?$"";s:43:""index.php?year=$matches[1]&feed=$matches[2]"";s:38:""([0-9]{4})/(feed|rdf|rss|rss2|atom)/?$"";s:43:""index.php?year=$matches[1]&feed=$matches[2]"";s:31:""([0-9]{4})/page/?([0-9]{1,})/?$"";s:44:""index.php?year=$matches[1]&paged=$matches[2]"";s:13:""([0-9]{4})/?$"";s:26:""index.php?year=$matches[1]"";s:27:"".?.+?/attachment/([^/]+)/?$"";s:32:""index.php?attachment=$matches[1]"";s:37:"".?.+?/attachment/([^/]+)/trackback/?$"";s:37:""index.php?attachment=$matches[1]&tb=1"";s:57:"".?.+?/attachment/([^/]+)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:49:""index.php?attachment=$matches[1]&feed=$matches[2]"";s:52:"".?.+?/attachment/([^/]+)/(feed|rdf|rss|rss2|atom)/?$"";s:49:""index.php?attachment=$matches[1]&feed=$matches[2]"";s:52:"".?.+?/attachment/([^/]+)/comment-page-([0-9]{1,})/?$"";s:50:""index.php?attachment=$matches[1]&cpage=$matches[2]"";s:20:""(.?.+?)/trackback/?$"";s:35:""index.php?pagename=$matches[1]&tb=1"";s:40:""(.?.+?)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:47:""index.php?pagename=$matches[1]&feed=$matches[2]"";s:35:""(.?.+?)/(feed|rdf|rss|rss2|atom)/?$"";s:47:""index.php?pagename=$matches[1]&feed=$matches[2]"";s:28:""(.?.+?)/page/?([0-9]{1,})/?$"";s:48:""index.php?pagename=$matches[1]&paged=$matches[2]"";s:35:""(.?.+?)/comment-page-([0-9]{1,})/?$"";s:48:""index.php?pagename=$matches[1]&cpage=$matches[2]"";s:20:""(.?.+?)(/[0-9]+)?/?$"";s:47:""index.php?pagename=$matches[1]&page=$matches[2]"";s:27:""[^/]+/attachment/([^/]+)/?$"";s:32:""index.php?attachment=$matches[1]"";s:37:""[^/]+/attachment/([^/]+)/trackback/?$"";s:37:""index.php?attachment=$matches[1]&tb=1"";s:57:""[^/]+/attachment/([^/]+)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:49:""index.php?attachment=$matches[1]&feed=$matches[2]"";s:52:""[^/]+/attachment/([^/]+)/(feed|rdf|rss|rss2|atom)/?$"";s:49:""index.php?attachment=$matches[1]&feed=$matches[2]"";s:52:""[^/]+/attachment/([^/]+)/comment-page-([0-9]{1,})/?$"";s:50:""index.php?attachment=$matches[1]&cpage=$matches[2]"";s:20:""([^/]+)/trackback/?$"";s:31:""index.php?name=$matches[1]&tb=1"";s:40:""([^/]+)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:43:""index.php?name=$matches[1]&feed=$matches[2]"";s:35:""([^/]+)/(feed|rdf|rss|rss2|atom)/?$"";s:43:""index.php?name=$matches[1]&feed=$matches[2]"";s:28:""([^/]+)/page/?([0-9]{1,})/?$"";s:44:""index.php?name=$matches[1]&paged=$matches[2]"";s:35:""([^/]+)/comment-page-([0-9]{1,})/?$"";s:44:""index.php?name=$matches[1]&cpage=$matches[2]"";s:20:""([^/]+)(/[0-9]+)?/?$"";s:43:""index.php?name=$matches[1]&page=$matches[2]"";s:16:""[^/]+/([^/]+)/?$"";s:32:""index.php?attachment=$matches[1]"";s:26:""[^/]+/([^/]+)/trackback/?$"";s:37:""index.php?attachment=$matches[1]&tb=1"";s:46:""[^/]+/([^/]+)/feed/(feed|rdf|rss|rss2|atom)/?$"";s:49:""index.php?attachment=$matches[1]&feed=$matches[2]"";s:41:""[^/]+/([^/]+)/(feed|rdf|rss|rss2|atom)/?$"";s:49:""index.php?attachment=$matches[1]&feed=$matches[2]"";s:41:""[^/]+/([^/]+)/comment-page-([0-9]{1,})/?$"";s:50:""index.php?attachment=$matches[1]&cpage=$matches[2]"";}","yes"
"1945","auto_core_update_notified","a:4:{s:4:""type"";s:6:""manual"";s:5:""email"";s:15:""you@example.com"";s:7:""version"";s:5:""4.2.2"";s:9:""timestamp"";i:1431511359;}","yes"
"11825","WPLANG",,"yes"
"11824","finished_splitting_shared_terms","1","yes"
"11826","db_upgraded","1","yes"
"11838","jetpack_file_data","a:1:{s:5:""3.8.2"";a:48:{s:32:""31e5b9ae08b62c2b0cd8a7792242298b"";a:14:{s:4:""name"";s:20:""Spelling and Grammar"";s:11:""description"";s:89:""Check your spelling, style, and grammar with the After the Deadline proofreading service."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:1:""6"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""1.1"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:7:""Writing"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:115:""after the deadline, afterthedeadline, spell, spellchecker, spelling, grammar, proofreading, style, language, cliche"";}s:32:""3f41b2d629265b5de8108b463abbe8e2"";a:14:{s:4:""name"";s:8:""Carousel"";s:11:""description"";s:63:""Transform standard image galleries into full-screen slideshows."";s:14:""jumpstart_desc"";s:79:""Brings your photos and images to life as full-size, easily navigable galleries."";s:4:""sort"";s:2:""22"";s:20:""recommendation_order"";s:2:""12"";s:10:""introduced"";s:3:""1.5"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:17:""Photos and Videos"";s:7:""feature"";s:9:""Jumpstart"";s:25:""additional_search_queries"";s:80:""gallery, carousel, diaporama, slideshow, images, lightbox, exif, metadata, image"";}s:32:""c6ebb418dde302de09600a6025370583"";a:14:{s:4:""name"";s:8:""Comments"";s:11:""description"";s:79:""Let readers comment with WordPress.com, Twitter, Facebook, or Google+ accounts."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""20"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""1.4"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:6:""Social"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:53:""comments, comment, facebook, twitter, google+, social"";}s:32:""836f9485669e1bbb02920cb474730df0"";a:14:{s:4:""name"";s:12:""Contact Form"";s:11:""description"";s:44:""Insert a contact form anywhere on your site."";s:14:""jumpstart_desc"";s:111:""Adds a button to your post and page editors, allowing you to build simple forms to help visitors stay in touch."";s:4:""sort"";s:2:""15"";s:20:""recommendation_order"";s:2:""14"";s:10:""introduced"";s:3:""1.3"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:5:""Other"";s:7:""feature"";s:9:""Jumpstart"";s:25:""additional_search_queries"";s:44:""contact, form, grunion, feedback, submission"";}s:32:""ea3970eebf8aac55fc3eca5dca0e0157"";a:14:{s:4:""name"";s:20:""Custom Content Types"";s:11:""description"";s:92:""Organize and display different types of content on your site, separate from posts and pages."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""34"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""3.1"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:7:""Writing"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:72:""cpt, custom post types, portfolio, portfolios, testimonial, testimonials"";}s:32:""d2bb05ccad3d8789df40ca3abb97336c"";a:14:{s:4:""name"";s:10:""Custom CSS"";s:11:""description"";s:57:""Customize your site’s CSS without modifying your theme."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:1:""2"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""1.7"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:10:""Appearance"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:108:""css, customize, custom, style, editor, less, sass, preprocessor, font, mobile, appearance, theme, stylesheet"";}s:32:""a2064eec5b9c7e0d816af71dee7a715f"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:0:"""";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:0:"""";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}s:32:""53a4ec755022ef3953699734c343da02"";a:14:{s:4:""name"";s:21:""Enhanced Distribution"";s:11:""description"";s:27:""Increase reach and traffic."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:1:""5"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""1.2"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:6:""Public"";s:11:""module_tags"";s:7:""Writing"";s:7:""feature"";s:7:""Traffic"";s:25:""additional_search_queries"";s:54:""google, seo, firehose, search, broadcast, broadcasting"";}s:32:""72fecb67ee6704ba0a33e0225316ad06"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:0:"""";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:0:"""";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}s:32:""d56e2886185a9eace719cc57d46770df"";a:14:{s:4:""name"";s:19:""Gravatar Hovercards"";s:11:""description"";s:58:""Enable pop-up business cards over commenters’ Gravatars."";s:14:""jumpstart_desc"";s:131:""Let commenters link their profiles to their Gravatar accounts, making it easy for your visitors to learn more about your community."";s:4:""sort"";s:2:""11"";s:20:""recommendation_order"";s:2:""13"";s:10:""introduced"";s:3:""1.1"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:18:""Social, Appearance"";s:7:""feature"";s:9:""Jumpstart"";s:25:""additional_search_queries"";s:20:""gravatar, hovercards"";}s:32:""e391e760617bd0e0736550e34a73d7fe"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:8:""2.0.3 ??"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}s:32:""2e345370766346c616b3c5046e817720"";a:14:{s:4:""name"";s:15:""Infinite Scroll"";s:11:""description"";s:46:""Add support for infinite scroll to your theme."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""26"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""2.0"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:10:""Appearance"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:33:""scroll, infinite, infinite scroll"";}s:32:""bd69edbf134de5fae8fdcf2e70a45b56"";a:14:{s:4:""name"";s:8:""JSON API"";s:11:""description"";s:69:""Allow applications to securely access your content through the cloud."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""19"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""1.9"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:6:""Public"";s:11:""module_tags"";s:19:""Writing, Developers"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:50:""api, rest, develop, developers, json, klout, oauth"";}s:32:""8110b7a4423aaa619dfa46b8843e10d1"";a:14:{s:4:""name"";s:14:""Beautiful Math"";s:11:""description"";s:85:""Use LaTeX markup language in posts and pages for complex equations and other geekery."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""12"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""1.1"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:7:""Writing"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:47:""latex, math, equation, equations, formula, code"";}s:32:""fd7e85d3b4887fa6b6f997d6592c1f33"";a:14:{s:4:""name"";s:5:""Likes"";s:11:""description"";s:70:""Give visitors an easy way to show their appreciation for your content."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""23"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""2.2"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:6:""Social"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:26:""like, likes, wordpress.com"";}s:32:""c5dfef41fad5bcdcaae8e315e5cfc420"";a:14:{s:4:""name"";s:6:""Manage"";s:11:""description"";s:76:""Manage all your sites from a centralized place, https://wordpress.com/sites."";s:14:""jumpstart_desc"";s:151:""Helps you remotely manage plugins, turn on automated updates, and more from <a href=""https://wordpress.com/plugins/"" target=""_blank"">wordpress.com</a>."";s:4:""sort"";s:1:""1"";s:20:""recommendation_order"";s:1:""3"";s:10:""introduced"";s:3:""3.4"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:35:""Centralized Management, Recommended"";s:7:""feature"";s:22:""Recommended, Jumpstart"";s:25:""additional_search_queries"";s:26:""manage, management, remote"";}s:32:""fd6dc399b92bce76013427e3107c314f"";a:14:{s:4:""name"";s:8:""Markdown"";s:11:""description"";s:51:""Write posts or pages in plain-text Markdown syntax."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""31"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""2.8"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:7:""Writing"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:12:""md, markdown"";}s:32:""c49a35b6482b0426cb07ad28ecf5d7df"";a:14:{s:4:""name"";s:12:""Mobile Theme"";s:11:""description"";s:64:""Optimize your site with a mobile-friendly theme for smartphones."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""21"";s:20:""recommendation_order"";s:2:""11"";s:10:""introduced"";s:3:""1.8"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:31:""Appearance, Mobile, Recommended"";s:7:""feature"";s:11:""Recommended"";s:25:""additional_search_queries"";s:24:""mobile, theme, minileven"";}s:32:""b42e38f6fafd2e4104ebe5bf39b4be47"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:0:"""";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:0:"""";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}s:32:""771cfeeba0d3d23ec344d5e781fb0ae2"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:0:"""";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:0:"""";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}s:32:""54f0661d27c814fc8bde39580181d939"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:0:"""";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:0:"""";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}s:32:""46c4c413b5c72bbd3c3dbd14ff8f8adc"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:0:"""";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:0:"""";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}s:32:""9ea52fa25783e5ceeb6bfaed3268e64e"";a:14:{s:4:""name"";s:7:""Monitor"";s:11:""description"";s:25:""Reports on site downtime."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""28"";s:20:""recommendation_order"";s:2:""10"";s:10:""introduced"";s:3:""2.6"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:11:""Recommended"";s:7:""feature"";s:33:""Recommended, Performance-Security"";s:25:""additional_search_queries"";s:37:""monitor, uptime, downtime, monitoring"";}s:32:""cfcaafd0fcad087899d715e0b877474d"";a:14:{s:4:""name"";s:13:""Notifications"";s:11:""description"";s:84:""Receive notification of site activity via the admin toolbar and your Mobile devices."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""13"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""1.9"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:5:""Other"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:62:""notification, notifications, toolbar, adminbar, push, comments"";}s:32:""0d18bfa69bec61550c1d813ce64149b0"";a:14:{s:4:""name"";s:10:""Omnisearch"";s:11:""description"";s:66:""Search your entire database from a single field in your Dashboard."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""16"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""2.3"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:10:""Developers"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:6:""search"";}s:32:""3f0a11e23118f0788d424b646a6d465f"";a:14:{s:4:""name"";s:6:""Photon"";s:11:""description"";s:27:""Speed up images and photos."";s:14:""jumpstart_desc"";s:141:""Mirrors and serves your images from our free and fast image CDN, improving your site’s performance with no additional load on your servers."";s:4:""sort"";s:2:""25"";s:20:""recommendation_order"";s:1:""1"";s:10:""introduced"";s:3:""2.0"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:42:""Photos and Videos, Appearance, Recommended"";s:7:""feature"";s:44:""Recommended, Jumpstart, Performance-Security"";s:25:""additional_search_queries"";s:38:""photon, image, cdn, performance, speed"";}s:32:""e37cfbcb72323fb1fe8255a2edb4d738"";a:14:{s:4:""name"";s:13:""Post by Email"";s:11:""description"";s:58:""Publish posts by email, using any device and email client."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""14"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""2.0"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:7:""Writing"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:20:""post by email, email"";}s:32:""728290d131a480bfe7b9e405d7cd925f"";a:14:{s:4:""name"";s:7:""Protect"";s:11:""description"";s:28:""Prevent brute force attacks."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:1:""1"";s:20:""recommendation_order"";s:1:""4"";s:10:""introduced"";s:3:""3.4"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:11:""Recommended"";s:7:""feature"";s:33:""Recommended, Performance-Security"";s:25:""additional_search_queries"";s:65:""security, secure, protection, botnet, brute force, protect, login"";}s:32:""f9ce784babbbf4dcca99b8cd2ceb420c"";a:14:{s:4:""name"";s:9:""Publicize"";s:11:""description"";s:30:""Automatically promote content."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""10"";s:20:""recommendation_order"";s:1:""7"";s:10:""introduced"";s:3:""2.0"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:19:""Social, Recommended"";s:7:""feature"";s:20:""Recommended, Traffic"";s:25:""additional_search_queries"";s:107:""facebook, twitter, google+, googleplus, google, path, tumblr, linkedin, social, tweet, connections, sharing"";}s:32:""052c03877dd3d296a71531cb07ad939a"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:0:"""";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:0:"""";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}s:32:""52edecb2a75222e75b2dce4356a4efce"";a:14:{s:4:""name"";s:13:""Related Posts"";s:11:""description"";s:24:""Display similar content."";s:14:""jumpstart_desc"";s:113:""Keep visitors engaged on your blog by highlighting relevant and new content at the bottom of each published post."";s:4:""sort"";s:2:""29"";s:20:""recommendation_order"";s:1:""9"";s:10:""introduced"";s:3:""2.9"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:11:""Recommended"";s:7:""feature"";s:31:""Recommended, Jumpstart, Traffic"";s:25:""additional_search_queries"";s:22:""related, related posts"";}s:32:""8b059cb50a66b717f1ec842e736b858c"";a:14:{s:4:""name"";s:7:""Sharing"";s:11:""description"";s:32:""Visitors can share your content."";s:14:""jumpstart_desc"";s:116:""Twitter, Facebook and Google+ buttons at the bottom of each post, making it easy for visitors to share your content."";s:4:""sort"";s:1:""7"";s:20:""recommendation_order"";s:1:""6"";s:10:""introduced"";s:3:""1.1"";s:7:""changed"";s:3:""1.2"";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:19:""Social, Recommended"";s:7:""feature"";s:31:""Recommended, Jumpstart, Traffic"";s:25:""additional_search_queries"";s:141:""share, sharing, sharedaddy, buttons, icons, email, facebook, twitter, google+, linkedin, pinterest, pocket, press this, print, reddit, tumblr"";}s:32:""a6d2394329871857401255533a9873f7"";a:14:{s:4:""name"";s:16:""Shortcode Embeds"";s:11:""description"";s:77:""Embed content from YouTube, Vimeo, SlideShare, and more, no coding necessary."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:1:""3"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""1.1"";s:7:""changed"";s:3:""1.2"";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:46:""Photos and Videos, Social, Writing, Appearance"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:251:""shortcodes, shortcode, embeds, media, bandcamp, blip.tv, dailymotion, digg, facebook, flickr, google calendars, google maps, google+, polldaddy, recipe, recipes, scribd, slideshare, slideshow, slideshows, soundcloud, ted, twitter, vimeo, vine, youtube"";}s:32:""21496e2897ea5f81605e2f2ac3beb921"";a:14:{s:4:""name"";s:16:""WP.me Shortlinks"";s:11:""description"";s:56:""Enable WP.me-powered shortlinks for all posts and pages."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:1:""8"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""1.1"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:6:""Social"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:17:""shortlinks, wp.me"";}s:32:""e2a54a5d7879a4162709e6ffb540dd08"";a:14:{s:4:""name"";s:9:""Site Icon"";s:11:""description"";s:29:""Add a site icon to your site."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""22"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""3.2"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:5:""Other"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:24:""favicon, icon, site icon"";}s:32:""59a23643437358a9b557f1d1e20ab040"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:0:"""";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:0:"""";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}s:32:""6a90f97c3194cfca5671728eaaeaf15e"";a:14:{s:4:""name"";s:14:""Single Sign On"";s:11:""description"";s:27:""Secure user authentication."";s:14:""jumpstart_desc"";s:98:""Lets you log in to all your Jetpack-enabled sites with one click using your WordPress.com account."";s:4:""sort"";s:2:""30"";s:20:""recommendation_order"";s:1:""5"";s:10:""introduced"";s:3:""2.6"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:10:""Developers"";s:7:""feature"";s:31:""Jumpstart, Performance-Security"";s:25:""additional_search_queries"";s:34:""sso, single sign on, login, log in"";}s:32:""b65604e920392e2f7134b646760b75e8"";a:14:{s:4:""name"";s:10:""Site Stats"";s:11:""description"";s:35:""Collect traffic stats and insights."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:1:""1"";s:20:""recommendation_order"";s:1:""2"";s:10:""introduced"";s:3:""1.1"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:23:""Site Stats, Recommended"";s:7:""feature"";s:20:""Recommended, Traffic"";s:25:""additional_search_queries"";s:54:""statistics, tracking, analytics, views, traffic, stats"";}s:32:""23a586dd7ead00e69ec53eb32ef740e4"";a:14:{s:4:""name"";s:13:""Subscriptions"";s:11:""description"";s:88:""Allow users to subscribe to your posts and comments and receive notifications via email."";s:14:""jumpstart_desc"";s:126:""Give visitors two easy subscription options — while commenting, or via a separate email subscription widget you can display."";s:4:""sort"";s:1:""9"";s:20:""recommendation_order"";s:1:""8"";s:10:""introduced"";s:3:""1.2"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:6:""Social"";s:7:""feature"";s:9:""Jumpstart"";s:25:""additional_search_queries"";s:74:""subscriptions, subscription, email, follow, followers, subscribers, signup"";}s:32:""1d978b8d84d2f378fe1a702a67633b6d"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:0:"""";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:0:"""";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}s:32:""b3b983461d7f3d27322a3551ed8a9405"";a:14:{s:4:""name"";s:15:""Tiled Galleries"";s:11:""description"";s:73:""Display your image galleries in a variety of sleek, graphic arrangements."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""24"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""2.1"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:2:""No"";s:11:""module_tags"";s:17:""Photos and Videos"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:43:""gallery, tiles, tiled, grid, mosaic, images"";}s:32:""d924e5b05722b0e104448543598f54c0"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:0:"""";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:0:"""";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}s:32:""36741583b10c521997e563ad8e1e8b77"";a:14:{s:4:""name"";s:10:""VaultPress"";s:11:""description"";s:27:""Backups and security scans."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""32"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:5:""0:1.2"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:5:""false"";s:4:""free"";s:5:""false"";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:20:""Performance-Security"";s:25:""additional_search_queries"";s:28:""vaultpress, backup, security"";}s:32:""2b9b44f09b5459617d68dd82ee17002a"";a:14:{s:4:""name"";s:17:""Site Verification"";s:11:""description"";s:77:""Verify your site or domain with Google Search Console, Pinterest, and others."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""33"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""3.0"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:56:""webmaster, seo, google, bing, pinterest, search, console"";}s:32:""5ab4c0db7c42e10e646342da0274c491"";a:14:{s:4:""name"";s:10:""VideoPress"";s:11:""description"";s:68:""Upload and embed videos right on your site. (Subscription required.)"";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""27"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""2.5"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:5:""false"";s:19:""requires_connection"";s:3:""Yes"";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:17:""Photos and Videos"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:25:""video, videos, videopress"";}s:32:""60a1d3aa38bc0fe1039e59dd60888543"";a:14:{s:4:""name"";s:17:""Widget Visibility"";s:11:""description"";s:57:""Specify which widgets appear on which pages of your site."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:2:""17"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""2.4"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:10:""Appearance"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:54:""widget visibility, logic, conditional, widgets, widget"";}s:32:""174ed3416476c2cb9ff5b0f671280b15"";a:14:{s:4:""name"";s:21:""Extra Sidebar Widgets"";s:11:""description"";s:79:""Add images, Twitter streams, your site’s RSS links, and more to your sidebar."";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:1:""4"";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:3:""1.2"";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:2:""No"";s:13:""auto_activate"";s:3:""Yes"";s:11:""module_tags"";s:18:""Social, Appearance"";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:65:""widget, widgets, facebook, gallery, twitter, gravatar, image, rss"";}s:32:""28b931a1db19bd24869bd54b14e733d5"";a:14:{s:4:""name"";s:0:"""";s:11:""description"";s:0:"""";s:14:""jumpstart_desc"";s:0:"""";s:4:""sort"";s:0:"""";s:20:""recommendation_order"";s:0:"""";s:10:""introduced"";s:0:"""";s:7:""changed"";s:0:"""";s:10:""deactivate"";s:0:"""";s:4:""free"";s:0:"""";s:19:""requires_connection"";s:0:"""";s:13:""auto_activate"";s:0:"""";s:11:""module_tags"";s:0:"""";s:7:""feature"";s:0:"""";s:25:""additional_search_queries"";s:0:"""";}}}","yes"
"15681","_transient_timeout_jetpack_site_is_vcs","1452727283","no"
"15682","_transient_jetpack_site_is_vcs","1","no"
"11835","jetpack_updates","a:7:{s:7:""plugins"";i:0;s:6:""themes"";i:0;s:9:""wordpress"";i:0;s:12:""translations"";i:0;s:5:""total"";i:0;s:10:""wp_version"";s:5:""4.4.1"";s:26:""site_is_version_controlled"";b:1;}","yes"
"11839","jetpack_available_modules","a:1:{s:5:""3.8.2"";a:36:{s:18:""after-the-deadline"";s:3:""1.1"";s:8:""carousel"";s:3:""1.5"";s:8:""comments"";s:3:""1.4"";s:12:""contact-form"";s:3:""1.3"";s:20:""custom-content-types"";s:3:""3.1"";s:10:""custom-css"";s:3:""1.7"";s:21:""enhanced-distribution"";s:3:""1.2"";s:19:""gravatar-hovercards"";s:3:""1.1"";s:15:""infinite-scroll"";s:3:""2.0"";s:8:""json-api"";s:3:""1.9"";s:5:""latex"";s:3:""1.1"";s:5:""likes"";s:3:""2.2"";s:6:""manage"";s:3:""3.4"";s:8:""markdown"";s:3:""2.8"";s:9:""minileven"";s:3:""1.8"";s:7:""monitor"";s:3:""2.6"";s:5:""notes"";s:3:""1.9"";s:10:""omnisearch"";s:3:""2.3"";s:6:""photon"";s:3:""2.0"";s:13:""post-by-email"";s:3:""2.0"";s:7:""protect"";s:3:""3.4"";s:9:""publicize"";s:3:""2.0"";s:13:""related-posts"";s:3:""2.9"";s:10:""sharedaddy"";s:3:""1.1"";s:10:""shortcodes"";s:3:""1.1"";s:10:""shortlinks"";s:3:""1.1"";s:9:""site-icon"";s:3:""3.2"";s:3:""sso"";s:3:""2.6"";s:5:""stats"";s:3:""1.1"";s:13:""subscriptions"";s:3:""1.2"";s:13:""tiled-gallery"";s:3:""2.1"";s:10:""vaultpress"";s:5:""0:1.2"";s:18:""verification-tools"";s:3:""3.0"";s:10:""videopress"";s:3:""2.5"";s:17:""widget-visibility"";s:3:""2.4"";s:7:""widgets"";s:3:""1.2"";}}","yes"
"11974","jetpack_security_report","a:0:{}","yes"
"15686","site_icon","0","yes"
"15687","medium_large_size_w","768","yes"
"15688","medium_large_size_h","0","yes"
"16092","_site_transient_update_core","O:8:""stdClass"":4:{s:7:""updates"";a:1:{i:0;O:8:""stdClass"":10:{s:8:""response"";s:6:""latest"";s:8:""download"";s:59:""https://downloads.wordpress.org/release/wordpress-4.4.2.zip"";s:6:""locale"";s:5:""en_US"";s:8:""packages"";O:8:""stdClass"":5:{s:4:""full"";s:59:""https://downloads.wordpress.org/release/wordpress-4.4.2.zip"";s:10:""no_content"";s:70:""https://downloads.wordpress.org/release/wordpress-4.4.2-no-content.zip"";s:11:""new_bundled"";s:71:""https://downloads.wordpress.org/release/wordpress-4.4.2-new-bundled.zip"";s:7:""partial"";b:0;s:8:""rollback"";b:0;}s:7:""current"";s:5:""4.4.2"";s:7:""version"";s:5:""4.4.2"";s:11:""php_version"";s:5:""5.2.4"";s:13:""mysql_version"";s:3:""5.0"";s:11:""new_bundled"";s:3:""4.4"";s:15:""partial_version"";s:0:"""";}}s:12:""last_checked"";i:1459029860;s:15:""version_checked"";s:5:""4.4.2"";s:12:""translations"";a:0:{}}","yes"
"16453","_site_transient_timeout_security_report_performed_recently","1456382259","yes"
"16454","_site_transient_security_report_performed_recently","1","yes"
"16455","_site_transient_timeout_ghu-1eda13567dd0e7ce35b07e674764d1ef","1456384962","yes"
"16456","_site_transient_ghu-1eda13567dd0e7ce35b07e674764d1ef","O:8:""stdClass"":12:{s:4:""name"";s:20:""mojo-marketplace.php"";s:4:""path"";s:20:""mojo-marketplace.php"";s:3:""sha"";s:40:""f8bb00c5dabbb77806a0b5a267869aedc15becf7"";s:4:""size"";i:2332;s:3:""url"";s:109:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/contents/mojo-marketplace.php?ref=production"";s:8:""html_url"";s:91:""https://github.com/mojoness/mojo-marketplace-wp-plugin/blob/production/mojo-marketplace.php"";s:7:""git_url"";s:115:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/git/blobs/f8bb00c5dabbb77806a0b5a267869aedc15becf7"";s:12:""download_url"";s:101:""https://raw.githubusercontent.com/mojoness/mojo-marketplace-wp-plugin/production/mojo-marketplace.php"";s:4:""type"";s:4:""file"";s:7:""content"";s:3164:""PD9waHAKLyoKUGx1Z2luIE5hbWU6IE1PSk8gTWFya2V0cGxhY2UKRGVzY3Jp
cHRpb246IFRoaXMgcGx1Z2luIGFkZHMgc2hvcnRjb2Rlcywgd2lkZ2V0cywg
YW5kIHRoZW1lcyB0byB5b3VyIFdvcmRQcmVzcyBzaXRlLgpWZXJzaW9uOiAw
LjcuMwpBdXRob3I6IE1pa2UgSGFuc2VuCkF1dGhvciBVUkk6IGh0dHA6Ly9t
aWtlaGFuc2VuLm1lP3V0bV9jYW1wYWlnbj1wbHVnaW4mdXRtX3NvdXJjZT1t
b2pvX3dwX3BsdWdpbgpMaWNlbnNlOiBHUEx2MiBvciBsYXRlcgpMaWNlbnNl
IFVSSTogaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC0yLjAuaHRt
bApHaXRIdWIgUGx1Z2luIFVSSTogbW9qb25lc3MvbW9qby1tYXJrZXRwbGFj
ZS13cC1wbHVnaW4KR2l0SHViIEJyYW5jaDogcHJvZHVjdGlvbgoqLwoKLy9E
byBub3QgYWNjZXNzIGZpbGUgZGlyZWN0bHkKaWYgKCAhIGRlZmluZWQoICdX
UElOQycgKSApIHsgZGllOyB9CgpkZWZpbmUoICdNTV9CQVNFX0RJUicsIHBs
dWdpbl9kaXJfcGF0aCggX19GSUxFX18gKSApOwpkZWZpbmUoICdNTV9CQVNF
X1VSTCcsIHBsdWdpbl9kaXJfdXJsKCBfX0ZJTEVfXyApICk7CgppZiAoIGZp
bGVfZXhpc3RzKCBNTV9CQVNFX0RJUiAuICdpbmMvYnJhbmQucGhwJyApICkg
ewoJcmVxdWlyZV9vbmNlKCBNTV9CQVNFX0RJUiAuICdpbmMvYnJhbmQucGhw
JyApOwp9CnJlcXVpcmVfb25jZSggTU1fQkFTRV9ESVIgLiAnaW5jL2Jhc2Uu
cGhwJyApOwpyZXF1aXJlX29uY2UoIE1NX0JBU0VfRElSIC4gJ2luYy9jaHVy
bi5waHAnICk7CnJlcXVpcmVfb25jZSggTU1fQkFTRV9ESVIgLiAnaW5jL21l
bnUucGhwJyApOwpyZXF1aXJlX29uY2UoIE1NX0JBU0VfRElSIC4gJ2luYy90
aGVtZXMtd2lkZ2V0LnBocCcgKTsKcmVxdWlyZV9vbmNlKCBNTV9CQVNFX0RJ
UiAuICdpbmMvc2hvcnRjb2RlLWdlbmVyYXRvci5waHAnICk7CnJlcXVpcmVf
b25jZSggTU1fQkFTRV9ESVIgLiAnaW5jL21vam8tdGhlbWVzLnBocCcgKTsK
cmVxdWlyZV9vbmNlKCBNTV9CQVNFX0RJUiAuICdpbmMvc3R5bGVzLnBocCcg
KTsKcmVxdWlyZV9vbmNlKCBNTV9CQVNFX0RJUiAuICdpbmMvcGx1Z2luLXNl
YXJjaC5waHAnICk7CnJlcXVpcmVfb25jZSggTU1fQkFTRV9ESVIgLiAnaW5j
L2pldHBhY2sucGhwJyApOwpyZXF1aXJlX29uY2UoIE1NX0JBU0VfRElSIC4g
J2luYy91c2VyLWV4cGVyaWVuY2UtdHJhY2tpbmcucGhwJyApOwpyZXF1aXJl
X29uY2UoIE1NX0JBU0VfRElSIC4gJ2luYy9ub3RpZmljYXRpb25zLnBocCcg
KTsKcmVxdWlyZV9vbmNlKCBNTV9CQVNFX0RJUiAuICdpbmMvc3BhbS1wcmV2
ZW50aW9uLnBocCcgKTsKcmVxdWlyZV9vbmNlKCBNTV9CQVNFX0RJUiAuICdp
bmMvdXBkYXRlcy5waHAnICk7CnJlcXVpcmVfb25jZSggTU1fQkFTRV9ESVIg
LiAnaW5jL2NvbWluZy1zb29uLnBocCcgKTsKcmVxdWlyZV9vbmNlKCBNTV9C
QVNFX0RJUiAuICdpbmMvdGVzdHMucGhwJyApOwpyZXF1aXJlX29uY2UoIE1N
X0JBU0VfRElSIC4gJ2luYy9lZGl0b3ItcHJvbXB0LnBocCcgKTsKbW1fcmVx
dWlyZSggTU1fQkFTRV9ESVIgLiAnaW5jL3Nzby5waHAnICk7CgovLyBMb2Fk
IGJhc2UgY2xhc3NlcyBmb3IgZ2l0aHViIHVwZGF0ZXIgb25seSBpbiB0aGUg
YWRtaW4gYW5kIG9ubHkgd2l0aCBjYXAKZnVuY3Rpb24gbW1fbG9hZF91cGRh
dGVyKCkgewoJaWYgKCBmaWxlX2V4aXN0cyggTU1fQkFTRV9ESVIgLiAndXBk
YXRlci5waHAnICkgKSB7CgkJbW1fcmVxdWlyZSggTU1fQkFTRV9ESVIgLiAn
dXBkYXRlci5waHAnICk7Cgl9IGVsc2UgaWYgKCBpc19hZG1pbigpICkgewoJ
CS8qCgkJQ2hlY2sgY2xhc3NfZXhpc3QgYmVjYXVzZSB0aGlzIGNvdWxkIGJl
IGxvYWRlZCBpbiBhIGRpZmZlcmVudCBwbHVnaW4KCQkqLwoJCWlmICggISBj
bGFzc19leGlzdHMoICdHaXRIdWJfVXBkYXRlcicgKSApIHsKCQkJcmVxdWly
ZV9vbmNlKCBNTV9CQVNFX0RJUiAuICd1cGRhdGVyL2NsYXNzLWdpdGh1Yi11
cGRhdGVyLnBocCcgKTsKCQl9CgkJaWYgKCAhIGNsYXNzX2V4aXN0cyggJ0dp
dEh1Yl9VcGRhdGVyX0dpdEh1Yl9BUEknICkgKSB7CgkJCXJlcXVpcmVfb25j
ZSggTU1fQkFTRV9ESVIgLiAndXBkYXRlci9jbGFzcy1naXRodWItYXBpLnBo
cCcgKTsKCQl9CgkJaWYgKCAhIGNsYXNzX2V4aXN0cyggJ0dpdEh1Yl9QbHVn
aW5fVXBkYXRlcicgKSApIHsKCQkJcmVxdWlyZV9vbmNlKCBNTV9CQVNFX0RJ
UiAuICd1cGRhdGVyL2NsYXNzLXBsdWdpbi11cGRhdGVyLnBocCcgKTsKCQl9
CgkJbmV3IEdpdEh1Yl9QbHVnaW5fVXBkYXRlcjsKCX0KfQphZGRfYWN0aW9u
KCAnYWRtaW5faW5pdCcsICdtbV9sb2FkX3VwZGF0ZXInICk7Cg==
"";s:8:""encoding"";s:6:""base64"";s:6:""_links"";O:8:""stdClass"":3:{s:4:""self"";s:109:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/contents/mojo-marketplace.php?ref=production"";s:3:""git"";s:115:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/git/blobs/f8bb00c5dabbb77806a0b5a267869aedc15becf7"";s:4:""html"";s:91:""https://github.com/mojoness/mojo-marketplace-wp-plugin/blob/production/mojo-marketplace.php"";}}","yes"
"16457","_site_transient_timeout_ghu-aca1a99da826e8036f3bd23a2dafb4ea","1456384962","yes"
"16458","_site_transient_ghu-aca1a99da826e8036f3bd23a2dafb4ea","O:8:""stdClass"":3:{s:11:""total_count"";i:1;s:18:""incomplete_results"";b:0;s:5:""items"";a:1:{i:0;O:8:""stdClass"":69:{s:2:""id"";i:16290496;s:4:""name"";s:26:""mojo-marketplace-wp-plugin"";s:9:""full_name"";s:35:""mojoness/mojo-marketplace-wp-plugin"";s:5:""owner"";O:8:""stdClass"":17:{s:5:""login"";s:8:""mojoness"";s:2:""id"";i:1278255;s:10:""avatar_url"";s:51:""https://avatars.githubusercontent.com/u/1278255?v=3"";s:11:""gravatar_id"";s:0:"""";s:3:""url"";s:37:""https://api.github.com/users/mojoness"";s:8:""html_url"";s:27:""https://github.com/mojoness"";s:13:""followers_url"";s:47:""https://api.github.com/users/mojoness/followers"";s:13:""following_url"";s:60:""https://api.github.com/users/mojoness/following{/other_user}"";s:9:""gists_url"";s:53:""https://api.github.com/users/mojoness/gists{/gist_id}"";s:11:""starred_url"";s:60:""https://api.github.com/users/mojoness/starred{/owner}{/repo}"";s:17:""subscriptions_url"";s:51:""https://api.github.com/users/mojoness/subscriptions"";s:17:""organizations_url"";s:42:""https://api.github.com/users/mojoness/orgs"";s:9:""repos_url"";s:43:""https://api.github.com/users/mojoness/repos"";s:10:""events_url"";s:54:""https://api.github.com/users/mojoness/events{/privacy}"";s:19:""received_events_url"";s:53:""https://api.github.com/users/mojoness/received_events"";s:4:""type"";s:12:""Organization"";s:10:""site_admin"";b:0;}s:7:""private"";b:0;s:8:""html_url"";s:54:""https://github.com/mojoness/mojo-marketplace-wp-plugin"";s:11:""description"";s:58:""WordPress plugin that has shortcodes, widgets and themes. "";s:4:""fork"";b:0;s:3:""url"";s:64:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin"";s:9:""forks_url"";s:70:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/forks"";s:8:""keys_url"";s:78:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/keys{/key_id}"";s:17:""collaborators_url"";s:93:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/collaborators{/collaborator}"";s:9:""teams_url"";s:70:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/teams"";s:9:""hooks_url"";s:70:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/hooks"";s:16:""issue_events_url"";s:87:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/issues/events{/number}"";s:10:""events_url"";s:71:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/events"";s:13:""assignees_url"";s:81:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/assignees{/user}"";s:12:""branches_url"";s:82:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/branches{/branch}"";s:8:""tags_url"";s:69:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/tags"";s:9:""blobs_url"";s:80:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/git/blobs{/sha}"";s:12:""git_tags_url"";s:79:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/git/tags{/sha}"";s:12:""git_refs_url"";s:79:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/git/refs{/sha}"";s:9:""trees_url"";s:80:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/git/trees{/sha}"";s:12:""statuses_url"";s:79:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/statuses/{sha}"";s:13:""languages_url"";s:74:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/languages"";s:14:""stargazers_url"";s:75:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/stargazers"";s:16:""contributors_url"";s:77:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/contributors"";s:15:""subscribers_url"";s:76:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/subscribers"";s:16:""subscription_url"";s:77:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/subscription"";s:11:""commits_url"";s:78:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/commits{/sha}"";s:15:""git_commits_url"";s:82:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/git/commits{/sha}"";s:12:""comments_url"";s:82:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/comments{/number}"";s:17:""issue_comment_url"";s:89:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/issues/comments{/number}"";s:12:""contents_url"";s:81:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/contents/{+path}"";s:11:""compare_url"";s:88:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/compare/{base}...{head}"";s:10:""merges_url"";s:71:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/merges"";s:11:""archive_url"";s:87:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/{archive_format}{/ref}"";s:13:""downloads_url"";s:74:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/downloads"";s:10:""issues_url"";s:80:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/issues{/number}"";s:9:""pulls_url"";s:79:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/pulls{/number}"";s:14:""milestones_url"";s:84:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/milestones{/number}"";s:17:""notifications_url"";s:104:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/notifications{?since,all,participating}"";s:10:""labels_url"";s:78:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/labels{/name}"";s:12:""releases_url"";s:78:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/releases{/id}"";s:15:""deployments_url"";s:76:""https://api.github.com/repos/mojoness/mojo-marketplace-wp-plugin/deployments"";s:10:""created_at"";s:20:""2014-01-27T19:47:10Z"";s:10:""updated_at"";s:20:""2016-01-13T19:02:46Z"";s:9:""pushed_at"";s:20:""2016-02-24T20:31:46Z"";s:7:""git_url"";s:56:""git://github.com/mojoness/mojo-marketplace-wp-plugin.git"";s:7:""ssh_url"";s:54:""git@github.com:mojoness/mojo-marketplace-wp-plugin.git"";s:9:""clone_url"";s:58:""https://github.com/mojoness/mojo-marketplace-wp-plugin.git"";s:7:""svn_url"";s:54:""https://github.com/mojoness/mojo-marketplace-wp-plugin"";s:8:""homepage"";N;s:4:""size"";i:1736;s:16:""stargazers_count"";i:2;s:14:""watchers_count"";i:2;s:8:""language"";s:3:""PHP"";s:10:""has_issues"";b:1;s:13:""has_downloads"";b:1;s:8:""has_wiki"";b:1;s:9:""has_pages"";b:0;s:11:""forks_count"";i:3;s:10:""mirror_url"";N;s:17:""open_issues_count"";i:1;s:5:""forks"";i:3;s:11:""open_issues"";i:1;s:8:""watchers"";i:2;s:14:""default_branch"";s:6:""master"";s:5:""score"";d:30.287206999999999;}}}","yes"
"16459","_site_transient_timeout_ghu-cd60ad3e4bd0d8706fc4a4f35f398ee5","1456384963","yes"
"16460","_site_transient_ghu-cd60ad3e4bd0d8706fc4a4f35f398ee5","no tags here","yes"
"16461","_site_transient_timeout_ghu-9bb54241f94b24d969f7f1e4865eb9ed","1456384963","yes"
"16462","_site_transient_ghu-9bb54241f94b24d969f7f1e4865eb9ed","O:8:""stdClass"":2:{s:7:""message"";s:9:""Not Found"";s:17:""documentation_url"";s:31:""https://developer.github.com/v3"";}","yes"
"16856","_transient_doing_cron","1459319589.4944519996643066406250","yes"
"1","2","_wp_page_template","default"
"2","4","_edit_last","1"
"3","4","_edit_lock","1407195745:1"
"306","94","_edit_last","1"
"6","4","dw-grid","normal"
"300","90","dw-grid","normal"
"301","92","_edit_last","1"
"18","9","visualizer-chart-type","pie"
"19","9","visualizer-default-data","0"
"20","9","visualizer-source","Visualizer_Source_Csv"
"21","9","visualizer-series","a:2:{i:0;a:2:{s:5:""label"";s:4:""Time"";s:4:""type"";s:6:""string"";}i:1;a:2:{s:5:""label"";s:17:""Number of Problem"";s:4:""type"";s:6:""number"";}}"
"46","19","_edit_lock","1405231922:1"
"40","17","_edit_last","1"
"22","9","visualizer-settings","a:20:{s:5:""title"";s:0:"""";s:14:""titleTextStyle"";a:1:{s:5:""color"";s:4:""#000"";}s:8:""fontName"";s:10:""Sans Serif"";s:8:""fontSize"";s:2:""15"";s:6:""legend"";a:3:{s:8:""position"";s:0:"""";s:9:""alignment"";s:0:"""";s:9:""textStyle"";a:1:{s:5:""color"";s:4:""#000"";}}s:7:""tooltip"";a:3:{s:7:""trigger"";s:0:"""";s:13:""showColorCode"";s:0:"""";s:4:""text"";s:0:"""";}s:4:""is3D"";s:1:""0"";s:17:""reverseCategories"";s:0:"""";s:12:""pieSliceText"";s:0:"""";s:7:""pieHole"";s:0:"""";s:13:""pieStartAngle"";s:0:"""";s:19:""pieSliceBorderColor"";s:7:""#212121"";s:24:""sliceVisibilityThreshold"";s:0:"""";s:20:""pieResidueSliceLabel"";s:0:"""";s:20:""pieResidueSliceColor"";s:4:""#ccc"";s:6:""slices"";a:3:{i:0;a:2:{s:6:""offset"";s:7:""#38d31d"";s:5:""color"";s:7:""#38d31d"";}i:1;a:2:{s:6:""offset"";s:7:""#002b51"";s:5:""color"";s:7:""#002b51"";}i:2;a:2:{s:6:""offset"";s:7:""#eaa235"";s:5:""color"";s:7:""#eaa235"";}}s:5:""width"";s:0:"""";s:6:""height"";s:0:"""";s:15:""backgroundColor"";a:3:{s:11:""strokeWidth"";s:0:"""";s:6:""stroke"";s:4:""#666"";s:4:""fill"";s:4:""#fff"";}s:9:""chartArea"";a:4:{s:4:""left"";s:0:"""";s:3:""top"";s:0:"""";s:5:""width"";s:0:"""";s:6:""height"";s:0:"""";}}"
"39","15","dw-grid","normal"
"36","15","_edit_lock","1402045823:1"
"35","15","_edit_last","1"
"45","19","_edit_last","1"
"43","17","dw-grid","normal"
"44","17","_edit_lock","1402045591:1"
"49","19","dw-grid","normal"
"54","22","_edit_last","1"
"59","24","_edit_last","1"
"57","22","dw-grid","normal"
"58","22","_edit_lock","1402045619:1"
"78","15","_wp_old_slug","problem-1-multiples-of-3-and-5"
"62","24","dw-grid","normal"
"63","24","_edit_lock","1402045639:1"
"90","24","_wp_old_slug","problem-5-smallest-multiple"
"94","33","_wp_attachment_metadata","a:5:{s:5:""width"";i:1600;s:6:""height"";i:660;s:4:""file"";s:57:""2014/06/clear-sky-nature-hd-wallpaper-1920x1080-38291.jpg"";s:5:""sizes"";a:3:{s:9:""thumbnail"";a:4:{s:4:""file"";s:57:""clear-sky-nature-hd-wallpaper-1920x1080-38291-150x150.jpg"";s:5:""width"";i:150;s:6:""height"";i:150;s:9:""mime-type"";s:10:""image/jpeg"";}s:6:""medium"";a:4:{s:4:""file"";s:57:""clear-sky-nature-hd-wallpaper-1920x1080-38291-300x123.jpg"";s:5:""width"";i:300;s:6:""height"";i:123;s:9:""mime-type"";s:10:""image/jpeg"";}s:5:""large"";a:4:{s:4:""file"";s:58:""clear-sky-nature-hd-wallpaper-1920x1080-38291-1024x422.jpg"";s:5:""width"";i:1024;s:6:""height"";i:422;s:9:""mime-type"";s:10:""image/jpeg"";}}s:10:""image_meta"";a:10:{s:8:""aperture"";i:0;s:6:""credit"";s:0:"""";s:6:""camera"";s:0:"""";s:7:""caption"";s:0:"""";s:17:""created_timestamp"";i:0;s:9:""copyright"";s:0:"""";s:12:""focal_length"";i:0;s:3:""iso"";i:0;s:13:""shutter_speed"";i:0;s:5:""title"";s:0:"""";}}"
"81","17","_wp_old_slug","problem-2-even-fibonacci-numbers"
"93","33","_wp_attached_file","2014/06/clear-sky-nature-hd-wallpaper-1920x1080-38291.jpg"
"84","19","_wp_old_slug","problem-3-largest-prime-factor"
"87","22","_wp_old_slug","problem-4-largest-palindrome-product"
"95","34","_menu_item_type","custom"
"96","34","_menu_item_menu_item_parent","0"
"97","34","_menu_item_object_id","34"
"98","34","_menu_item_object","custom"
"99","34","_menu_item_target",
"100","34","_menu_item_classes","a:1:{i:0;s:0:"""";}"
"101","34","_menu_item_xfn",
"102","34","_menu_item_url","http://ltran.co/"
"123","37","_edit_lock","1402135614:1"
"122","37","_edit_last","1"
"128","39","_edit_lock","1402135641:1"
"127","39","_edit_last","1"
"126","37","dw-grid","normal"
"137","43","_edit_last","1"
"131","39","dw-grid","normal"
"132","41","_edit_last","1"
"133","41","_edit_lock","1402135674:1"
"141","43","dw-grid","normal"
"136","41","dw-grid","normal"
"138","43","_edit_lock","1403716484:1"
"142","45","_edit_last","1"
"143","45","_edit_lock","1402135846:1"
"147","47","_edit_last","1"
"148","47","_edit_lock","1402135955:1"
"146","45","dw-grid","normal"
"153","49","_edit_lock","1402135955:1"
"152","49","_edit_last","1"
"151","47","dw-grid","normal"
"158","51","_edit_lock","1402135956:1"
"157","51","_edit_last","1"
"156","49","dw-grid","normal"
"225","72","_edit_last","1"
"224","70","dw-grid","normal"
"161","51","dw-grid","normal"
"169","41","_wp_old_slug","problem-8-largest-product-in-a-series"
"166","39","_wp_old_slug","problem-7-10001st-prime"
"219","68","dw-grid","normal"
"172","43","_wp_old_slug","problem-9-special-pythagorean-triplet"
"175","45","_wp_old_slug","problem-10-summation-of-primes"
"178","47","_wp_old_slug","problem-11-largest-product-in-a-grid"
"181","49","_wp_old_slug","problem-12-highly-divisible-triangular-number"
"220","70","_edit_last","1"
"184","51","_wp_old_slug","problem-13-large-sum"
"226","72","_edit_lock","1402136958:1"
"221","70","_edit_lock","1402136862:1"
"215","68","_edit_last","1"
"216","68","_edit_lock","1402136843:1"
"231","74","_edit_lock","1402137023:1"
"230","74","_edit_last","1"
"229","72","dw-grid","normal"
"236","76","_edit_lock","1402137103:1"
"235","76","_edit_last","1"
"234","74","dw-grid","normal"
"241","78","_edit_lock","1402136956:1"
"240","78","_edit_last","1"
"239","76","dw-grid","full"
"248","81","_edit_lock","1402137102:1"
"244","78","dw-grid","normal"
"247","81","_edit_last","1"
"302","92","_edit_lock","1402482176:1"
"251","81","dw-grid","normal"
"292","88","_edit_lock","1402482186:1"
"268","72","_wp_old_slug","problem-16-power-digit-sum"
"291","88","_edit_last","1"
"262","68","_wp_old_slug","problem-14-longest-collatz-sequence"
"271","74","_wp_old_slug","problem-17-number-letter-counts"
"265","70","_wp_old_slug","problem-15-lattice-paths"
"274","76","_wp_old_slug","problem-18-maximum-path-sum-1"
"277","78","_wp_old_slug","problem-19-counting-sundays"
"280","81","_wp_old_slug","problem-20-factorial-digit-sum"
"297","90","_edit_lock","1402482182:1"
"305","92","dw-grid","normal"
"295","88","dw-grid","normal"
"296","90","_edit_last","1"
"307","94","_edit_lock","1402482171:1"
"312","96","_edit_lock","1402482164:1"
"311","96","_edit_last","1"
"310","94","dw-grid","normal"
"315","96","dw-grid","normal"
"327","98","_wp_attachment_metadata","a:5:{s:5:""width"";i:16;s:6:""height"";i:16;s:4:""file"";s:19:""2014/06/favicon.png"";s:5:""sizes"";a:0:{}s:10:""image_meta"";a:10:{s:8:""aperture"";i:0;s:6:""credit"";s:0:"""";s:6:""camera"";s:0:"""";s:7:""caption"";s:0:"""";s:17:""created_timestamp"";i:0;s:9:""copyright"";s:0:"""";s:12:""focal_length"";i:0;s:3:""iso"";i:0;s:13:""shutter_speed"";i:0;s:5:""title"";s:0:"""";}}"
"326","98","_wp_attached_file","2014/06/favicon.png"
"328","100","_edit_last","1"
"329","100","_edit_lock","1402813937:1"
"334","102","_edit_lock","1402813912:1"
"333","102","_edit_last","1"
"332","100","dw-grid","normal"
"374","112","_edit_lock","1402814295:1"
"337","102","dw-grid","normal"
"338","104","_edit_last","1"
"339","104","_edit_lock","1402813886:1"
"349","108","_edit_lock","1402813852:1"
"342","104","dw-grid","normal"
"343","106","_edit_last","1"
"344","106","_edit_lock","1402813867:1"
"372","110","dw-grid","normal"
"348","108","_edit_last","1"
"347","106","dw-grid","normal"
"352","108","dw-grid","normal"
"355","108","_wp_old_slug","problem-27-quadratic-primes"
"358","106","_wp_old_slug","problem-28-number-spiral-diagonals"
"361","104","_wp_old_slug","problem-29-distinct-powers"
"373","112","_edit_last","1"
"369","110","_edit_lock","1402814314:1"
"364","102","_wp_old_slug","problem-30-digit-fifth-powers"
"368","110","_edit_last","1"
"367","100","_wp_old_slug","problem-33-digit-canceling-fractions"
"379","114","_edit_lock","1402814277:1"
"378","114","_edit_last","1"
"377","112","dw-grid","normal"
"384","116","_edit_lock","1402814260:1"
"383","116","_edit_last","1"
"382","114","dw-grid","normal"
"389","118","_edit_lock","1402814658:1"
"388","118","_edit_last","1"
"387","116","dw-grid","normal"
"394","120","_edit_lock","1402814232:1"
"393","120","_edit_last","1"
"392","118","dw-grid","normal"
"416","122","_edit_lock","1402814939:1"
"397","120","dw-grid","normal"
"406","114","_wp_old_slug","problem-37-truncatable-primes"
"400","120","_wp_old_slug","problem-34-digit-factorials"
"403","116","_wp_old_slug","problem-36-double-base-palindromes"
"415","122","_edit_last","1"
"409","112","_wp_old_slug","problem-38-pandigital-multiples"
"412","110","_wp_old_slug","problem-39-integer-right-triangles"
"421","124","_edit_lock","1402815828:1"
"420","124","_edit_last","1"
"419","122","dw-grid","normal"
"426","126","_edit_lock","1402814910:1"
"425","126","_edit_last","1"
"424","124","dw-grid","normal"
"431","128","_edit_lock","1402814892:1"
"430","128","_edit_last","1"
"429","126","dw-grid","normal"
"436","130","_edit_lock","1402814873:1"
"435","130","_edit_last","1"
"434","128","dw-grid","normal"
"450","126","_wp_old_slug","problem-42-coded-triangle-numbers"
"439","130","dw-grid","normal"
"442","130","_wp_old_slug","problem-40-champernownes-constant"
"457","132","_edit_last","1"
"445","128","_wp_old_slug","problem-41-pandigital-prime"
"456","122","_wp_old_slug","problem-44-pentagon-numbers"
"458","132","_edit_lock","1402815469:1"
"453","124","_wp_old_slug","problem-43-sub-string-divisibility"
"465","135","_edit_lock","1402815442:1"
"461","132","dw-grid","full"
"464","135","_edit_last","1"
"470","137","_edit_lock","1402815428:1"
"469","137","_edit_last","1"
"468","135","dw-grid","normal"
"475","139","_edit_lock","1402815414:1"
"474","139","_edit_last","1"
"473","137","dw-grid","normal"
"480","141","_edit_lock","1402815395:1"
"479","141","_edit_last","1"
"478","139","dw-grid","normal"
"485","143","_edit_lock","1402815381:1"
"484","143","_edit_last","1"
"483","141","dw-grid","normal"
"497","139","_wp_old_slug","problem-47-distinct-prime-factors"
"488","143","dw-grid","normal"
"503","135","_wp_old_slug","problem-56-powerful-digit-sum"
"491","143","_wp_old_slug","problem-45-triangular-pentagonal-and-hexagonal"
"494","141","_wp_old_slug","problem-46-goldbachs-other-conjecture"
"500","137","_wp_old_slug","problem-48-self-powers"
"506","132","_wp_old_slug","problem-67-maximum-path-sum-2"
"701","33","_edit_lock","1402904791:1"
"2","0","2014-06-04 11:00:26","2014-06-04 11:00:26","This is an example page. It's different from a blog post because it will stay in one place and will show up in your site navigation (in most themes). Most people start with an About page that introduces them to potential site visitors. It might say something like this:

<blockquote>Hi there! I'm a bike messenger by day, aspiring actor by night, and this is my blog. I live in Los Angeles, have a great dog named Jack, and I like pi&#241;a coladas. (And gettin' caught in the rain.)</blockquote>

...or something like this:

<blockquote>The XYZ Doohickey Company was founded in 1971, and has been providing quality doohickeys to the public ever since. Located in Gotham City, XYZ employs over 2,000 people and does all kinds of awesome things for the Gotham community.</blockquote>

As a new WordPress user, you should go to <a href=""http://euler.lvtran.com/wp-admin/"">your dashboard</a> to delete this page and create new pages for your content. Have fun!","Sample Page",,"publish","open","open",,"sample-page",,,"2014-06-04 11:00:26","2014-06-04 11:00:26",,"0","http://euler.lvtran.com/?page_id=2","0","page",,"0"
"4","1","2013-12-31 11:07:10","2013-12-31 11:07:10","""Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems."" - <a style=""color: #3399ff;"" href=""http://www.projecteuler.net"">projecteuler.net</a>
<br>
<img class=""aligncenter size-full wp-image-257"" alt=""eulerBadge"" src=""http://www.lvtran.com/wp-content/uploads/2014/01/eulerBadge.png"" width=""200"" height=""60"" />
My language of choice is <b>Java</b>, of course. The official rule limits solutions' execution time to 1 minute or less. I am a really big fan of optimization, however, so I keep mine under <b>1 second</b>. Who likes waiting anyway?

[visualizer id=""9""] 
The chart shows my solutions' execution time in milliseconds; these executions were done on a 3rd-gen Intel® Core™ i7-3632QM quad-core. Please surf through the solved problems and suggest improvements where needed!","Project Euler",,"publish","closed","closed",,"project-euler",,,"2014-06-15 07:08:33","2014-06-15 07:08:33",,"0","http://euler.lvtran.com/?p=4","0","post",,"0"
"5","1","2014-06-04 11:07:10","2014-06-04 11:07:10","Testing","Project Euler",,"inherit","open","open",,"4-revision-v1",,,"2014-06-04 11:07:10","2014-06-04 11:07:10",,"4","http://euler.lvtran.com/?p=5","0","revision",,"0"
"8","1","2014-06-05 03:20:46","2014-06-05 03:20:46","""Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems."" - <a style=""color: #3399ff;"" href=""http://www.projecteuler.net"">projecteuler.net</a>
<img class=""aligncenter size-full wp-image-257"" alt=""eulerBadge"" src=""http://www.lvtran.com/wp-content/uploads/2014/01/eulerBadge.png"" width=""200"" height=""60"" />
My language of choice is <b>Java</b>, of course. The official rule limits solutions' execution time to 1 minute or less. I am a really big fan of optimization, however, so I keep mine under <b>1 second</b>. Who likes waiting anyway?
[visualizer id=""128""]

The chart shows my solutions' execution time in milliseconds; these executions were done on a 3rd-gen Intel® Core™ i7-3632QM quad-core. Please surf through the solved problems and suggest improvements where needed!","Project Euler",,"inherit","open","open",,"4-revision-v1",,,"2014-06-05 03:20:46","2014-06-05 03:20:46",,"4","http://euler.lvtran.com/4-revision-v1/","0","revision",,"0"
"9","1","2014-06-05 21:07:16","2014-06-05 21:07:16","a:3:{i:0;a:2:{i:0;s:7:""< 10 ms"";i:1;d:20;}i:1;a:2:{i:0;s:14:""10 ms - 100 ms"";i:1;d:24;}i:2;a:2:{i:0;s:11:""100 ms - 1s"";i:1;d:2;}}","Visualization",,"publish","open","open",,"visualization",,,"2014-06-05 21:07:16","2014-06-05 21:07:16",,"0","http://euler.lvtran.com/?post_type=visualizer&#038;p=9","0","visualizer",,"0"
"10","1","2014-06-05 21:07:56","2014-06-05 21:07:56","""Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems."" - <a style=""color: #3399ff;"" href=""http://www.projecteuler.net"">projecteuler.net</a>
<br>
<img class=""aligncenter size-full wp-image-257"" alt=""eulerBadge"" src=""http://www.lvtran.com/wp-content/uploads/2014/01/eulerBadge.png"" width=""200"" height=""60"" />
My language of choice is <b>Java</b>, of course. The official rule limits solutions' execution time to 1 minute or less. I am a really big fan of optimization, however, so I keep mine under <b>1 second</b>. Who likes waiting anyway?
<br>
[visualizer id=""9""] 
The chart shows my solutions' execution time in milliseconds; these executions were done on a 3rd-gen Intel® Core™ i7-3632QM quad-core. Please surf through the solved problems and suggest improvements where needed!","Project Euler",,"inherit","open","open",,"4-revision-v1",,,"2014-06-05 21:07:56","2014-06-05 21:07:56",,"4","http://euler.lvtran.com/4-revision-v1/","0","revision",,"0"
"11","1","2014-06-05 21:12:06","2014-06-05 21:12:06","""Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems."" - <a style=""color: #3399ff;"" href=""http://www.projecteuler.net"">projecteuler.net</a>
<br>
<img class=""aligncenter size-full wp-image-257"" alt=""eulerBadge"" src=""http://www.lvtran.com/wp-content/uploads/2014/01/eulerBadge.png"" width=""200"" height=""60"" />
My language of choice is <b>Java</b>, of course. The official rule limits solutions' execution time to 1 minute or less. I am a really big fan of optimization, however, so I keep mine under <b>1 second</b>. Who likes waiting anyway?
[visualizer id=""9""] 
The chart shows my solutions' execution time in milliseconds; these executions were done on a 3rd-gen Intel® Core™ i7-3632QM quad-core. Please surf through the solved problems and suggest improvements where needed!","Project Euler",,"inherit","open","open",,"4-revision-v1",,,"2014-06-05 21:12:06","2014-06-05 21:12:06",,"4","http://euler.lvtran.com/4-revision-v1/","0","revision",,"0"
"12","1","2014-06-06 08:27:16","2014-06-06 08:27:16","""Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems."" - <a style=""color: #3399ff;"" href=""http://www.projecteuler.net"">projecteuler.net</a>
<br>
<img class=""aligncenter size-full wp-image-257"" alt=""eulerBadge"" src=""http://www.lvtran.com/wp-content/uploads/2014/01/eulerBadge.png"" width=""200"" height=""60"" />
My language of choice is <b>Java</b>, of course. The official rule limits solutions' execution time to 1 minute or less. I am a really big fan of optimization, however, so I keep mine under <b>1 second</b>. Who likes waiting anyway?<!--more-->


[visualizer id=""9""] 
The chart shows my solutions' execution time in milliseconds; these executions were done on a 3rd-gen Intel® Core™ i7-3632QM quad-core. Please surf through the solved problems and suggest improvements where needed!","Project Euler",,"inherit","open","open",,"4-autosave-v1",,,"2014-06-06 08:27:16","2014-06-06 08:27:16",,"4","http://euler.lvtran.com/4-autosave-v1/","0","revision",,"0"
"7","1","2014-06-05 03:19:06","2014-06-05 03:19:06","""Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems."" - <a style=""color: #3399ff;"" href=""http://www.projecteuler.net"">projecteuler.net</a>
<img class=""aligncenter size-full wp-image-257"" alt=""eulerBadge"" src=""http://www.lvtran.com/wp-content/uploads/2014/01/eulerBadge.png"" width=""200"" height=""60"" />
My language of choice is <b>Java</b>, of course. The official rule limits solutions' execution time to 1 minute or less. I am a really big fan of optimization, however, so I keep mine under <b>1 second</b>. Who likes waiting anyway?
[visualizer id=""128""]

The chart shows my solutions' execution time in milliseconds; these executions were done on a 3rd-gen Intel® Core™ i7-3632QM quad-core. Please surf through the solved problems and suggest improvements where needed!

<a style=""color: #3399ff;"" href=""http://lvtran.com/p56/"" target=""_blank"">Problem 56</a><a style=""color: #3399ff;"" href=""http://lvtran.com/p67/"" target=""_blank"">Problem 67</a>
<table>
<tbody>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p1/"" target=""_blank"">Problem 1</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p2/"" target=""_blank"">Problem 2</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p3/"" target=""_blank"">Problem 3</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p4/"" target=""_blank"">Problem 4</a></td>
</tr>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p5/"" target=""_blank"">Problem 5</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p6/"" target=""_blank"">Problem 6</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p7/"" target=""_blank"">Problem 7</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p8/"" target=""_blank"">Problem 8</a></td>
</tr>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p9/"" target=""_blank"">Problem 9</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p10/"" target=""_blank"">Problem 10</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p11/"" target=""_blank"">Problem 11</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p12/"" target=""_blank"">Problem 12</a></td>
</tr>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p13/"" target=""_blank"">Problem 13</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p14/"" target=""_blank"">Problem 14</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p15/"" target=""_blank"">Problem 15</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p16/"" target=""_blank"">Problem 16</a></td>
</tr>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p17/"" target=""_blank"">Problem 17</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p18/"" target=""_blank"">Problem 18</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p19/"" target=""_blank"">Problem 19</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p20/"" target=""_blank"">Problem 20</a></td>
</tr>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p21/"" target=""_blank"">Problem 21</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p22/"" target=""_blank"">Problem 22</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p23/"" target=""_blank"">Problem 23</a></td>
</tr>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p25/"" target=""_blank"">Problem 25</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p26/"" target=""_blank"">Problem 26</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p27/"" target=""_blank"">Problem 27</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p28/"" target=""_blank"">Problem 28</a></td>
</tr>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p29/"" target=""_blank"">Problem 29</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p30/"" target=""_blank"">Problem 30</a></td>
</tr>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p33/"" target=""_blank"">Problem 33</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p34/"" target=""_blank"">Problem 34</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p35/"" target=""_blank"">Problem 35</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p36/"" target=""_blank"">Problem 36</a></td>
</tr>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p37/"" target=""_blank"">Problem 37</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p38/"" target=""_blank"">Problem 38</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p39/"" target=""_blank"">Problem 39</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p40/"" target=""_blank"">Problem 40</a></td>
</tr>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p41/"" target=""_blank"">Problem 41</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p42/"" target=""_blank"">Problem 42</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p43/"" target=""_blank"">Problem 43</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p44/"" target=""_blank"">Problem 44</a></td>
</tr>
<tr>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p45/"" target=""_blank"">Problem 45</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p46/"" target=""_blank"">Problem 46</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p47/"" target=""_blank"">Problem 47</a></td>
<td><a style=""color: #3399ff;"" href=""http://lvtran.com/p48/"" target=""_blank"">Problem 48</a></td>
</tr>
</tbody>
</table>","Project Euler",,"inherit","open","open",,"4-revision-v1",,,"2014-06-05 03:19:06","2014-06-05 03:19:06",,"4","http://euler.lvtran.com/4-revision-v1/","0","revision",,"0"
"14","1","2014-06-06 08:29:54","2014-06-06 08:29:54","""Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems."" - <a style=""color: #3399ff;"" href=""http://www.projecteuler.net"">projecteuler.net</a>
<br>
<img class=""aligncenter size-full wp-image-257"" alt=""eulerBadge"" src=""http://www.lvtran.com/wp-content/uploads/2014/01/eulerBadge.png"" width=""200"" height=""60"" />
My language of choice is <b>Java</b>, of course. The official rule limits solutions' execution time to 1 minute or less. I am a really big fan of optimization, however, so I keep mine under <b>1 second</b>. Who likes waiting anyway?

[visualizer id=""9""] 
The chart shows my solutions' execution time in milliseconds; these executions were done on a 3rd-gen Intel® Core™ i7-3632QM quad-core. Please surf through the solved problems and suggest improvements where needed!","Project Euler",,"inherit","open","open",,"4-revision-v1",,,"2014-06-06 08:29:54","2014-06-06 08:29:54",,"4","http://euler.lvtran.com/4-revision-v1/","0","revision",,"0"
"13","1","2014-06-06 08:27:31","2014-06-06 08:27:31","""Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems."" - <a style=""color: #3399ff;"" href=""http://www.projecteuler.net"">projecteuler.net</a>
<br>
<img class=""aligncenter size-full wp-image-257"" alt=""eulerBadge"" src=""http://www.lvtran.com/wp-content/uploads/2014/01/eulerBadge.png"" width=""200"" height=""60"" />
My language of choice is <b>Java</b>, of course. The official rule limits solutions' execution time to 1 minute or less. I am a really big fan of optimization, however, so I keep mine under <b>1 second</b>. Who likes waiting anyway?<!--more-->


[visualizer id=""9""] 
The chart shows my solutions' execution time in milliseconds; these executions were done on a 3rd-gen Intel® Core™ i7-3632QM quad-core. Please surf through the solved problems and suggest improvements where needed!","Project Euler",,"inherit","open","open",,"4-revision-v1",,,"2014-06-06 08:27:31","2014-06-06 08:27:31",,"4","http://euler.lvtran.com/4-revision-v1/","0","revision",,"0"
"15","1","2013-12-28 08:59:31","2013-12-28 08:59:31","<p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. </p><br>
<!--more-->
<h2>The Catch</h2>
<p>How to check if an arbitrary number <strong>x</strong> is evenly divisible by 3 or 5.</p>
<h2>The Light</h2>
<p>To check for divisibility, use modulus operation (<strong>%</strong>), which calculates the remainder of <strong>x</strong> divides by<strong> a</strong>, where a != 0. If <strong>x % a == 0</strong>, then the division of<strong> x</strong> by<strong> a</strong> leaves no remainder, or <strong>x</strong> is divisible by <strong>a</strong> (In Discrete Mathematics, this is written as x | a).</p>
<h2>The Code</h2>
[java]public class Problem1
{
  public static void main(String[] args)
  {
    int sum = 0;
    for(int i = 0; i &lt; 1000; i++)
    { 
      if(i % 3 == 0 || i % 5 == 0)
        sum += i;
    }
    System.out.println(sum);
  }
}[/java]
[java]Execution time: 0 ms.[/java]","Problem 1: Multiples of 3 and 5",,"publish","closed","closed",,"p1",,,"2014-06-15 07:08:33","2014-06-15 07:08:33",,"0","http://euler.lvtran.com/?p=15","0","post",,"0"
"16","1","2014-06-06 08:43:31","2014-06-06 08:43:31","<h2>The Problem</h2> 
<p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. </p><br>
<!--more-->
<h2>The Catch</h2>
<p>How to check if an arbitrary number <strong>x</strong> is evenly divisible by 3 or 5.</p>
<h2>The Light</h2>
<p>To check for divisibility, use modulus operation (<strong>%</strong>), which calculates the remainder of <strong>x</strong> divides by<strong> a</strong>, where a != 0. If <strong>x % a == 0</strong>, then the division of<strong> x</strong> by<strong> a</strong> leaves no remainder, or <strong>x</strong> is divisible by <strong>a</strong> (In Discrete Mathematics, this is written as x | a).</p>
<h2>The Code</h2>
[java]public class Problem1
{
  public static void main(String[] args)
  {
    int sum = 0;
    for(int i = 0; i &lt; 1000; i++)
    { 
      if(i % 3 == 0 || i % 5 == 0)
        sum += i;
    }
    System.out.println(sum);
  }
}[/java]
[java]Execution time: 0 ms.[/java]","Problem 1: Multiples of 3 and 5",,"inherit","open","open",,"15-revision-v1",,,"2014-06-06 08:43:31","2014-06-06 08:43:31",,"15","http://euler.lvtran.com/15-revision-v1/","0","revision",,"0"
"17","1","2013-12-28 08:57:24","2013-12-28 08:57:24","<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
<!--more-->
<h2>The Catch</h2>
<p>How to efficiently generate a Fibonacci sequence.<br>
How to pick out the even-valued Fibonacci number.</p>
<h2>The Light</h2>
<p>The recursive approach to generating a Fibonacci sequence (time complexity of <b>O(2<sup>n</sup>)</b>) might not be as elegant as an iterative one. Consider this piece of code, which prints all Fibonacci numbers under 10 using the iterative approach (time complexity of <b>O(n)</b>). For every fibonacciNumber created, check if it is divisible by 2 to pick out the even-valued ones. Sum them up to find the answer.</p>
[java]int firstNumber = 1;
int secondNumber = 2;
int fibonacciNumber = 0;

System.out.print(firstNumber + "" "" + secondNumber);
while(fibonacciNumber &lt; 10)
{
  fibonacciNumber = firstNumber + secondNumber;
  System.out.print("" "" + fibonacciNumber);
  firstNumber = secondNumber;
  secondNumber = fibonacciNumber;
}[/java]
<h2>The Code</h2>
[java]
public class Problem2
{
  public static void main(String[] args)
  {
    fib(); 
  }

  public static void fib()
  {
    int f1 = 1;
    int f2 = 1;
    int fib = 0;
    int sum = 0;

    while(fib < 4000000)
    {
      fib = f1 + f2;
      if(fib % 2 == 0)
        sum += fib;

      f1 = f2;
      f2 = fib;
    }
    System.out.println(sum);
  }
}[/java]
[java]Execution time: 1 ms.[/java]","Problem 2: Even Fibonacci Numbers",,"publish","closed","closed",,"p2",,,"2014-06-15 07:08:34","2014-06-15 07:08:34",,"0","http://euler.lvtran.com/?p=17","0","post",,"0"
"18","1","2014-06-06 08:57:24","2014-06-06 08:57:24","<h2>The Problem</h2> 
<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
<h2>The Catch</h2>
<p>How to efficiently generate a Fibonacci sequence.<br>
How to pick out the even-valued Fibonacci number.</p>
<h2>The Light</h2>
<p>The recursive approach to generating a Fibonacci sequence (time complexity of <b>O(2<sup>n</sup>)</b>) might not be as elegant as an iterative one. Consider this piece of code, which prints all Fibonacci numbers under 10 using the iterative approach (time complexity of <b>O(n)</b>). For every fibonacciNumber created, check if it is divisible by 2 to pick out the even-valued ones. Sum them up to find the answer.</p>
[java]int firstNumber = 1;
int secondNumber = 2;
int fibonacciNumber = 0;

System.out.print(firstNumber + "" "" + secondNumber);
while(fibonacciNumber &lt; 10)
{
  fibonacciNumber = firstNumber + secondNumber;
  System.out.print("" "" + fibonacciNumber);
  firstNumber = secondNumber;
  secondNumber = fibonacciNumber;
}[/java]
<h2>The Code</h2>
[java]
public class Problem2
{
  public static void main(String[] args)
  {
    fib(); 
  }

  public static void fib()
  {
    int f1 = 1;
    int f2 = 1;
    int fib = 0;
    int sum = 0;

    while(fib < 4000000)
    {
      fib = f1 + f2;
      if(fib % 2 == 0)
        sum += fib;

      f1 = f2;
      f2 = fib;
    }
    System.out.println(sum);
  }
}[/java]
[java]Execution time: 1 ms.[/java]","Problem 2: Even Fibonacci Numbers",,"inherit","open","open",,"17-revision-v1",,,"2014-06-06 08:57:24","2014-06-06 08:57:24",,"17","http://euler.lvtran.com/17-revision-v1/","0","revision",,"0"
"19","1","2013-12-27 08:58:40","2013-12-27 08:58:40","<p>The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600,851,475,143 ? </p>
<!--more-->
<h2>The Catch</h2>
<p>How to find the prime factors of any number.<br>
How to determine if the factor is prime.<br>
How to store 600,851,475,143 in Java, since maximum value for <b>int</b> primitive type is 2,147,483,647.</p>
<h2>The Light</h2>
<p>&clubs;&nbsp;Use <strong><a href=""http://en.wikipedia.org/wiki/Prime_factorization"" target=""_blank"">prime factorization</a></strong> to find an arbitrary <strong>x</strong>'s prime factors:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Divide <strong>x</strong> by first prime number <strong>p</strong> (2 is the first value for <strong>p</strong>).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; If <strong>x</strong> is not divisible by <strong>p</strong>, move to the next prime that <strong>x</strong> is divisible by.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; If <strong>x</strong> is divisible by <strong>p</strong>, then keep dividing <strong>x</strong> by <strong>p</strong> until <strong>x</strong> is no longer divisible by <strong>p</strong> or <strong>x</strong> &nbsp;&nbsp;&nbsp;&nbsp;gets reduced to 1, whichever comes first.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat step 2 and 3 until <strong>x</strong> gets reduced to 1.<br></p>

&nbsp;&nbsp;&nbsp;&nbsp;Example: Prime factorize 14.<br>
&nbsp;&nbsp;&nbsp;&nbsp;14 / 2 = 7<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 % 2 != 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 % 3 != 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 % 5 != 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 / 7 = 1 <br>
&nbsp;&nbsp;&nbsp;&nbsp;Primes factor of 14 are 2, 7.</p>
			
			
<p>&clubs;&nbsp;Determine primeness: Recall that a <a href=""http://en.wikipedia.org/wiki/Prime_number"" target=""_blank"">prime number</a> is a natural number greater than 1 that has no positive divisors other than 1 and itself. Prime numbers are always odd with the exception of 2, the smallest prime number. So the first criteria for a number <strong>x</strong> to be prime is <strong>x</strong> needs to be an odd, natural number that is greater than 2. We then have to check all of its factors up to the square root of <strong>x</strong>. The reason for this is for every factor <strong>a</strong> of <strong>x</strong> that is less than or equal to <strong>sqrt(x)</strong>, there is a corresponding factor <strong>b</strong> of <strong>x</strong> that is greater than <strong>sqrt(x)</strong> such that <strong>a</strong> *<strong> b</strong> = <strong>x</strong>, thus checking for <strong>b</strong> is redundant.<br>
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/pdigit.jpg"" alt=""pdigit"" width=""500"" height=""375"" class=""aligncenter size-full wp-image-162"" />
<p>&diams; Example: Is 17 a prime number? 17 is obviously an odd number. If 17 has any more factors other than 1 and itself, then it is not prime. Prime factorize 17 to find its factors: 17 is not divisible by 2, 3, 5, 7, 11, and 13, thus 2, 3, 5, 7, 11, and 13 are not its factors. So 17's only factors are 1 and 17, making 17 prime. In fact, we can stop prime factorizing at <strong>sqrt(17)</strong>, or 4.123 because if 17 is not divisible by any number <strong>a</strong> with 1 &lt; <strong>a</strong> &lt;= 4.123, then 17 will not be divisible by any number <strong>b</strong> with 4.123 &lt; <strong>b</strong> &lt; 17.
<br>&clubs;&nbsp;To store the number 600,851,475,143, use primitive type <b>long</b>, whose maximum value is 9,223,372,036,854,775,807.</p><br>
<h2>The Code</h2>
[java]
public class Problem3
{
  public static void main(String[] args)
  {
    long n = 600851475143L;  //Use literal L at the end of the number to let the compiler know you're using a long
    int factor = 3;

    while(n &gt; 1)
    {
      if(isPrime(factor))
        if(n % factor == 0)
          n /= factor;	
        else
          factor += 2;		
      else
        factor += 2;
    }
    System.out.println(""Greatest prime factor = "" + factor);
  }

  public static boolean isPrime(int n)
  {
    if(n &lt; 2)
      return false;

    if(n != 2 &amp;&amp; n % 2 == 0)
      return false;

    for(int i = 3; i*i &lt;= n; i += 2)
    {
      if(n % i == 0)
        return false;
    } 
    return true;
  }
}
[/java]	
[java]Execution time: 2 ms.[/java]","Problem 3: Largest Prime Factor",,"publish","closed","closed",,"p3",,,"2014-06-15 07:08:34","2014-06-15 07:08:34",,"0","http://euler.lvtran.com/?p=19","0","post",,"0"
"20","1","2014-06-06 08:58:40","2014-06-06 08:58:40","<h2>The Problem</h2> 
<p>The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600,851,475,143 ? </p>
<!--more-->
<h2>The Catch</h2>
<p>How to find the prime factors of any number.<br>
How to determine if the factor is prime.<br>
How to store 600,851,475,143 in Java, since maximum value for <b>int</b> primitive type is 2,147,483,647.</p>
<h2>The Light</h2>
<p>&clubs;&nbsp;Use <strong><a href=""http://en.wikipedia.org/wiki/Prime_factorization"" target=""_blank"">prime factorization</a></strong> to find an arbitrary <strong>x</strong>'s prime factors:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Divide <strong>x</strong> by first prime number <strong>p</strong> (2 is the first value for <strong>p</strong>).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; If <strong>x</strong> is not divisible by <strong>p</strong>, move to the next prime that <strong>x</strong> is divisible by.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; If <strong>x</strong> is divisible by <strong>p</strong>, then keep dividing <strong>x</strong> by <strong>p</strong> until <strong>x</strong> is no longer divisible by <strong>p</strong> or <strong>x</strong> &nbsp;&nbsp;&nbsp;&nbsp;gets reduced to 1, whichever comes first.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat step 2 and 3 until <strong>x</strong> gets reduced to 1.<br></p>

&nbsp;&nbsp;&nbsp;&nbsp;Example: Prime factorize 14.<br>
&nbsp;&nbsp;&nbsp;&nbsp;14 / 2 = 7<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 % 2 != 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 % 3 != 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 % 5 != 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 / 7 = 1 <br>
&nbsp;&nbsp;&nbsp;&nbsp;Primes factor of 14 are 2, 7.</p>
			
			
<p>&clubs;&nbsp;Determine primeness: Recall that a <a href=""http://en.wikipedia.org/wiki/Prime_number"" target=""_blank"">prime number</a> is a natural number greater than 1 that has no positive divisors other than 1 and itself. Prime numbers are always odd with the exception of 2, the smallest prime number. So the first criteria for a number <strong>x</strong> to be prime is <strong>x</strong> needs to be an odd, natural number that is greater than 2. We then have to check all of its factors up to the square root of <strong>x</strong>. The reason for this is for every factor <strong>a</strong> of <strong>x</strong> that is less than or equal to <strong>sqrt(x)</strong>, there is a corresponding factor <strong>b</strong> of <strong>x</strong> that is greater than <strong>sqrt(x)</strong> such that <strong>a</strong> *<strong> b</strong> = <strong>x</strong>, thus checking for <strong>b</strong> is redundant.<br>
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/pdigit.jpg"" alt=""pdigit"" width=""500"" height=""375"" class=""aligncenter size-full wp-image-162"" />
<p>&diams; Example: Is 17 a prime number? 17 is obviously an odd number. If 17 has any more factors other than 1 and itself, then it is not prime. Prime factorize 17 to find its factors: 17 is not divisible by 2, 3, 5, 7, 11, and 13, thus 2, 3, 5, 7, 11, and 13 are not its factors. So 17's only factors are 1 and 17, making 17 prime. In fact, we can stop prime factorizing at <strong>sqrt(17)</strong>, or 4.123 because if 17 is not divisible by any number <strong>a</strong> with 1 &lt; <strong>a</strong> &lt;= 4.123, then 17 will not be divisible by any number <strong>b</strong> with 4.123 &lt; <strong>b</strong> &lt; 17.
<br>&clubs;&nbsp;To store the number 600,851,475,143, use primitive type <b>long</b>, whose maximum value is 9,223,372,036,854,775,807.</p><br>
<h2>The Code</h2>
[java]
public class Problem3
{
  public static void main(String[] args)
  {
    long n = 600851475143L;  //Use literal L at the end of the number to let the compiler know you're using a long
    int factor = 3;

    while(n &gt; 1)
    {
      if(isPrime(factor))
        if(n % factor == 0)
          n /= factor;	
        else
          factor += 2;		
      else
        factor += 2;
    }
    System.out.println(""Greatest prime factor = "" + factor);
  }

  public static boolean isPrime(int n)
  {
    if(n &lt; 2)
      return false;

    if(n != 2 &amp;&amp; n % 2 == 0)
      return false;

    for(int i = 3; i*i &lt;= n; i += 2)
    {
      if(n % i == 0)
        return false;
    } 
    return true;
  }
}
[/java]	
[java]Execution time: 2 ms.[/java]","Problem 3: Largest Prime Factor",,"inherit","open","open",,"19-revision-v1",,,"2014-06-06 08:58:40","2014-06-06 08:58:40",,"19","http://euler.lvtran.com/19-revision-v1/","0","revision",,"0"
"31","1","2014-06-06 09:05:05","2014-06-06 09:05:05","<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
<!--more-->
<h2>The Catch</h2>
<p>How to efficiently generate a Fibonacci sequence.<br>
How to pick out the even-valued Fibonacci number.</p>
<h2>The Light</h2>
<p>The recursive approach to generating a Fibonacci sequence (time complexity of <b>O(2<sup>n</sup>)</b>) might not be as elegant as an iterative one. Consider this piece of code, which prints all Fibonacci numbers under 10 using the iterative approach (time complexity of <b>O(n)</b>). For every fibonacciNumber created, check if it is divisible by 2 to pick out the even-valued ones. Sum them up to find the answer.</p>
[java]int firstNumber = 1;
int secondNumber = 2;
int fibonacciNumber = 0;

System.out.print(firstNumber + "" "" + secondNumber);
while(fibonacciNumber &lt; 10)
{
  fibonacciNumber = firstNumber + secondNumber;
  System.out.print("" "" + fibonacciNumber);
  firstNumber = secondNumber;
  secondNumber = fibonacciNumber;
}[/java]
<h2>The Code</h2>
[java]
public class Problem2
{
  public static void main(String[] args)
  {
    fib(); 
  }

  public static void fib()
  {
    int f1 = 1;
    int f2 = 1;
    int fib = 0;
    int sum = 0;

    while(fib < 4000000)
    {
      fib = f1 + f2;
      if(fib % 2 == 0)
        sum += fib;

      f1 = f2;
      f2 = fib;
    }
    System.out.println(sum);
  }
}[/java]
[java]Execution time: 1 ms.[/java]","Problem 2: Even Fibonacci Numbers",,"inherit","open","open",,"17-revision-v1",,,"2014-06-06 09:05:05","2014-06-06 09:05:05",,"17","http://euler.lvtran.com/17-revision-v1/","0","revision",,"0"
"21","1","2014-06-06 08:59:42","2014-06-06 08:59:42","<h2>The Problem</h2> 
<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
<!--more-->
<h2>The Catch</h2>
<p>How to efficiently generate a Fibonacci sequence.<br>
How to pick out the even-valued Fibonacci number.</p>
<h2>The Light</h2>
<p>The recursive approach to generating a Fibonacci sequence (time complexity of <b>O(2<sup>n</sup>)</b>) might not be as elegant as an iterative one. Consider this piece of code, which prints all Fibonacci numbers under 10 using the iterative approach (time complexity of <b>O(n)</b>). For every fibonacciNumber created, check if it is divisible by 2 to pick out the even-valued ones. Sum them up to find the answer.</p>
[java]int firstNumber = 1;
int secondNumber = 2;
int fibonacciNumber = 0;

System.out.print(firstNumber + "" "" + secondNumber);
while(fibonacciNumber &lt; 10)
{
  fibonacciNumber = firstNumber + secondNumber;
  System.out.print("" "" + fibonacciNumber);
  firstNumber = secondNumber;
  secondNumber = fibonacciNumber;
}[/java]
<h2>The Code</h2>
[java]
public class Problem2
{
  public static void main(String[] args)
  {
    fib(); 
  }

  public static void fib()
  {
    int f1 = 1;
    int f2 = 1;
    int fib = 0;
    int sum = 0;

    while(fib < 4000000)
    {
      fib = f1 + f2;
      if(fib % 2 == 0)
        sum += fib;

      f1 = f2;
      f2 = fib;
    }
    System.out.println(sum);
  }
}[/java]
[java]Execution time: 1 ms.[/java]","Problem 2: Even Fibonacci Numbers",,"inherit","open","open",,"17-revision-v1",,,"2014-06-06 08:59:42","2014-06-06 08:59:42",,"17","http://euler.lvtran.com/17-revision-v1/","0","revision",,"0"
"22","1","2013-12-26 09:01:17","2013-12-26 09:01:17","<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99. Find the largest palindrome made from the product of two 3-digit numbers. </p><!--more-->


<h2>The Catch</h2>
<p>How to check if a number is palindromic.</p>
<h2>The Light</h2>
<p>Parse a number to a character array. There are 2 possibilities:
<p>The length of the array is even: from the 2 middle-indexed elements, check outward for equality.
<a><img src=""http://www.lvtran.com/wp-content/uploads/2014/02/p4a.png"" alt=""p4a"" width=""650"" height=""86"" class=""aligncenter size-full wp-image-166"" /></a>
<p>The length of the array is odd: from the elements to the right and left of the middle-indexed element, check outward for equality.
<a><img src=""http://www.lvtran.com/wp-content/uploads/2014/02/p4b.png"" alt=""p4b"" width=""672"" height=""73"" class=""aligncenter size-full wp-image-167"" /></a>
<h2>The Code</h2>
[java]
public class Problem4
{
  public static void main(String[] args)
  {
    int max = 0;
    int value = 0;
     
    for(int i = 100; i < 1000; i++)
    {
      for(int j = 100; j < 1000; j++)
      {
        value = i * j;
        String s = Integer.toString(value);
         
        if(isPalin(s))
          if(value > max)
            max = value;
      }
    }
    System.out.println(max);
  }
   
  public static boolean isPalin(String s)
  {
    for(int i = 0; i < s.length()/2; i++)
    {
      if(s.charAt(i) != s.charAt(s.length() - 1 - i))
        return false;
    }
    return true;
  }
}
[/java]
[java]Execution time: 64 ms.[/java]","Problem 4: Largest Palindrome Product",,"publish","closed","closed",,"p4",,,"2014-06-15 07:08:35","2014-06-15 07:08:35",,"0","http://euler.lvtran.com/?p=22","0","post",,"0"
"23","1","2014-06-06 09:01:17","2014-06-06 09:01:17","<h2>The Problem</h2> 
<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99. Find the largest palindrome made from the product of two 3-digit numbers. </p><!--more-->


<h2>The Catch</h2>
<p>How to check if a number is palindromic.</p>
<h2>The Light</h2>
<p>Parse a number to a character array. There are 2 possibilities:
<p>The length of the array is even: from the 2 middle-indexed elements, check outward for equality.
<a><img src=""http://www.lvtran.com/wp-content/uploads/2014/02/p4a.png"" alt=""p4a"" width=""650"" height=""86"" class=""aligncenter size-full wp-image-166"" /></a>
<p>The length of the array is odd: from the elements to the right and left of the middle-indexed element, check outward for equality.
<a><img src=""http://www.lvtran.com/wp-content/uploads/2014/02/p4b.png"" alt=""p4b"" width=""672"" height=""73"" class=""aligncenter size-full wp-image-167"" /></a>
<h2>The Code</h2>
[java]
public class Problem4
{
  public static void main(String[] args)
  {
    int max = 0;
    int value = 0;
     
    for(int i = 100; i < 1000; i++)
    {
      for(int j = 100; j < 1000; j++)
      {
        value = i * j;
        String s = Integer.toString(value);
         
        if(isPalin(s))
          if(value > max)
            max = value;
      }
    }
    System.out.println(max);
  }
   
  public static boolean isPalin(String s)
  {
    for(int i = 0; i < s.length()/2; i++)
    {
      if(s.charAt(i) != s.charAt(s.length() - 1 - i))
        return false;
    }
    return true;
  }
}
[/java]
[java]Execution time: 64 ms.[/java]","Problem 4: Largest Palindrome Product",,"inherit","open","open",,"22-revision-v1",,,"2014-06-06 09:01:17","2014-06-06 09:01:17",,"22","http://euler.lvtran.com/22-revision-v1/","0","revision",,"0"
"24","1","2013-12-25 09:01:54","2013-12-25 09:01:54","<p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20? </p><!--more-->


<h2>The Catch</h2>
<p>How to efficiently check whether an arbitrary number <strong>x </strong>is divisible by all of the numbers from 1 to 20; dividing <strong>x</strong> by all numbers from 1 to 20 is called brute forcing and is not efficient.</p><br>
<h2>The Light</h2>
<p>Manipulate the divisibility rules to lessen check points: If <strong>x</strong> is divisible by 20, then <strong>x</strong> is also divisible by 2, 4, 5, 10 (because they are factors of 20). If <strong>x</strong> is divisible by 18, then <strong>x</strong> is also divisible by 2, 3, 6, 9 (because they are factors of 18).
<p>That leaves 7, 8, 11, 12, 13, 14, 15, 16, 17, 19 unchecked, but checking divisibility by 14 will take care of 7 and checking divisibility by 16 will take care of 8. As a result, the only necessary check points are <strong>11, 12, 13, 14, 15, 16, 17, 18, 19, 20</strong>; immediately return if divisibility test fails for any of these check points.</p>
<h2>The Code</h2>
[java]
public class Problem5
{
  public static void main(String[] args)
  {
    int n = 20;
 
    while(!isDivisible(n))
    {
      n += 20;  //Increment by 20 to speed up because n has to be divisible by 20
    }  
 
    System.out.println(n);
  }
 
  public static boolean isDivisible(int n)
  {
    if( n % 20 != 0 || n % 18 != 0 || n % 19 != 0)
      return false;
 
    for(int i = 11; i < 18; i++)
    {
      if(n % i != 0)
        return false;
    }
    return true;
  }
}    
[/java]
[java]Execution time: 43 ms.[/java]","Problem 5: Smallest Multiple",,"publish","closed","closed",,"p5",,,"2014-06-15 07:08:35","2014-06-15 07:08:35",,"0","http://euler.lvtran.com/?p=24","0","post",,"0"
"25","1","2014-06-06 09:01:54","2014-06-06 09:01:54","<h2>The Problem</h2> 
<p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20? </p><!--more-->


<h2>The Catch</h2>
<p>How to efficiently check whether an arbitrary number <strong>x </strong>is divisible by all of the numbers from 1 to 20; dividing <strong>x</strong> by all numbers from 1 to 20 is called brute forcing and is not efficient.</p><br>
<h2>The Light</h2>
<p>Manipulate the divisibility rules to lessen check points: If <strong>x</strong> is divisible by 20, then <strong>x</strong> is also divisible by 2, 4, 5, 10 (because they are factors of 20). If <strong>x</strong> is divisible by 18, then <strong>x</strong> is also divisible by 2, 3, 6, 9 (because they are factors of 18).
<p>That leaves 7, 8, 11, 12, 13, 14, 15, 16, 17, 19 unchecked, but checking divisibility by 14 will take care of 7 and checking divisibility by 16 will take care of 8. As a result, the only necessary check points are <strong>11, 12, 13, 14, 15, 16, 17, 18, 19, 20</strong>; immediately return if divisibility test fails for any of these check points.</p>
<h2>The Code</h2>
[java]
public class Problem5
{
  public static void main(String[] args)
  {
    int n = 20;
 
    while(!isDivisible(n))
    {
      n += 20;  //Increment by 20 to speed up because n has to be divisible by 20
    }  
 
    System.out.println(n);
  }
 
  public static boolean isDivisible(int n)
  {
    if( n % 20 != 0 || n % 18 != 0 || n % 19 != 0)
      return false;
 
    for(int i = 11; i < 18; i++)
    {
      if(n % i != 0)
        return false;
    }
    return true;
  }
}    
[/java]
[java]Execution time: 43 ms.[/java]","Problem 5: Smallest Multiple",,"inherit","open","open",,"24-revision-v1",,,"2014-06-06 09:01:54","2014-06-06 09:01:54",,"24","http://euler.lvtran.com/24-revision-v1/","0","revision",,"0"
"26","1","2014-06-06 09:04:00","2014-06-06 09:04:00","<p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20? </p><!--more-->


<h2>The Catch</h2>
<p>How to efficiently check whether an arbitrary number <strong>x </strong>is divisible by all of the numbers from 1 to 20; dividing <strong>x</strong> by all numbers from 1 to 20 is called brute forcing and is not efficient.</p><br>
<h2>The Light</h2>
<p>Manipulate the divisibility rules to lessen check points: If <strong>x</strong> is divisible by 20, then <strong>x</strong> is also divisible by 2, 4, 5, 10 (because they are factors of 20). If <strong>x</strong> is divisible by 18, then <strong>x</strong> is also divisible by 2, 3, 6, 9 (because they are factors of 18).
<p>That leaves 7, 8, 11, 12, 13, 14, 15, 16, 17, 19 unchecked, but checking divisibility by 14 will take care of 7 and checking divisibility by 16 will take care of 8. As a result, the only necessary check points are <strong>11, 12, 13, 14, 15, 16, 17, 18, 19, 20</strong>; immediately return if divisibility test fails for any of these check points.</p>
<h2>The Code</h2>
[java]
public class Problem5
{
  public static void main(String[] args)
  {
    int n = 20;
 
    while(!isDivisible(n))
    {
      n += 20;  //Increment by 20 to speed up because n has to be divisible by 20
    }  
 
    System.out.println(n);
  }
 
  public static boolean isDivisible(int n)
  {
    if( n % 20 != 0 || n % 18 != 0 || n % 19 != 0)
      return false;
 
    for(int i = 11; i < 18; i++)
    {
      if(n % i != 0)
        return false;
    }
    return true;
  }
}    
[/java]
[java]Execution time: 43 ms.[/java]","Problem 5: Smallest Multiple",,"inherit","open","open",,"24-autosave-v1",,,"2014-06-06 09:04:00","2014-06-06 09:04:00",,"24","http://euler.lvtran.com/24-autosave-v1/","0","revision",,"0"
"27","1","2014-06-06 09:04:02","2014-06-06 09:04:02","<p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20? </p><!--more-->


<h2>The Catch</h2>
<p>How to efficiently check whether an arbitrary number <strong>x </strong>is divisible by all of the numbers from 1 to 20; dividing <strong>x</strong> by all numbers from 1 to 20 is called brute forcing and is not efficient.</p><br>
<h2>The Light</h2>
<p>Manipulate the divisibility rules to lessen check points: If <strong>x</strong> is divisible by 20, then <strong>x</strong> is also divisible by 2, 4, 5, 10 (because they are factors of 20). If <strong>x</strong> is divisible by 18, then <strong>x</strong> is also divisible by 2, 3, 6, 9 (because they are factors of 18).
<p>That leaves 7, 8, 11, 12, 13, 14, 15, 16, 17, 19 unchecked, but checking divisibility by 14 will take care of 7 and checking divisibility by 16 will take care of 8. As a result, the only necessary check points are <strong>11, 12, 13, 14, 15, 16, 17, 18, 19, 20</strong>; immediately return if divisibility test fails for any of these check points.</p>
<h2>The Code</h2>
[java]
public class Problem5
{
  public static void main(String[] args)
  {
    int n = 20;
 
    while(!isDivisible(n))
    {
      n += 20;  //Increment by 20 to speed up because n has to be divisible by 20
    }  
 
    System.out.println(n);
  }
 
  public static boolean isDivisible(int n)
  {
    if( n % 20 != 0 || n % 18 != 0 || n % 19 != 0)
      return false;
 
    for(int i = 11; i < 18; i++)
    {
      if(n % i != 0)
        return false;
    }
    return true;
  }
}    
[/java]
[java]Execution time: 43 ms.[/java]","Problem 5: Smallest Multiple",,"inherit","open","open",,"24-revision-v1",,,"2014-06-06 09:04:02","2014-06-06 09:04:02",,"24","http://euler.lvtran.com/24-revision-v1/","0","revision",,"0"
"29","1","2014-06-06 09:04:27","2014-06-06 09:04:27","<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99. Find the largest palindrome made from the product of two 3-digit numbers. </p><!--more-->


<h2>The Catch</h2>
<p>How to check if a number is palindromic.</p>
<h2>The Light</h2>
<p>Parse a number to a character array. There are 2 possibilities:
<p>The length of the array is even: from the 2 middle-indexed elements, check outward for equality.
<a><img src=""http://www.lvtran.com/wp-content/uploads/2014/02/p4a.png"" alt=""p4a"" width=""650"" height=""86"" class=""aligncenter size-full wp-image-166"" /></a>
<p>The length of the array is odd: from the elements to the right and left of the middle-indexed element, check outward for equality.
<a><img src=""http://www.lvtran.com/wp-content/uploads/2014/02/p4b.png"" alt=""p4b"" width=""672"" height=""73"" class=""aligncenter size-full wp-image-167"" /></a>
<h2>The Code</h2>
[java]
public class Problem4
{
  public static void main(String[] args)
  {
    int max = 0;
    int value = 0;
     
    for(int i = 100; i < 1000; i++)
    {
      for(int j = 100; j < 1000; j++)
      {
        value = i * j;
        String s = Integer.toString(value);
         
        if(isPalin(s))
          if(value > max)
            max = value;
      }
    }
    System.out.println(max);
  }
   
  public static boolean isPalin(String s)
  {
    for(int i = 0; i < s.length()/2; i++)
    {
      if(s.charAt(i) != s.charAt(s.length() - 1 - i))
        return false;
    }
    return true;
  }
}
[/java]
[java]Execution time: 64 ms.[/java]","Problem 4: Largest Palindrome Product",,"inherit","open","open",,"22-revision-v1",,,"2014-06-06 09:04:27","2014-06-06 09:04:27",,"22","http://euler.lvtran.com/22-revision-v1/","0","revision",,"0"
"30","1","2014-06-06 09:05:02","2014-06-06 09:05:02","<p>The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600,851,475,143 ? </p>
<!--more-->
<h2>The Catch</h2>
<p>How to find the prime factors of any number.<br>
How to determine if the factor is prime.<br>
How to store 600,851,475,143 in Java, since maximum value for <b>int</b> primitive type is 2,147,483,647.</p>
<h2>The Light</h2>
<p>&clubs;&nbsp;Use <strong><a href=""http://en.wikipedia.org/wiki/Prime_factorization"" target=""_blank"">prime factorization</a></strong> to find an arbitrary <strong>x</strong>'s prime factors:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Divide <strong>x</strong> by first prime number <strong>p</strong> (2 is the first value for <strong>p</strong>).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; If <strong>x</strong> is not divisible by <strong>p</strong>, move to the next prime that <strong>x</strong> is divisible by.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; If <strong>x</strong> is divisible by <strong>p</strong>, then keep dividing <strong>x</strong> by <strong>p</strong> until <strong>x</strong> is no longer divisible by <strong>p</strong> or <strong>x</strong> &nbsp;&nbsp;&nbsp;&nbsp;gets reduced to 1, whichever comes first.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat step 2 and 3 until <strong>x</strong> gets reduced to 1.<br></p>

&nbsp;&nbsp;&nbsp;&nbsp;Example: Prime factorize 14.<br>
&nbsp;&nbsp;&nbsp;&nbsp;14 / 2 = 7<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 % 2 != 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 % 3 != 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 % 5 != 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 / 7 = 1 <br>
&nbsp;&nbsp;&nbsp;&nbsp;Primes factor of 14 are 2, 7.</p>
			
			
<p>&clubs;&nbsp;Determine primeness: Recall that a <a href=""http://en.wikipedia.org/wiki/Prime_number"" target=""_blank"">prime number</a> is a natural number greater than 1 that has no positive divisors other than 1 and itself. Prime numbers are always odd with the exception of 2, the smallest prime number. So the first criteria for a number <strong>x</strong> to be prime is <strong>x</strong> needs to be an odd, natural number that is greater than 2. We then have to check all of its factors up to the square root of <strong>x</strong>. The reason for this is for every factor <strong>a</strong> of <strong>x</strong> that is less than or equal to <strong>sqrt(x)</strong>, there is a corresponding factor <strong>b</strong> of <strong>x</strong> that is greater than <strong>sqrt(x)</strong> such that <strong>a</strong> *<strong> b</strong> = <strong>x</strong>, thus checking for <strong>b</strong> is redundant.<br>
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/pdigit.jpg"" alt=""pdigit"" width=""500"" height=""375"" class=""aligncenter size-full wp-image-162"" />
<p>&diams; Example: Is 17 a prime number? 17 is obviously an odd number. If 17 has any more factors other than 1 and itself, then it is not prime. Prime factorize 17 to find its factors: 17 is not divisible by 2, 3, 5, 7, 11, and 13, thus 2, 3, 5, 7, 11, and 13 are not its factors. So 17's only factors are 1 and 17, making 17 prime. In fact, we can stop prime factorizing at <strong>sqrt(17)</strong>, or 4.123 because if 17 is not divisible by any number <strong>a</strong> with 1 &lt; <strong>a</strong> &lt;= 4.123, then 17 will not be divisible by any number <strong>b</strong> with 4.123 &lt; <strong>b</strong> &lt; 17.
<br>&clubs;&nbsp;To store the number 600,851,475,143, use primitive type <b>long</b>, whose maximum value is 9,223,372,036,854,775,807.</p><br>
<h2>The Code</h2>
[java]
public class Problem3
{
  public static void main(String[] args)
  {
    long n = 600851475143L;  //Use literal L at the end of the number to let the compiler know you're using a long
    int factor = 3;

    while(n &gt; 1)
    {
      if(isPrime(factor))
        if(n % factor == 0)
          n /= factor;	
        else
          factor += 2;		
      else
        factor += 2;
    }
    System.out.println(""Greatest prime factor = "" + factor);
  }

  public static boolean isPrime(int n)
  {
    if(n &lt; 2)
      return false;

    if(n != 2 &amp;&amp; n % 2 == 0)
      return false;

    for(int i = 3; i*i &lt;= n; i += 2)
    {
      if(n % i == 0)
        return false;
    } 
    return true;
  }
}
[/java]	
[java]Execution time: 2 ms.[/java]","Problem 3: Largest Prime Factor",,"inherit","open","open",,"19-revision-v1",,,"2014-06-06 09:05:02","2014-06-06 09:05:02",,"19","http://euler.lvtran.com/19-revision-v1/","0","revision",,"0"
"32","1","2014-06-06 09:05:10","2014-06-06 09:05:10","<p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. </p><br>
<!--more-->
<h2>The Catch</h2>
<p>How to check if an arbitrary number <strong>x</strong> is evenly divisible by 3 or 5.</p>
<h2>The Light</h2>
<p>To check for divisibility, use modulus operation (<strong>%</strong>), which calculates the remainder of <strong>x</strong> divides by<strong> a</strong>, where a != 0. If <strong>x % a == 0</strong>, then the division of<strong> x</strong> by<strong> a</strong> leaves no remainder, or <strong>x</strong> is divisible by <strong>a</strong> (In Discrete Mathematics, this is written as x | a).</p>
<h2>The Code</h2>
[java]public class Problem1
{
  public static void main(String[] args)
  {
    int sum = 0;
    for(int i = 0; i &lt; 1000; i++)
    { 
      if(i % 3 == 0 || i % 5 == 0)
        sum += i;
    }
    System.out.println(sum);
  }
}[/java]
[java]Execution time: 0 ms.[/java]","Problem 1: Multiples of 3 and 5",,"inherit","open","open",,"15-revision-v1",,,"2014-06-06 09:05:10","2014-06-06 09:05:10",,"15","http://euler.lvtran.com/15-revision-v1/","0","revision",,"0"
"34","1","2014-06-06 09:20:31","2014-06-06 09:20:31",,"Home",,"publish","open","open",,"home",,,"2015-03-12 23:31:24","2015-03-12 23:31:24",,"0","http://euler.lvtran.com/?p=34","1","nav_menu_item",,"0"
"37","1","2013-12-24 10:00:08","2013-12-24 10:00:08","<p>The sum of the squares of the first ten natural numbers is 1<sup>2</sup> + 2<sup>2</sup> + ... + 10<sup>2</sup> = 385. The square of the sum of the first ten natural numbers is (1 + 2 + ... + 10)<sup>2</sup> = 55<sup>2</sup> = 3025. Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p><!--more-->



<h2>The Catch</h2>
<p>This problem is straight forward enough to efficiently brute force.</p>

<h2>The Light</h2>
<p>Loop from 1 to 100 and accumulate the sum of the squares and	the sum for each iteration. After the loop is completed, find their difference.</p>

<h2>The Code</h2>
[java]
public class Problem6
{
  public static void main(String[] args)
  {
    int s1 = 0;
    int s2 = 0;

    for(int i = 1; i &lt;= 100; i++)
    {
      s1 += (i*i);
      s2 += i;
    }
    System.out.println(s2 * s2 - s1);
 }
}
[/java]
[java]Execution time: 0 ms.[/java]","Problem 6: Sum Square Difference",,"publish","closed","closed",,"p6",,,"2014-06-15 07:08:36","2014-06-15 07:08:36",,"0","http://euler.lvtran.com/?p=37","0","post",,"0"
"54","1","2014-06-07 10:09:09","2014-06-07 10:09:09","<p>The sum of the squares of the first ten natural numbers is 1<sup>2</sup> + 2<sup>2</sup> + ... + 10<sup>2</sup> = 385. The square of the sum of the first ten natural numbers is (1 + 2 + ... + 10)<sup>2</sup> = 55<sup>2</sup> = 3025. Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p><!--more-->



<h2>The Catch</h2>
<p>This problem is straight forward enough to efficiently brute force.</p>

<h2>The Light</h2>
<p>Loop from 1 to 100 and accumulate the sum of the squares and	the sum for each iteration. After the loop is completed, find their difference.</p>

<h2>The Code</h2>
[java]
public class Problem6
{
  public static void main(String[] args)
  {
    int s1 = 0;
    int s2 = 0;

    for(int i = 1; i &lt;= 100; i++)
    {
      s1 += (i*i);
      s2 += i;
    }
    System.out.println(s2 * s2 - s1);
 }
}
[/java]
[java]Execution time: 0 ms.[/java]","Problem 6: Sum Square Difference",,"inherit","open","open",,"37-revision-v1",,,"2014-06-07 10:09:09","2014-06-07 10:09:09",,"37","http://euler.lvtran.com/37-revision-v1/","0","revision",,"0"
"38","1","2014-06-07 10:00:09","2014-06-07 10:00:09","<h2>The Problem</h2> 
<p>The sum of the squares of the first ten natural numbers is 1<sup>2</sup> + 2<sup>2</sup> + ... + 10<sup>2</sup> = 385. The square of the sum of the first ten natural numbers is (1 + 2 + ... + 10)<sup>2</sup> = 55<sup>2</sup> = 3025. Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p><!--more-->



<h2>The Catch</h2>
<p>This problem is straight forward enough to efficiently brute force.</p>

<h2>The Light</h2>
<p>Loop from 1 to 100 and accumulate the sum of the squares and	the sum for each iteration. After the loop is completed, find their difference.</p>

<h2>The Code</h2>
[java]
public class Problem6
{
  public static void main(String[] args)
  {
    int s1 = 0;
    int s2 = 0;

    for(int i = 1; i &lt;= 100; i++)
    {
      s1 += (i*i);
      s2 += i;
    }
    System.out.println(s2 * s2 - s1);
 }
}
[/java]
[java]Execution time: 0 ms.[/java]","Problem 6: Sum Square Difference",,"inherit","open","open",,"37-revision-v1",,,"2014-06-07 10:00:09","2014-06-07 10:00:09",,"37","http://euler.lvtran.com/37-revision-v1/","0","revision",,"0"
"39","1","2013-12-23 10:00:38","2013-12-23 10:00:38","<p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6<sup>th</sup> prime is 13. What is the 10,001<sup>st</sup> prime number?</p><!--more-->



<h2>The Catch</h2>
<p>How to determine whether an arbitrary number <strong>x</strong> is prime.</p>

<h2>The Light</h2>
<p>Reuse the prime checking code in <a href=""http://lvtran.com/p3"">Problem 3</a> to find the 10,100st prime number.</p>

<h2>The Code</h2>
[java]
public class Problem7
{
  public static void main(String[] args)
  {
    int count = 1; //Start count at 1 because 2 is the first prime number

    for(int i = 3;; i += 2) //Increment by 2 because primes from 3 onward are odd
    {
      if(isPrime(i))
        ++count;
      if(count == 10001)
      {
        System.out.println(i);
        break;
      }
    }
  }

  public static boolean isPrime(int n)
  {
    if(n &lt; 2)
      return false;

    if(n != 2 &amp;&amp; n % 2 == 0)
      return false;

    for(int i = 3; i*i &lt;= n; i += 2)
    {
      if(n % i == 0)
        return false;
    } 
    return true;
  }
}
[/java]
[java]Execution time: 8 ms.[/java]","Problem 7: 10,001<sup>st</sup> Prime",,"publish","closed","closed",,"p7",,,"2014-06-15 07:08:37","2014-06-15 07:08:37",,"0","http://euler.lvtran.com/?p=39","0","post",,"0"
"40","1","2014-06-07 10:00:38","2014-06-07 10:00:38","<h2>The Problem</h2> 
<p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6<sup>th</sup> prime is 13. What is the 10,001<sup>st</sup> prime number?</p><!--more-->



<h2>The Catch</h2>
<p>How to determine whether an arbitrary number <strong>x</strong> is prime.</p>

<h2>The Light</h2>
<p>Reuse the prime checking code in <a href=""http://lvtran.com/p3"">Problem 3</a> to find the 10,100st prime number.</p>

<h2>The Code</h2>
[java]
public class Problem7
{
  public static void main(String[] args)
  {
    int count = 1; //Start count at 1 because 2 is the first prime number

    for(int i = 3;; i += 2) //Increment by 2 because primes from 3 onward are odd
    {
      if(isPrime(i))
        ++count;
      if(count == 10001)
      {
        System.out.println(i);
        break;
      }
    }
  }

  public static boolean isPrime(int n)
  {
    if(n &lt; 2)
      return false;

    if(n != 2 &amp;&amp; n % 2 == 0)
      return false;

    for(int i = 3; i*i &lt;= n; i += 2)
    {
      if(n % i == 0)
        return false;
    } 
    return true;
  }
}
[/java]
[java]Execution time: 8 ms.[/java]","Problem 7: 10,001<sup>st</sup> Prime",,"inherit","open","open",,"39-revision-v1",,,"2014-06-07 10:00:38","2014-06-07 10:00:38",,"39","http://euler.lvtran.com/39-revision-v1/","0","revision",,"0"
"41","1","2013-12-22 10:01:27","2013-12-22 10:01:27","<p>Find the greatest product of five consecutive digits in the 1000-digit number:</p><!--more-->


<p>7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450</p>

<h2>The Catch</h2>
<p>How to calculate the product <strong>x</strong> of every 5 digits in this 1,000-digit number. For every<strong> x</strong> calculated, check if it is the maximum value obtained.</p>

<h2>The Light</h2>
<p>Parse the 1,000-digit number to a character array and manipulate each character. Keep track of the greatest <strong>x</strong>.</p>

<h2>The Code</h2>
[java]
public class Problem8
{
  public static void main(String[] args)
  {
    String digit =  ""7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"";
    System.out.println(fiveDigitSum(digit));	
  }

  public static int fiveDigitSum(String s)
  {
    int max = 0;
    int tmp = 0;
    char[] digit = new char[s.length()];
    digit = s.toCharArray();

    for(int i = 0; i &lt; digit.length - 4; i++)     
    {       
      int d1 = Character.getNumericValue(digit[i]);       
      int d2 = Character.getNumericValue(digit[i + 1]);       
      int d3 = Character.getNumericValue(digit[i + 2]);       
      int d4 = Character.getNumericValue(digit[i + 3]);       
      int d5 = Character.getNumericValue(digit[i + 4]); 	         

      tmp = d1 * d2 * d3 * d4 * d5; 	         

      if(tmp &gt; max)
        max = tmp;
    }
    return max;	
  }
}
[/java]
[java]Execution time: 1 ms.[/java]","Problem 8: Largest Product in a Series",,"publish","closed","closed",,"p8",,,"2014-06-15 07:08:38","2014-06-15 07:08:38",,"0","http://euler.lvtran.com/?p=41","0","post",,"0"
"56","1","2014-06-07 10:10:07","2014-06-07 10:10:07","<p>Find the greatest product of five consecutive digits in the 1000-digit number:</p><!--more-->


<p>7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450</p>

<h2>The Catch</h2>
<p>How to calculate the product <strong>x</strong> of every 5 digits in this 1,000-digit number. For every<strong> x</strong> calculated, check if it is the maximum value obtained.</p>

<h2>The Light</h2>
<p>Parse the 1,000-digit number to a character array and manipulate each character. Keep track of the greatest <strong>x</strong>.</p>

<h2>The Code</h2>
[java]
public class Problem8
{
  public static void main(String[] args)
  {
    String digit =  ""7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"";
    System.out.println(fiveDigitSum(digit));	
  }

  public static int fiveDigitSum(String s)
  {
    int max = 0;
    int tmp = 0;
    char[] digit = new char[s.length()];
    digit = s.toCharArray();

    for(int i = 0; i &lt; digit.length - 4; i++)     
    {       
      int d1 = Character.getNumericValue(digit[i]);       
      int d2 = Character.getNumericValue(digit[i + 1]);       
      int d3 = Character.getNumericValue(digit[i + 2]);       
      int d4 = Character.getNumericValue(digit[i + 3]);       
      int d5 = Character.getNumericValue(digit[i + 4]); 	         

      tmp = d1 * d2 * d3 * d4 * d5; 	         

      if(tmp &gt; max)
        max = tmp;
    }
    return max;	
  }
}
[/java]
[java]Execution time: 1 ms.[/java]","Problem 8: Largest Product in a Series",,"inherit","open","open",,"41-revision-v1",,,"2014-06-07 10:10:07","2014-06-07 10:10:07",,"41","http://euler.lvtran.com/41-revision-v1/","0","revision",,"0"
"42","1","2014-06-07 10:01:27","2014-06-07 10:01:27","<h2>The Problem</h2> 
<p>Find the greatest product of five consecutive digits in the 1000-digit number:</p>
<p>7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450</p>
<!--more-->

<h2>The Catch</h2>
<p>How to calculate the product <strong>x</strong> of every 5 digits in this 1,000-digit number. For every<strong> x</strong> calculated, check if it is the maximum value obtained.</p>

<h2>The Light</h2>
<p>Parse the 1,000-digit number to a character array and manipulate each character. Keep track of the greatest <strong>x</strong>.</p>

<h2>The Code</h2>
[java]
public class Problem8
{
  public static void main(String[] args)
  {
    String digit =  ""7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"";
    System.out.println(fiveDigitSum(digit));	
  }

  public static int fiveDigitSum(String s)
  {
    int max = 0;
    int tmp = 0;
    char[] digit = new char[s.length()];
    digit = s.toCharArray();

    for(int i = 0; i &lt; digit.length - 4; i++)     
    {       
      int d1 = Character.getNumericValue(digit[i]);       
      int d2 = Character.getNumericValue(digit[i + 1]);       
      int d3 = Character.getNumericValue(digit[i + 2]);       
      int d4 = Character.getNumericValue(digit[i + 3]);       
      int d5 = Character.getNumericValue(digit[i + 4]); 	         

      tmp = d1 * d2 * d3 * d4 * d5; 	         

      if(tmp &gt; max)
        max = tmp;
    }
    return max;	
  }
}
[/java]
[java]Execution time: 1 ms.[/java]","Problem 8: Largest Product in a Series",,"inherit","open","open",,"41-revision-v1",,,"2014-06-07 10:01:27","2014-06-07 10:01:27",,"41","http://euler.lvtran.com/41-revision-v1/","0","revision",,"0"
"43","1","2013-12-21 10:03:56","2013-12-21 10:03:56","<p>A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, a^2 + b^2 = c^2. For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2. There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product <i>abc</i>.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to generate Pythagorean triplets.</p>

<h2>The Light</h2>
<p>Utilize the <a href=""http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple"" target=""_blank"">Euclid's Formula</a> to create Pythagorean triplets: Given an arbitrary pair of positive integers m and n with m &gt; n</var>, the formula states that:
&nbsp;&nbsp;&nbsp;&nbsp;a = m<sup>2</sup> - n<sup>2</sup>
&nbsp;&nbsp;&nbsp;&nbsp;b = 2 * m * n
&nbsp;&nbsp;&nbsp;&nbsp;c = m<sup>2</sup> + n<sup>2</sup>
Check when their sum equals 1,000 and find their product.</p>

<h2>The Code</h2>
[java]
public class Problem9
{
  public static void main(String[] args)
  {
    for(int m = 2;; m++) 
    {
      for(int n = 1; n &lt; m; n++)
      {
        int a = m * m - n * n;
        int b = 2 * m * n;
        int c = m * m + n * n;

        int sum = a + b + c;
        if( sum == 1000 )
        {
          System.out.println(""a = "" + a);
          System.out.println(""b = "" + b);
          System.out.println(""c = "" + c);
          System.out.println(a * b * c );
          return;
        }
      }
    }
  }
}
[/java]
[java]Execution time: 2 ms.[/java]","Problem 9: Special Pythagorean Triplet",,"publish","closed","closed",,"p9",,,"2014-06-15 07:08:38","2014-06-15 07:08:38",,"0","http://euler.lvtran.com/?p=43","0","post",,"0"
"67","1","2014-06-07 10:19:27","2014-06-07 10:19:27","<p>A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, a^2 + b^2 = c^2. For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2. There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product <i>abc</i>.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to generate Pythagorean triplets.</p>

<h2>The Light</h2>
<p>Utilize the <a href=""http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple"" target=""_blank"">Euclid's Formula</a> to create Pythagorean triplets: Given an arbitrary pair of positive integers m and n with m &gt; n</var>, the formula states that:
&nbsp;&nbsp;&nbsp;&nbsp;a = m<sup>2</sup> - n<sup>2</sup>
&nbsp;&nbsp;&nbsp;&nbsp;b = 2 * m * n
&nbsp;&nbsp;&nbsp;&nbsp;c = m<sup>2</sup> + n<sup>2</sup>
Check when their sum equals 1,000 and find their product.</p>

<h2>The Code</h2>
[java]
public class Problem9
{
  public static void main(String[] args)
  {
    for(int m = 2;; m++) 
    {
      for(int n = 1; n &lt; m; n++)
      {
        int a = m * m - n * n;
        int b = 2 * m * n;
        int c = m * m + n * n;

        int sum = a + b + c;
        if( sum == 1000 )
        {
          System.out.println(""a = "" + a);
          System.out.println(""b = "" + b);
          System.out.println(""c = "" + c);
          System.out.println(a * b * c );
          return;
        }
      }
    }
  }
}
[/java]
[java]Execution time: 2 ms.[/java]","Problem 9: Special Pythagorean Triplet",,"inherit","open","open",,"43-revision-v1",,,"2014-06-07 10:19:27","2014-06-07 10:19:27",,"43","http://euler.lvtran.com/43-revision-v1/","0","revision",,"0"
"58","1","2014-06-07 10:11:34","2014-06-07 10:11:34","<p>A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>. For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>. There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product <i>abc</i>.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to generate Pythagorean triplets.</p>

<h2>The Light</h2>
<p>Utilize the <a href=""http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple"" target=""_blank"">Euclid's Formula</a> to create Pythagorean triplets: Given an arbitrary pair of positive integers m and n with m &gt; n</var>, the formula states that:
&nbsp;&nbsp;&nbsp;&nbsp;a = m<sup>2</sup> - n<sup>2</sup>
&nbsp;&nbsp;&nbsp;&nbsp;b = 2 * m * n
&nbsp;&nbsp;&nbsp;&nbsp;c = m<sup>2</sup> + n<sup>2</sup>
Check when their sum equals 1,000 and find their product.</p>

<h2>The Code</h2>
[java]
public class Problem9
{
  public static void main(String[] args)
  {
    for(int m = 2;; m++) 
    {
      for(int n = 1; n &lt; m; n++)
      {
        int a = m * m - n * n;
        int b = 2 * m * n;
        int c = m * m + n * n;

        int sum = a + b + c;
        if( sum == 1000 )
        {
          System.out.println(""a = "" + a);
          System.out.println(""b = "" + b);
          System.out.println(""c = "" + c);
          System.out.println(a * b * c );
          return;
        }
      }
    }
  }
}
[/java]
[java]Execution time: 2 ms.[/java]","Problem 9: Special Pythagorean Triplet",,"inherit","open","open",,"43-revision-v1",,,"2014-06-07 10:11:34","2014-06-07 10:11:34",,"43","http://euler.lvtran.com/43-revision-v1/","0","revision",,"0"
"44","1","2014-06-07 10:01:56","2014-06-07 10:01:56","<h2>The Problem</h2> 
<p>A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>. For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>. There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product <i>abc</i>.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to generate Pythagorean triplets.</p>

<h2>The Light</h2>
<p>Utilize the <a href=""http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple"" target=""_blank"">Euclid's Formula</a> to create Pythagorean triplets: Given an arbitrary pair of positive integers m and n with m &gt; n</var>, the formula states that:
&nbsp;&nbsp;&nbsp;&nbsp;a = m<sup>2</sup> - n<sup>2</sup>
&nbsp;&nbsp;&nbsp;&nbsp;b = 2 * m * n
&nbsp;&nbsp;&nbsp;&nbsp;c = m<sup>2</sup> + n<sup>2</sup>
Check when their sum equals 1,000 and find their product.</p>

<h2>The Code</h2>
[java]
public class Problem9
{
  public static void main(String[] args)
  {
    for(int m = 2;; m++) 
    {
      for(int n = 1; n &lt; m; n++)
      {
        int a = m * m - n * n;
        int b = 2 * m * n;
        int c = m * m + n * n;

        int sum = a + b + c;
        if( sum == 1000 )
        {
          System.out.println(""a = "" + a);
          System.out.println(""b = "" + b);
          System.out.println(""c = "" + c);
          System.out.println(a * b * c );
          return;
        }
      }
    }
  }
}
[/java]
[java]Execution time: 2 ms.[/java]","Problem 9: Special Pythagorean Triplet",,"inherit","open","open",,"43-revision-v1",,,"2014-06-07 10:01:56","2014-06-07 10:01:56",,"43","http://euler.lvtran.com/43-revision-v1/","0","revision",,"0"
"45","1","2013-12-21 10:02:22","2013-12-21 10:02:22","<p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17. Find the sum of all the primes below two million.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to efficiently generate a list of prime below a given upper bound.</p>

<h2>The Light</h2>
<p>Including the first prime number, 2, in a sum variable, we can loop from 3 to 2,000,000 and reuse the prime checking code in <a href=""http://lvtran.com/p3"">Problem 3</a> and increment for every odd number. The sum will probably get too large for a type <b>int</b> variable to hold, causing a <a href=""http://stackoverflow.com/questions/3001836/how-does-java-handle-integer-underflows-and-overflows-and-how-would-you-check-fo"" target=""_blank""> number overflow error</a>. Use a type <b>long</b> variable to solve this issue. This approach, however, requires approximately 1,000,000 iterations and takes as long as half a second to execute, which is not very efficient.<br><br>
The <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" target=""_blank""> Sieve of Eratosthenes</a> discussed in <a href=""http://lvtran.com/p35"" target=""_blank"">Problem 35</a> will yield a much better result.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem10
{
  public static void main(String[] args)
  {
    long sum = 0;
    List primeList = generatePrimes(2000000);        

    for(int i = 0; i &lt; primeList.size(); i++)
    {
      sum += primeList.get(i);
    }
    System.out.println(sum); 
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 24 ms.[/java]","Problem 10: Summation of Primes",,"publish","closed","closed",,"p10",,,"2014-06-15 07:08:39","2014-06-15 07:08:39",,"0","http://euler.lvtran.com/?p=45","0","post",,"0"
"57","1","2014-06-07 10:10:44","2014-06-07 10:10:44","<p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17. Find the sum of all the primes below two million.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to efficiently generate a list of prime below a given upper bound.</p>

<h2>The Light</h2>
<p>Including the first prime number, 2, in a sum variable, we can loop from 3 to 2,000,000 and reuse the prime checking code in <a href=""http://lvtran.com/p3"">Problem 3</a> and increment for every odd number. The sum will probably get too large for a type <b>int</b> variable to hold, causing a <a href=""http://stackoverflow.com/questions/3001836/how-does-java-handle-integer-underflows-and-overflows-and-how-would-you-check-fo"" target=""_blank""> number overflow error</a>. Use a type <b>long</b> variable to solve this issue. This approach, however, requires approximately 1,000,000 iterations and takes as long as half a second to execute, which is not very efficient.<br><br>
The <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" target=""_blank""> Sieve of Eratosthenes</a> discussed in <a href=""http://lvtran.com/p35"" target=""_blank"">Problem 35</a> will yield a much better result.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem10
{
  public static void main(String[] args)
  {
    long sum = 0;
    List primeList = generatePrimes(2000000);        

    for(int i = 0; i &lt; primeList.size(); i++)
    {
      sum += primeList.get(i);
    }
    System.out.println(sum); 
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 24 ms.[/java]","Problem 10: Summation of Primes",,"inherit","open","open",,"45-revision-v1",,,"2014-06-07 10:10:44","2014-06-07 10:10:44",,"45","http://euler.lvtran.com/45-revision-v1/","0","revision",,"0"
"46","1","2014-06-07 10:02:22","2014-06-07 10:02:22","<h2>The Problem</h2> 
<p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17. Find the sum of all the primes below two million.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to efficiently generate a list of prime below a given upper bound.</p>

<h2>The Light</h2>
<p>Including the first prime number, 2, in a sum variable, we can loop from 3 to 2,000,000 and reuse the prime checking code in <a href=""http://lvtran.com/p3"">Problem 3</a> and increment for every odd number. The sum will probably get too large for a type <b>int</b> variable to hold, causing a <a href=""http://stackoverflow.com/questions/3001836/how-does-java-handle-integer-underflows-and-overflows-and-how-would-you-check-fo"" target=""_blank""> number overflow error</a>. Use a type <b>long</b> variable to solve this issue. This approach, however, requires approximately 1,000,000 iterations and takes as long as half a second to execute, which is not very efficient.<br><br>
The <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" target=""_blank""> Sieve of Eratosthenes</a> discussed in <a href=""http://lvtran.com/p35"" target=""_blank"">Problem 35</a> will yield a much better result.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem10
{
  public static void main(String[] args)
  {
    long sum = 0;
    List primeList = generatePrimes(2000000);        

    for(int i = 0; i &lt; primeList.size(); i++)
    {
      sum += primeList.get(i);
    }
    System.out.println(sum); 
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 24 ms.[/java]","Problem 10: Summation of Primes",,"inherit","open","open",,"45-revision-v1",,,"2014-06-07 10:02:22","2014-06-07 10:02:22",,"45","http://euler.lvtran.com/45-revision-v1/","0","revision",,"0"
"47","1","2013-12-20 10:03:20","2013-12-20 10:03:20","<p>In the 20 x 20 grid below, four numbers along a diagonal line have been marked in red. The product of these numbers is 26 * 63 * 78 * 14 = 1788696. What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20 x 20 grid?</p>
<!--more-->


<p style=""text-align: center;"">08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br>
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br>
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br>
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br>
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br>
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br>
32 98 81 28 64 23 67 10 <span style=""color: #ff0000;""><b>26</b></span> 38 40 67 59 54 70 66 18 38 64 70<br>
67 26 20 68 02 62 12 20 95 <span style=""color: #ff0000;""><b>63</b></span> 94 39 63 08 40 91 66 49 94 21<br>
24 55 58 05 66 73 99 26 97 17 <span style=""color: #ff0000;""><b>78</b></span> 78 96 83 14 88 34 89 63 72<br>
21 36 23 09 75 00 76 44 20 45 35 <span style=""color: #ff0000;""><b>14</b></span> 00 61 33 97 34 31 33 95<br>
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br>
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br>
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br>
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br>
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br>
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br>
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br>
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br>
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br>
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48<br></p>
<br>

<h2>The Catch</h2>
<p>This problem is fairly straightforward; there is no other way but to check all routes of the 20 x 20 grid.</p>

<h2>The Light</h2>
<p>Checking columns and rows are simple: just loop through each row and column and find the product of every 4 entries. Checking 2 left	and right diagonals require more check points to prevent out of bound exception.</p>

<h2>The Code</h2>
[java]
public class Problem11
{
  public static void main( String[] args )
  {
    int[][] a = new int[20][20];
    int[] a1d = { 8, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91,  8,
                 49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00,
                 81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65,
                 52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91,
                 22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80,
                 24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50,
                 32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70,
                 67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63,  8, 40, 91, 66, 49, 94, 21,
                 24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72,
                 21, 36, 23,  9, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95,
                 78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14,  9, 53, 56, 92,
                 16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57,
                 86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58,
                 19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40,
                 04, 52,  8, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66,
                 88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69,
                 04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18,  8, 46, 29, 32, 40, 62, 76, 36,
                 20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16,
                 20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54,
                 01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48,};
    int index = 0;
    int max = 0;
    int product = 0;

    for(int x = 0; x &lt; a.length; x++)
    {
      for(int y = 0; y &lt; a.length; y++)
      {
        a[x][y] = a1d[index++];
      }
    }

    //Check columns
    int x3 = 0;
    for(int y = 0; y &lt; a.length; y++)
    {
      while(x3 &lt; a.length - 3)       
      {         
        product = a[x3][y] *                    
                  a[x3 + 1][y] *
                  a[x3 + 2][y] *                    
                  a[x3 + 3][y];
        if(product &gt; max)
          max = product;

        ++x3;
      }
      x3 = 0;
    }

    //Check rows
    int y4 = 0;
    for( int x = 0; x &lt; a.length; x++)
    {
      while(y4 &lt; a.length - 3)       
      {         
        product = a[x][y4] *                    
                  a[x][y4 + 1] *                    
                  a[x][y4 + 2] *                    
                  a[x][y4 + 3];          
    
        if(product &gt; max)
          max = product;

        ++y4;
      }
      y4 = 0;
    }

    //Check left diagonal below
    int x = 1;
    int tmp = 1;
    while(x &lt; a.length - 3)
    {
      for(int y = 0; y &lt; a.length - 3 - tmp; y++)       
      {         
        product = a[x][y] *                    
                  a[x + 1][y + 1] *                    
                  a[x + 1][y + 2] *                    
                  a[x + 1][y + 3];               

        if(product &gt; max)
          max = product;

        ++x;
      }
      x = ++tmp;
    }

    //Chek left diagonal above
    int x2 = 1;
    int tmp2 = 1;
    while(x2 &lt; a.length - 3)
    {
      for(int y = 0; y &lt; a.length - 3 - tmp2; y++)       
      {         
        product = a[y][x2] *                    
                  a[y + 1][x2 + 1] *                    
                  a[y + 2][x2 + 2] *                    
                  a[y + 3][x2 + 3];          

        if(product &gt; max)
          max = product;

        ++x2;
      }
      x2 = ++tmp2;
    }

    //Check left diagonal middle line
    for(int i = 0; i &lt; a.length - 3; i++)     
    {       
      product = a[i][i] *                  
                a[i + 1][i + 1] *                  
                a[i + 2][i + 2] *                  
                a[i + 3][i + 3];        

      if(product &gt; max)
        max = product;
    }

    //Check right diagonal above and diagonal middle line
    int x5 = 3;
    int tmp5 = 3;
    int count = 16;
    while(x5 &lt; a.length)
    {
      for(int y = 0; y &lt; a.length - 3 - count; y++)       
      {         
        product = a[x5][y] *                    
                  a[x5 - 1][y + 1] *                    
                  a[x5 - 2][y + 2] *                    
                  a[x5 - 3][y + 3];          
 
        if(product &gt; max)
          max = product;

        x5--;
      }
      count--;
      x5 = ++tmp5;
    }

    //Check right diagonal below
    int y6 = 1;
    int tmp6 = 1;
    while(y6 &lt; a.length - 3)     
    {       
      for(x = a.length - 1; x &gt; 3 &amp;&amp; y6 &lt; a.length - 3; x--)       
      {         
        product = a[x][y6] *                    
                  a[x - 1][y6 + 1] *                    
                  a[x - 2][y6 + 2] *                    
                  a[x - 3][y6 + 3];          

        if(product &gt; max)
          max = product;

        y6++;
      }
      y6 = ++tmp6;	  
    }
    System.out.println(max);
  }
}
[/java]
[java]Execution time: 1 ms.[/java]","Problem 11: Largest Product in a Grid",,"publish","closed","closed",,"p11",,,"2014-06-15 07:08:39","2014-06-15 07:08:39",,"0","http://euler.lvtran.com/?p=47","0","post",,"0"
"60","1","2014-06-07 10:12:47","2014-06-07 10:12:47","<p>In the 20 x 20 grid below, four numbers along a diagonal line have been marked in red. The product of these numbers is 26 * 63 * 78 * 14 = 1788696. What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20 x 20 grid?</p>
<!--more-->


<p style=""text-align: center;"">08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br>
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br>
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br>
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br>
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br>
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br>
32 98 81 28 64 23 67 10 <span style=""color: #ff0000;""><b>26</b></span> 38 40 67 59 54 70 66 18 38 64 70<br>
67 26 20 68 02 62 12 20 95 <span style=""color: #ff0000;""><b>63</b></span> 94 39 63 08 40 91 66 49 94 21<br>
24 55 58 05 66 73 99 26 97 17 <span style=""color: #ff0000;""><b>78</b></span> 78 96 83 14 88 34 89 63 72<br>
21 36 23 09 75 00 76 44 20 45 35 <span style=""color: #ff0000;""><b>14</b></span> 00 61 33 97 34 31 33 95<br>
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br>
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br>
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br>
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br>
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br>
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br>
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br>
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br>
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br>
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48<br></p>
<br>

<h2>The Catch</h2>
<p>This problem is fairly straightforward; there is no other way but to check all routes of the 20 x 20 grid.</p>

<h2>The Light</h2>
<p>Checking columns and rows are simple: just loop through each row and column and find the product of every 4 entries. Checking 2 left	and right diagonals require more check points to prevent out of bound exception.</p>

<h2>The Code</h2>
[java]
public class Problem11
{
  public static void main( String[] args )
  {
    int[][] a = new int[20][20];
    int[] a1d = { 8, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91,  8,
                 49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00,
                 81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65,
                 52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91,
                 22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80,
                 24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50,
                 32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70,
                 67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63,  8, 40, 91, 66, 49, 94, 21,
                 24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72,
                 21, 36, 23,  9, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95,
                 78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14,  9, 53, 56, 92,
                 16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57,
                 86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58,
                 19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40,
                 04, 52,  8, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66,
                 88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69,
                 04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18,  8, 46, 29, 32, 40, 62, 76, 36,
                 20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16,
                 20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54,
                 01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48,};
    int index = 0;
    int max = 0;
    int product = 0;

    for(int x = 0; x &lt; a.length; x++)
    {
      for(int y = 0; y &lt; a.length; y++)
      {
        a[x][y] = a1d[index++];
      }
    }

    //Check columns
    int x3 = 0;
    for(int y = 0; y &lt; a.length; y++)
    {
      while(x3 &lt; a.length - 3)       
      {         
        product = a[x3][y] *                    
                  a[x3 + 1][y] *
                  a[x3 + 2][y] *                    
                  a[x3 + 3][y];
        if(product &gt; max)
          max = product;

        ++x3;
      }
      x3 = 0;
    }

    //Check rows
    int y4 = 0;
    for( int x = 0; x &lt; a.length; x++)
    {
      while(y4 &lt; a.length - 3)       
      {         
        product = a[x][y4] *                    
                  a[x][y4 + 1] *                    
                  a[x][y4 + 2] *                    
                  a[x][y4 + 3];          
    
        if(product &gt; max)
          max = product;

        ++y4;
      }
      y4 = 0;
    }

    //Check left diagonal below
    int x = 1;
    int tmp = 1;
    while(x &lt; a.length - 3)
    {
      for(int y = 0; y &lt; a.length - 3 - tmp; y++)       
      {         
        product = a[x][y] *                    
                  a[x + 1][y + 1] *                    
                  a[x + 1][y + 2] *                    
                  a[x + 1][y + 3];               

        if(product &gt; max)
          max = product;

        ++x;
      }
      x = ++tmp;
    }

    //Chek left diagonal above
    int x2 = 1;
    int tmp2 = 1;
    while(x2 &lt; a.length - 3)
    {
      for(int y = 0; y &lt; a.length - 3 - tmp2; y++)       
      {         
        product = a[y][x2] *                    
                  a[y + 1][x2 + 1] *                    
                  a[y + 2][x2 + 2] *                    
                  a[y + 3][x2 + 3];          

        if(product &gt; max)
          max = product;

        ++x2;
      }
      x2 = ++tmp2;
    }

    //Check left diagonal middle line
    for(int i = 0; i &lt; a.length - 3; i++)     
    {       
      product = a[i][i] *                  
                a[i + 1][i + 1] *                  
                a[i + 2][i + 2] *                  
                a[i + 3][i + 3];        

      if(product &gt; max)
        max = product;
    }

    //Check right diagonal above and diagonal middle line
    int x5 = 3;
    int tmp5 = 3;
    int count = 16;
    while(x5 &lt; a.length)
    {
      for(int y = 0; y &lt; a.length - 3 - count; y++)       
      {         
        product = a[x5][y] *                    
                  a[x5 - 1][y + 1] *                    
                  a[x5 - 2][y + 2] *                    
                  a[x5 - 3][y + 3];          
 
        if(product &gt; max)
          max = product;

        x5--;
      }
      count--;
      x5 = ++tmp5;
    }

    //Check right diagonal below
    int y6 = 1;
    int tmp6 = 1;
    while(y6 &lt; a.length - 3)     
    {       
      for(x = a.length - 1; x &gt; 3 &amp;&amp; y6 &lt; a.length - 3; x--)       
      {         
        product = a[x][y6] *                    
                  a[x - 1][y6 + 1] *                    
                  a[x - 2][y6 + 2] *                    
                  a[x - 3][y6 + 3];          

        if(product &gt; max)
          max = product;

        y6++;
      }
      y6 = ++tmp6;	  
    }
    System.out.println(max);
  }
}
[/java]
[java]Execution time: 1 ms.[/java]","Problem 11: Largest Product in a Grid",,"inherit","open","open",,"47-revision-v1",,,"2014-06-07 10:12:47","2014-06-07 10:12:47",,"47","http://euler.lvtran.com/47-revision-v1/","0","revision",,"0"
"48","1","2014-06-07 10:03:20","2014-06-07 10:03:20","<h2>The Problem</h2> 
<p>In the 20 x 20 grid below, four numbers along a diagonal line have been marked in red.
<p style=""text-align: center;"">08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br>
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br>
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br>
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br>
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br>
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br>
32 98 81 28 64 23 67 10 <span style=""color: #ff0000;""><b>26</b></span> 38 40 67 59 54 70 66 18 38 64 70<br>
67 26 20 68 02 62 12 20 95 <span style=""color: #ff0000;""><b>63</b></span> 94 39 63 08 40 91 66 49 94 21<br>
24 55 58 05 66 73 99 26 97 17 <span style=""color: #ff0000;""><b>78</b></span> 78 96 83 14 88 34 89 63 72<br>
21 36 23 09 75 00 76 44 20 45 35 <span style=""color: #ff0000;""><b>14</b></span> 00 61 33 97 34 31 33 95<br>
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br>
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br>
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br>
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br>
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br>
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br>
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br>
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br>
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br>
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48<br></p>
<br>The product of these numbers is 26 * 63 * 78 * 14 = 1788696. What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20 x 20 grid?</p>
<!--more-->


<h2>The Catch</h2>
<p>This problem is fairly straightforward; there is no other way but to check all routes of the 20 x 20 grid.</p>

<h2>The Light</h2>
<p>Checking columns and rows are simple: just loop through each row and column and find the product of every 4 entries. Checking 2 left	and right diagonals require more check points to prevent out of bound exception.</p>

<h2>The Code</h2>
[java]
public class Problem11
{
  public static void main( String[] args )
  {
    int[][] a = new int[20][20];
    int[] a1d = { 8, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91,  8,
                 49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00,
                 81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65,
                 52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91,
                 22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80,
                 24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50,
                 32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70,
                 67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63,  8, 40, 91, 66, 49, 94, 21,
                 24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72,
                 21, 36, 23,  9, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95,
                 78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14,  9, 53, 56, 92,
                 16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57,
                 86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58,
                 19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40,
                 04, 52,  8, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66,
                 88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69,
                 04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18,  8, 46, 29, 32, 40, 62, 76, 36,
                 20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16,
                 20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54,
                 01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48,};
    int index = 0;
    int max = 0;
    int product = 0;

    for(int x = 0; x &lt; a.length; x++)
    {
      for(int y = 0; y &lt; a.length; y++)
      {
        a[x][y] = a1d[index++];
      }
    }

    //Check columns
    int x3 = 0;
    for(int y = 0; y &lt; a.length; y++)
    {
      while(x3 &lt; a.length - 3)       
      {         
        product = a[x3][y] *                    
                  a[x3 + 1][y] *
                  a[x3 + 2][y] *                    
                  a[x3 + 3][y];
        if(product &gt; max)
          max = product;

        ++x3;
      }
      x3 = 0;
    }

    //Check rows
    int y4 = 0;
    for( int x = 0; x &lt; a.length; x++)
    {
      while(y4 &lt; a.length - 3)       
      {         
        product = a[x][y4] *                    
                  a[x][y4 + 1] *                    
                  a[x][y4 + 2] *                    
                  a[x][y4 + 3];          
    
        if(product &gt; max)
          max = product;

        ++y4;
      }
      y4 = 0;
    }

    //Check left diagonal below
    int x = 1;
    int tmp = 1;
    while(x &lt; a.length - 3)
    {
      for(int y = 0; y &lt; a.length - 3 - tmp; y++)       
      {         
        product = a[x][y] *                    
                  a[x + 1][y + 1] *                    
                  a[x + 1][y + 2] *                    
                  a[x + 1][y + 3];               

        if(product &gt; max)
          max = product;

        ++x;
      }
      x = ++tmp;
    }

    //Chek left diagonal above
    int x2 = 1;
    int tmp2 = 1;
    while(x2 &lt; a.length - 3)
    {
      for(int y = 0; y &lt; a.length - 3 - tmp2; y++)       
      {         
        product = a[y][x2] *                    
                  a[y + 1][x2 + 1] *                    
                  a[y + 2][x2 + 2] *                    
                  a[y + 3][x2 + 3];          

        if(product &gt; max)
          max = product;

        ++x2;
      }
      x2 = ++tmp2;
    }

    //Check left diagonal middle line
    for(int i = 0; i &lt; a.length - 3; i++)     
    {       
      product = a[i][i] *                  
                a[i + 1][i + 1] *                  
                a[i + 2][i + 2] *                  
                a[i + 3][i + 3];        

      if(product &gt; max)
        max = product;
    }

    //Check right diagonal above and diagonal middle line
    int x5 = 3;
    int tmp5 = 3;
    int count = 16;
    while(x5 &lt; a.length)
    {
      for(int y = 0; y &lt; a.length - 3 - count; y++)       
      {         
        product = a[x5][y] *                    
                  a[x5 - 1][y + 1] *                    
                  a[x5 - 2][y + 2] *                    
                  a[x5 - 3][y + 3];          
 
        if(product &gt; max)
          max = product;

        x5--;
      }
      count--;
      x5 = ++tmp5;
    }

    //Check right diagonal below
    int y6 = 1;
    int tmp6 = 1;
    while(y6 &lt; a.length - 3)     
    {       
      for(x = a.length - 1; x &gt; 3 &amp;&amp; y6 &lt; a.length - 3; x--)       
      {         
        product = a[x][y6] *                    
                  a[x - 1][y6 + 1] *                    
                  a[x - 2][y6 + 2] *                    
                  a[x - 3][y6 + 3];          

        if(product &gt; max)
          max = product;

        y6++;
      }
      y6 = ++tmp6;	  
    }
    System.out.println(max);
  }
}
[/java]
[java]Execution time: 1 ms.[/java]","Problem 11: Largest Product in a Grid",,"inherit","open","open",,"47-revision-v1",,,"2014-06-07 10:03:20","2014-06-07 10:03:20",,"47","http://euler.lvtran.com/47-revision-v1/","0","revision",,"0"
"49","1","2013-12-19 10:03:45","2013-12-19 10:03:45","<p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7<sup>th</sup> triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be: 1, 3, 			6, 10, 15, 21, 28, 36, 45, 55, ... Let us list the factors of the first seven triangle numbers. We can see that 28 is the first triangle number to have over five divisors. What is the value of the first triangle number to have over five hundred divisors?
<b>1</b>: 1<br>
<b>3</b>: 1,3<br>
<b>6</b>: 1,2,3,6<br>
<b>10</b>: 1,2,5,10<br>
<b>15</b>: 1,3,5,15<br>
<b>21</b>: 1,3,7,21<br>
<b>28</b>: 1,2,4,7,14,28</p></p><br><br>
<!--more-->


<h2>The Catch</h2>
<p>How to find all of the divisors of an arbitrary number <strong>x</strong>.</p>

<h2>The Light</h2>
<p>&clubs;&nbsp;Using similar idea from <a href=""http://lvtran.com/p3/"">Problem 3</a>, we only need to check numbers from <strong>1</strong> to <strong>sqrt(x)</strong> and times the answer by 2 to get <strong>x</strong>'s total numbers of divisors.
<p>Example: How many divisors does 360 have? <br>Check numbers from 1 to sqrt(360) = 18.97. From 1 to 18.97, 360 has <strong>12</strong> divisors (1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 18). Thus, 360 has a total of <strong>24</strong> divisors (1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 18, 20, 24, 30, 36, 40, 45, 60, 72, 90, 120, 180, 360).
<p>&clubs;&nbsp;There is an even better way to calculate the number of divisors the number <strong>x</strong> has: <a href=""http://en.wikipedia.org/wiki/Prime_factor"" target=""_blank"">prime factorization</a>. A positive number <strong>x</strong> can be written as the product of primes:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Divide <strong>x</strong> by the first prime, 2, until <strong>x</strong> is no longer divisible by 2.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat with the next lowest prime number until <strong>x</strong> gets reduced to 1.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Write the prime factors into exponent forms.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Add 1 to each exponent and find their product, which is the total number of divisors.
<br>Example: Find 360's total number of divisors.
360/2 = 180
180/2 = 90
90/2 = 45 (No longer divisible by 2, move on to 3)
45/3 = 15
15/3 = 5 (No longer divisible by 3, move on to 5)
5/5 = 1 (x gets reduced to 1, stop)
So 360 = 2<sup>3</sup> * 3<sup>2</sup> * 5<sup>1</sup>
<br>Total number of divisors = (3 + 1) * (2 + 1) * (1 + 1) = 24</p>

&clubs;&nbsp;Prime factorization requires a pre-calculated list of prime, which can be achieved by <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" target=""_blank"">Sieve of Eratosthenes</a> as discussed in <a href=""http://lvtran.com/p35/"">Problem 35</a>.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem12
{    
  static List primeList = generatePrimes(100000);

  public static void main(String[] args)
  {
    long triNum = 0;

    for( int i = 1;; i++ )
    {
      triNum += i;
      if(primeFactorize(triNum) &gt; 500)
      {
        System.out.println(triNum);
        break;
      }	  
    }
  }

  public static int primeFactorize(long n)
  {
    int index = 0;
    int divisors = 1;

    while(n &gt; 1)
    {
      int count = 0;
      while(n % primeList.get(index) == 0)
      {
        count++;
    	n /= primeList.get(index);
      }
      divisors *= ++count;
      index++;
    }

    return divisors;
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 49 ms.[/java]","Problem 12: Highly Divisible Triangular Number",,"publish","closed","closed",,"p12",,,"2014-06-15 07:08:40","2014-06-15 07:08:40",,"0","http://euler.lvtran.com/?p=49","0","post",,"0"
"61","1","2014-06-07 10:13:18","2014-06-07 10:13:18","<p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7<sup>th</sup> triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be: 1, 3, 			6, 10, 15, 21, 28, 36, 45, 55, ... Let us list the factors of the first seven triangle numbers. We can see that 28 is the first triangle number to have over five divisors. What is the value of the first triangle number to have over five hundred divisors?
<b>1</b>: 1<br>
<b>3</b>: 1,3<br>
<b>6</b>: 1,2,3,6<br>
<b>10</b>: 1,2,5,10<br>
<b>15</b>: 1,3,5,15<br>
<b>21</b>: 1,3,7,21<br>
<b>28</b>: 1,2,4,7,14,28</p></p><br><br>
<!--more-->


<h2>The Catch</h2>
<p>How to find all of the divisors of an arbitrary number <strong>x</strong>.</p>

<h2>The Light</h2>
<p>&clubs;&nbsp;Using similar idea from <a href=""http://lvtran.com/p3/"">Problem 3</a>, we only need to check numbers from <strong>1</strong> to <strong>sqrt(x)</strong> and times the answer by 2 to get <strong>x</strong>'s total numbers of divisors.
<p>Example: How many divisors does 360 have? <br>Check numbers from 1 to sqrt(360) = 18.97. From 1 to 18.97, 360 has <strong>12</strong> divisors (1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 18). Thus, 360 has a total of <strong>24</strong> divisors (1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 18, 20, 24, 30, 36, 40, 45, 60, 72, 90, 120, 180, 360).
<p>&clubs;&nbsp;There is an even better way to calculate the number of divisors the number <strong>x</strong> has: <a href=""http://en.wikipedia.org/wiki/Prime_factor"" target=""_blank"">prime factorization</a>. A positive number <strong>x</strong> can be written as the product of primes:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Divide <strong>x</strong> by the first prime, 2, until <strong>x</strong> is no longer divisible by 2.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat with the next lowest prime number until <strong>x</strong> gets reduced to 1.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Write the prime factors into exponent forms.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Add 1 to each exponent and find their product, which is the total number of divisors.
<br>Example: Find 360's total number of divisors.
360/2 = 180
180/2 = 90
90/2 = 45 (No longer divisible by 2, move on to 3)
45/3 = 15
15/3 = 5 (No longer divisible by 3, move on to 5)
5/5 = 1 (x gets reduced to 1, stop)
So 360 = 2<sup>3</sup> * 3<sup>2</sup> * 5<sup>1</sup>
<br>Total number of divisors = (3 + 1) * (2 + 1) * (1 + 1) = 24</p>

&clubs;&nbsp;Prime factorization requires a pre-calculated list of prime, which can be achieved by <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" target=""_blank"">Sieve of Eratosthenes</a> as discussed in <a href=""http://lvtran.com/p35/"">Problem 35</a>.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem12
{    
  static List primeList = generatePrimes(100000);

  public static void main(String[] args)
  {
    long triNum = 0;

    for( int i = 1;; i++ )
    {
      triNum += i;
      if(primeFactorize(triNum) &gt; 500)
      {
        System.out.println(triNum);
        break;
      }	  
    }
  }

  public static int primeFactorize(long n)
  {
    int index = 0;
    int divisors = 1;

    while(n &gt; 1)
    {
      int count = 0;
      while(n % primeList.get(index) == 0)
      {
        count++;
    	n /= primeList.get(index);
      }
      divisors *= ++count;
      index++;
    }

    return divisors;
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 49 ms.[/java]","Problem 12: Highly Divisible Triangular Number",,"inherit","open","open",,"49-revision-v1",,,"2014-06-07 10:13:18","2014-06-07 10:13:18",,"49","http://euler.lvtran.com/49-revision-v1/","0","revision",,"0"
"50","1","2014-06-07 10:03:45","2014-06-07 10:03:45","<h2>The Problem</h2> 
<p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7<sup>th</sup> triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be: 1, 3, 			6, 10, 15, 21, 28, 36, 45, 55, ... Let us list the factors of the first seven triangle numbers. We can see that 28 is the first triangle number to have over five divisors. What is the value of the first triangle number to have over five hundred divisors?
<b>1</b>: 1<br>
<b>3</b>: 1,3<br>
<b>6</b>: 1,2,3,6<br>
<b>10</b>: 1,2,5,10<br>
<b>15</b>: 1,3,5,15<br>
<b>21</b>: 1,3,7,21<br>
<b>28</b>: 1,2,4,7,14,28</p></p><br><br>
<!--more-->


<h2>The Catch</h2>
<p>How to find all of the divisors of an arbitrary number <strong>x</strong>.</p>

<h2>The Light</h2>
<p>&clubs;&nbsp;Using similar idea from <a href=""http://lvtran.com/p3/"">Problem 3</a>, we only need to check numbers from <strong>1</strong> to <strong>sqrt(x)</strong> and times the answer by 2 to get <strong>x</strong>'s total numbers of divisors.
<p>Example: How many divisors does 360 have? <br>Check numbers from 1 to sqrt(360) = 18.97. From 1 to 18.97, 360 has <strong>12</strong> divisors (1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 18). Thus, 360 has a total of <strong>24</strong> divisors (1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 18, 20, 24, 30, 36, 40, 45, 60, 72, 90, 120, 180, 360).
<p>&clubs;&nbsp;There is an even better way to calculate the number of divisors the number <strong>x</strong> has: <a href=""http://en.wikipedia.org/wiki/Prime_factor"" target=""_blank"">prime factorization</a>. A positive number <strong>x</strong> can be written as the product of primes:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Divide <strong>x</strong> by the first prime, 2, until <strong>x</strong> is no longer divisible by 2.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat with the next lowest prime number until <strong>x</strong> gets reduced to 1.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Write the prime factors into exponent forms.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Add 1 to each exponent and find their product, which is the total number of divisors.
<br>Example: Find 360's total number of divisors.
360/2 = 180
180/2 = 90
90/2 = 45 (No longer divisible by 2, move on to 3)
45/3 = 15
15/3 = 5 (No longer divisible by 3, move on to 5)
5/5 = 1 (x gets reduced to 1, stop)
So 360 = 2<sup>3</sup> * 3<sup>2</sup> * 5<sup>1</sup>
<br>Total number of divisors = (3 + 1) * (2 + 1) * (1 + 1) = 24</p>

&clubs;&nbsp;Prime factorization requires a pre-calculated list of prime, which can be achieved by <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" target=""_blank"">Sieve of Eratosthenes</a> as discussed in <a href=""http://lvtran.com/p35/"">Problem 35</a>.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem12
{    
  static List primeList = generatePrimes(100000);

  public static void main(String[] args)
  {
    long triNum = 0;

    for( int i = 1;; i++ )
    {
      triNum += i;
      if(primeFactorize(triNum) &gt; 500)
      {
        System.out.println(triNum);
        break;
      }	  
    }
  }

  public static int primeFactorize(long n)
  {
    int index = 0;
    int divisors = 1;

    while(n &gt; 1)
    {
      int count = 0;
      while(n % primeList.get(index) == 0)
      {
        count++;
    	n /= primeList.get(index);
      }
      divisors *= ++count;
      index++;
    }

    return divisors;
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 49 ms.[/java]","Problem 12: Highly Divisible Triangular Number",,"inherit","open","open",,"49-revision-v1",,,"2014-06-07 10:03:45","2014-06-07 10:03:45",,"49","http://euler.lvtran.com/49-revision-v1/","0","revision",,"0"
"51","1","2013-12-18 10:04:05","2013-12-18 10:04:05","<p>Work out the first ten digits of the sum of the following one-hundred 50-digit numbers (one number on each line).<!--more-->


<div align=""center""><p>
				37107287533902102798797998220837590246510135740250<br>
				46376937677490009712648124896970078050417018260538<br>
				74324986199524741059474233309513058123726617309629<br>
				91942213363574161572522430563301811072406154908250<br>
				23067588207539346171171980310421047513778063246676<br>
				89261670696623633820136378418383684178734361726757<br>
				28112879812849979408065481931592621691275889832738<br>
				44274228917432520321923589422876796487670272189318<br>
				47451445736001306439091167216856844588711603153276<br>
				70386486105843025439939619828917593665686757934951<br>
				62176457141856560629502157223196586755079324193331<br>
				64906352462741904929101432445813822663347944758178<br>
				92575867718337217661963751590579239728245598838407<br>
				58203565325359399008402633568948830189458628227828<br>
				80181199384826282014278194139940567587151170094390<br>
				35398664372827112653829987240784473053190104293586<br>
				86515506006295864861532075273371959191420517255829<br>
				71693888707715466499115593487603532921714970056938<br>
				54370070576826684624621495650076471787294438377604<br>
				53282654108756828443191190634694037855217779295145<br>
				36123272525000296071075082563815656710885258350721<br>
				45876576172410976447339110607218265236877223636045<br>
				17423706905851860660448207621209813287860733969412<br>
				81142660418086830619328460811191061556940512689692<br>
				51934325451728388641918047049293215058642563049483<br>
				62467221648435076201727918039944693004732956340691<br>
				15732444386908125794514089057706229429197107928209<br>
				55037687525678773091862540744969844508330393682126<br>
				18336384825330154686196124348767681297534375946515<br>
				80386287592878490201521685554828717201219257766954<br>
				78182833757993103614740356856449095527097864797581<br>
				16726320100436897842553539920931837441497806860984<br>
				48403098129077791799088218795327364475675590848030<br>
				87086987551392711854517078544161852424320693150332<br>
				59959406895756536782107074926966537676326235447210<br>
				69793950679652694742597709739166693763042633987085<br>
				41052684708299085211399427365734116182760315001271<br>
				65378607361501080857009149939512557028198746004375<br>
				35829035317434717326932123578154982629742552737307<br>
				94953759765105305946966067683156574377167401875275<br>
				88902802571733229619176668713819931811048770190271<br>
				25267680276078003013678680992525463401061632866526<br>
				36270218540497705585629946580636237993140746255962<br>
				24074486908231174977792365466257246923322810917141<br>
				91430288197103288597806669760892938638285025333403<br>
				34413065578016127815921815005561868836468420090470<br>
				23053081172816430487623791969842487255036638784583<br>
				11487696932154902810424020138335124462181441773470<br>
				63783299490636259666498587618221225225512486764533<br>
				67720186971698544312419572409913959008952310058822<br>
				95548255300263520781532296796249481641953868218774<br>
				76085327132285723110424803456124867697064507995236<br>
				37774242535411291684276865538926205024910326572967<br>
				23701913275725675285653248258265463092207058596522<br>
				29798860272258331913126375147341994889534765745501<br>
				18495701454879288984856827726077713721403798879715<br>
				38298203783031473527721580348144513491373226651381<br>
				34829543829199918180278916522431027392251122869539<br>
				40957953066405232632538044100059654939159879593635<br>
				29746152185502371307642255121183693803580388584903<br>
				41698116222072977186158236678424689157993532961922<br>
				62467957194401269043877107275048102390895523597457<br>
				23189706772547915061505504953922979530901129967519<br>
				86188088225875314529584099251203829009407770775672<br>
				11306739708304724483816533873502340845647058077308<br>
				82959174767140363198008187129011875491310547126581<br>
				97623331044818386269515456334926366572897563400500<br>
				42846280183517070527831839425882145521227251250327<br>
				55121603546981200581762165212827652751691296897789<br>
				32238195734329339946437501907836945765883352399886<br>
				75506164965184775180738168837861091527357929701337<br>
				62177842752192623401942399639168044983993173312731<br>
				32924185707147349566916674687634660915035914677504<br>
				99518671430235219628894890102423325116913619626622<br>
				73267460800591547471830798392868535206946944540724<br>
				76841822524674417161514036427982273348055556214818<br>
				97142617910342598647204516893989422179826088076852<br>
				87783646182799346313767754307809363333018982642090<br>
				10848802521674670883215120185883543223812876952786<br>
				71329612474782464538636993009049310363619763878039<br>
				62184073572399794223406235393808339651327408011116<br>
				66627891981488087797941876876144230030984490851411<br>
				60661826293682836764744779239180335110989069790714<br>
				85786944089552990653640447425576083659976645795096<br>
				66024396409905389607120198219976047599490197230297<br>
				64913982680032973156037120041377903785566085089252<br>
				16730939319872750275468906903707539413042652315011<br>
				94809377245048795150954100921645863754710598436791<br>
				78639167021187492431995700641917969777599028300699<br>
				15368713711936614952811305876380278410754449733078<br>
				40789923115535562561142322423255033685442488917353<br>
				44889911501440648020369068063960672322193204149535<br>
				41503128880339536053299340368006977710650566631954<br>
				81234880673210146739058568557934581403627822703280<br>
				82616570773948327592232845941706525094512325230608<br>
				22918802058777319719839450180888072429661980811197<br>
				77158542502016545090413245809786882778948721859617<br>
				72107838435069186155435662884062257473692284509516<br>
				20849603980134001723930671666823555245252804609722<br>
				53503534226472524250874054075591789781264330331690<br>
</p></div>

<h2>The Catch</h2>
<p>How to store and quickly calculate extremely large numbers.</p>

<h2>The Light</h2>
<p>Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem13
{
  public static void main(String[] args)
  {
    String[] num = 
    {
      ""37107287533902102798797998220837590246510135740250"",
      ""46376937677490009712648124896970078050417018260538"",
      ""74324986199524741059474233309513058123726617309629"",
      ""91942213363574161572522430563301811072406154908250"",
      ""23067588207539346171171980310421047513778063246676"",
      ""89261670696623633820136378418383684178734361726757"",
      ""28112879812849979408065481931592621691275889832738"",
      ""44274228917432520321923589422876796487670272189318"",
      ""47451445736001306439091167216856844588711603153276"",
      ""70386486105843025439939619828917593665686757934951"",
      ""62176457141856560629502157223196586755079324193331"",
      ""64906352462741904929101432445813822663347944758178"",
      ""92575867718337217661963751590579239728245598838407"",
      ""58203565325359399008402633568948830189458628227828"",
      ""80181199384826282014278194139940567587151170094390"",
      ""35398664372827112653829987240784473053190104293586"",
      ""86515506006295864861532075273371959191420517255829"",
      ""71693888707715466499115593487603532921714970056938"",
      ""54370070576826684624621495650076471787294438377604"",
      ""53282654108756828443191190634694037855217779295145"",
      ""36123272525000296071075082563815656710885258350721"",
      ""45876576172410976447339110607218265236877223636045"",
      ""17423706905851860660448207621209813287860733969412"",
      ""81142660418086830619328460811191061556940512689692"",
      ""51934325451728388641918047049293215058642563049483"",
      ""62467221648435076201727918039944693004732956340691"",
      ""15732444386908125794514089057706229429197107928209"",
      ""55037687525678773091862540744969844508330393682126"",
      ""18336384825330154686196124348767681297534375946515"",
      ""80386287592878490201521685554828717201219257766954"",
      ""78182833757993103614740356856449095527097864797581"",
      ""16726320100436897842553539920931837441497806860984"",
      ""48403098129077791799088218795327364475675590848030"",
      ""87086987551392711854517078544161852424320693150332"",
      ""59959406895756536782107074926966537676326235447210"",
      ""69793950679652694742597709739166693763042633987085"",
      ""41052684708299085211399427365734116182760315001271"",
      ""65378607361501080857009149939512557028198746004375"",
      ""35829035317434717326932123578154982629742552737307"",
      ""94953759765105305946966067683156574377167401875275"",
      ""88902802571733229619176668713819931811048770190271"",
      ""25267680276078003013678680992525463401061632866526"",
      ""36270218540497705585629946580636237993140746255962"",
      ""24074486908231174977792365466257246923322810917141"",
      ""91430288197103288597806669760892938638285025333403"",
      ""34413065578016127815921815005561868836468420090470"",
      ""23053081172816430487623791969842487255036638784583"",
      ""11487696932154902810424020138335124462181441773470"",
      ""63783299490636259666498587618221225225512486764533"",
      ""67720186971698544312419572409913959008952310058822"",
      ""95548255300263520781532296796249481641953868218774"",
      ""76085327132285723110424803456124867697064507995236"",
      ""37774242535411291684276865538926205024910326572967"",
      ""23701913275725675285653248258265463092207058596522"",
      ""29798860272258331913126375147341994889534765745501"",
      ""18495701454879288984856827726077713721403798879715"",
      ""38298203783031473527721580348144513491373226651381"",
      ""34829543829199918180278916522431027392251122869539"",
      ""40957953066405232632538044100059654939159879593635"",
      ""29746152185502371307642255121183693803580388584903"",
      ""41698116222072977186158236678424689157993532961922"",
      ""62467957194401269043877107275048102390895523597457"",
      ""23189706772547915061505504953922979530901129967519"",
      ""86188088225875314529584099251203829009407770775672"",
      ""11306739708304724483816533873502340845647058077308"",
      ""82959174767140363198008187129011875491310547126581"",
      ""97623331044818386269515456334926366572897563400500"",
      ""42846280183517070527831839425882145521227251250327"",
      ""55121603546981200581762165212827652751691296897789"",
      ""32238195734329339946437501907836945765883352399886"",
      ""75506164965184775180738168837861091527357929701337"",
      ""62177842752192623401942399639168044983993173312731"",
      ""32924185707147349566916674687634660915035914677504"",
      ""99518671430235219628894890102423325116913619626622"",
      ""73267460800591547471830798392868535206946944540724"",
      ""76841822524674417161514036427982273348055556214818"",
      ""97142617910342598647204516893989422179826088076852"",
      ""87783646182799346313767754307809363333018982642090"",
      ""10848802521674670883215120185883543223812876952786"",
      ""71329612474782464538636993009049310363619763878039"",
      ""62184073572399794223406235393808339651327408011116"",
      ""66627891981488087797941876876144230030984490851411"",
      ""60661826293682836764744779239180335110989069790714"",
      ""85786944089552990653640447425576083659976645795096"",
      ""66024396409905389607120198219976047599490197230297"",
      ""64913982680032973156037120041377903785566085089252"",
      ""16730939319872750275468906903707539413042652315011"",
      ""94809377245048795150954100921645863754710598436791"",
      ""78639167021187492431995700641917969777599028300699"",
      ""15368713711936614952811305876380278410754449733078"",
      ""40789923115535562561142322423255033685442488917353"",
      ""44889911501440648020369068063960672322193204149535"",
      ""41503128880339536053299340368006977710650566631954"",
      ""81234880673210146739058568557934581403627822703280"",
      ""82616570773948327592232845941706525094512325230608"",
      ""22918802058777319719839450180888072429661980811197"",
      ""77158542502016545090413245809786882778948721859617"",
      ""72107838435069186155435662884062257473692284509516"",
      ""20849603980134001723930671666823555245252804609722"",
      ""53503534226472524250874054075591789781264330331690"",
    };
    BigInteger sum = BigInteger.ZERO; 
    for(int i = 0; i &lt; 100; i++)
    {
      sum = sum.add( new BigInteger(num[i]));
    }
    System.out.println(""First 10 digits are "" + sum.toString().substring(0, 10));
  }
}
[/java]
[java]Execution time: 77 ms.[/java]","Problem 13: Large Sum",,"publish","closed","closed",,"p13",,,"2014-06-15 07:08:42","2014-06-15 07:08:42",,"0","http://euler.lvtran.com/?p=51","0","post",,"0"
"52","1","2014-06-07 10:04:05","2014-06-07 10:04:05","<h2>The Problem</h2> 
<p>Work out the first ten digits of the sum of the following one-hundred 50-digit numbers (one number on each line).
<div align=""center""><p>
				37107287533902102798797998220837590246510135740250<br>
				46376937677490009712648124896970078050417018260538<br>
				74324986199524741059474233309513058123726617309629<br>
				91942213363574161572522430563301811072406154908250<br>
				23067588207539346171171980310421047513778063246676<br>
				89261670696623633820136378418383684178734361726757<br>
				28112879812849979408065481931592621691275889832738<br>
				44274228917432520321923589422876796487670272189318<br>
				47451445736001306439091167216856844588711603153276<br>
				70386486105843025439939619828917593665686757934951<br>
				62176457141856560629502157223196586755079324193331<br>
				64906352462741904929101432445813822663347944758178<br>
				92575867718337217661963751590579239728245598838407<br>
				58203565325359399008402633568948830189458628227828<br>
				80181199384826282014278194139940567587151170094390<br>
				35398664372827112653829987240784473053190104293586<br>
				86515506006295864861532075273371959191420517255829<br>
				71693888707715466499115593487603532921714970056938<br>
				54370070576826684624621495650076471787294438377604<br>
				53282654108756828443191190634694037855217779295145<br>
				36123272525000296071075082563815656710885258350721<br>
				45876576172410976447339110607218265236877223636045<br>
				17423706905851860660448207621209813287860733969412<br>
				81142660418086830619328460811191061556940512689692<br>
				51934325451728388641918047049293215058642563049483<br>
				62467221648435076201727918039944693004732956340691<br>
				15732444386908125794514089057706229429197107928209<br>
				55037687525678773091862540744969844508330393682126<br>
				18336384825330154686196124348767681297534375946515<br>
				80386287592878490201521685554828717201219257766954<br>
				78182833757993103614740356856449095527097864797581<br>
				16726320100436897842553539920931837441497806860984<br>
				48403098129077791799088218795327364475675590848030<br>
				87086987551392711854517078544161852424320693150332<br>
				59959406895756536782107074926966537676326235447210<br>
				69793950679652694742597709739166693763042633987085<br>
				41052684708299085211399427365734116182760315001271<br>
				65378607361501080857009149939512557028198746004375<br>
				35829035317434717326932123578154982629742552737307<br>
				94953759765105305946966067683156574377167401875275<br>
				88902802571733229619176668713819931811048770190271<br>
				25267680276078003013678680992525463401061632866526<br>
				36270218540497705585629946580636237993140746255962<br>
				24074486908231174977792365466257246923322810917141<br>
				91430288197103288597806669760892938638285025333403<br>
				34413065578016127815921815005561868836468420090470<br>
				23053081172816430487623791969842487255036638784583<br>
				11487696932154902810424020138335124462181441773470<br>
				63783299490636259666498587618221225225512486764533<br>
				67720186971698544312419572409913959008952310058822<br>
				95548255300263520781532296796249481641953868218774<br>
				76085327132285723110424803456124867697064507995236<br>
				37774242535411291684276865538926205024910326572967<br>
				23701913275725675285653248258265463092207058596522<br>
				29798860272258331913126375147341994889534765745501<br>
				18495701454879288984856827726077713721403798879715<br>
				38298203783031473527721580348144513491373226651381<br>
				34829543829199918180278916522431027392251122869539<br>
				40957953066405232632538044100059654939159879593635<br>
				29746152185502371307642255121183693803580388584903<br>
				41698116222072977186158236678424689157993532961922<br>
				62467957194401269043877107275048102390895523597457<br>
				23189706772547915061505504953922979530901129967519<br>
				86188088225875314529584099251203829009407770775672<br>
				11306739708304724483816533873502340845647058077308<br>
				82959174767140363198008187129011875491310547126581<br>
				97623331044818386269515456334926366572897563400500<br>
				42846280183517070527831839425882145521227251250327<br>
				55121603546981200581762165212827652751691296897789<br>
				32238195734329339946437501907836945765883352399886<br>
				75506164965184775180738168837861091527357929701337<br>
				62177842752192623401942399639168044983993173312731<br>
				32924185707147349566916674687634660915035914677504<br>
				99518671430235219628894890102423325116913619626622<br>
				73267460800591547471830798392868535206946944540724<br>
				76841822524674417161514036427982273348055556214818<br>
				97142617910342598647204516893989422179826088076852<br>
				87783646182799346313767754307809363333018982642090<br>
				10848802521674670883215120185883543223812876952786<br>
				71329612474782464538636993009049310363619763878039<br>
				62184073572399794223406235393808339651327408011116<br>
				66627891981488087797941876876144230030984490851411<br>
				60661826293682836764744779239180335110989069790714<br>
				85786944089552990653640447425576083659976645795096<br>
				66024396409905389607120198219976047599490197230297<br>
				64913982680032973156037120041377903785566085089252<br>
				16730939319872750275468906903707539413042652315011<br>
				94809377245048795150954100921645863754710598436791<br>
				78639167021187492431995700641917969777599028300699<br>
				15368713711936614952811305876380278410754449733078<br>
				40789923115535562561142322423255033685442488917353<br>
				44889911501440648020369068063960672322193204149535<br>
				41503128880339536053299340368006977710650566631954<br>
				81234880673210146739058568557934581403627822703280<br>
				82616570773948327592232845941706525094512325230608<br>
				22918802058777319719839450180888072429661980811197<br>
				77158542502016545090413245809786882778948721859617<br>
				72107838435069186155435662884062257473692284509516<br>
				20849603980134001723930671666823555245252804609722<br>
				53503534226472524250874054075591789781264330331690<br>
</p></div>

<h2>The Catch</h2>
<p>How to store and quickly calculate extremely large numbers.</p>

<h2>The Light</h2>
<p>Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem13
{
  public static void main(String[] args)
  {
    String[] num = 
    {
      ""37107287533902102798797998220837590246510135740250"",
      ""46376937677490009712648124896970078050417018260538"",
      ""74324986199524741059474233309513058123726617309629"",
      ""91942213363574161572522430563301811072406154908250"",
      ""23067588207539346171171980310421047513778063246676"",
      ""89261670696623633820136378418383684178734361726757"",
      ""28112879812849979408065481931592621691275889832738"",
      ""44274228917432520321923589422876796487670272189318"",
      ""47451445736001306439091167216856844588711603153276"",
      ""70386486105843025439939619828917593665686757934951"",
      ""62176457141856560629502157223196586755079324193331"",
      ""64906352462741904929101432445813822663347944758178"",
      ""92575867718337217661963751590579239728245598838407"",
      ""58203565325359399008402633568948830189458628227828"",
      ""80181199384826282014278194139940567587151170094390"",
      ""35398664372827112653829987240784473053190104293586"",
      ""86515506006295864861532075273371959191420517255829"",
      ""71693888707715466499115593487603532921714970056938"",
      ""54370070576826684624621495650076471787294438377604"",
      ""53282654108756828443191190634694037855217779295145"",
      ""36123272525000296071075082563815656710885258350721"",
      ""45876576172410976447339110607218265236877223636045"",
      ""17423706905851860660448207621209813287860733969412"",
      ""81142660418086830619328460811191061556940512689692"",
      ""51934325451728388641918047049293215058642563049483"",
      ""62467221648435076201727918039944693004732956340691"",
      ""15732444386908125794514089057706229429197107928209"",
      ""55037687525678773091862540744969844508330393682126"",
      ""18336384825330154686196124348767681297534375946515"",
      ""80386287592878490201521685554828717201219257766954"",
      ""78182833757993103614740356856449095527097864797581"",
      ""16726320100436897842553539920931837441497806860984"",
      ""48403098129077791799088218795327364475675590848030"",
      ""87086987551392711854517078544161852424320693150332"",
      ""59959406895756536782107074926966537676326235447210"",
      ""69793950679652694742597709739166693763042633987085"",
      ""41052684708299085211399427365734116182760315001271"",
      ""65378607361501080857009149939512557028198746004375"",
      ""35829035317434717326932123578154982629742552737307"",
      ""94953759765105305946966067683156574377167401875275"",
      ""88902802571733229619176668713819931811048770190271"",
      ""25267680276078003013678680992525463401061632866526"",
      ""36270218540497705585629946580636237993140746255962"",
      ""24074486908231174977792365466257246923322810917141"",
      ""91430288197103288597806669760892938638285025333403"",
      ""34413065578016127815921815005561868836468420090470"",
      ""23053081172816430487623791969842487255036638784583"",
      ""11487696932154902810424020138335124462181441773470"",
      ""63783299490636259666498587618221225225512486764533"",
      ""67720186971698544312419572409913959008952310058822"",
      ""95548255300263520781532296796249481641953868218774"",
      ""76085327132285723110424803456124867697064507995236"",
      ""37774242535411291684276865538926205024910326572967"",
      ""23701913275725675285653248258265463092207058596522"",
      ""29798860272258331913126375147341994889534765745501"",
      ""18495701454879288984856827726077713721403798879715"",
      ""38298203783031473527721580348144513491373226651381"",
      ""34829543829199918180278916522431027392251122869539"",
      ""40957953066405232632538044100059654939159879593635"",
      ""29746152185502371307642255121183693803580388584903"",
      ""41698116222072977186158236678424689157993532961922"",
      ""62467957194401269043877107275048102390895523597457"",
      ""23189706772547915061505504953922979530901129967519"",
      ""86188088225875314529584099251203829009407770775672"",
      ""11306739708304724483816533873502340845647058077308"",
      ""82959174767140363198008187129011875491310547126581"",
      ""97623331044818386269515456334926366572897563400500"",
      ""42846280183517070527831839425882145521227251250327"",
      ""55121603546981200581762165212827652751691296897789"",
      ""32238195734329339946437501907836945765883352399886"",
      ""75506164965184775180738168837861091527357929701337"",
      ""62177842752192623401942399639168044983993173312731"",
      ""32924185707147349566916674687634660915035914677504"",
      ""99518671430235219628894890102423325116913619626622"",
      ""73267460800591547471830798392868535206946944540724"",
      ""76841822524674417161514036427982273348055556214818"",
      ""97142617910342598647204516893989422179826088076852"",
      ""87783646182799346313767754307809363333018982642090"",
      ""10848802521674670883215120185883543223812876952786"",
      ""71329612474782464538636993009049310363619763878039"",
      ""62184073572399794223406235393808339651327408011116"",
      ""66627891981488087797941876876144230030984490851411"",
      ""60661826293682836764744779239180335110989069790714"",
      ""85786944089552990653640447425576083659976645795096"",
      ""66024396409905389607120198219976047599490197230297"",
      ""64913982680032973156037120041377903785566085089252"",
      ""16730939319872750275468906903707539413042652315011"",
      ""94809377245048795150954100921645863754710598436791"",
      ""78639167021187492431995700641917969777599028300699"",
      ""15368713711936614952811305876380278410754449733078"",
      ""40789923115535562561142322423255033685442488917353"",
      ""44889911501440648020369068063960672322193204149535"",
      ""41503128880339536053299340368006977710650566631954"",
      ""81234880673210146739058568557934581403627822703280"",
      ""82616570773948327592232845941706525094512325230608"",
      ""22918802058777319719839450180888072429661980811197"",
      ""77158542502016545090413245809786882778948721859617"",
      ""72107838435069186155435662884062257473692284509516"",
      ""20849603980134001723930671666823555245252804609722"",
      ""53503534226472524250874054075591789781264330331690"",
    };
    BigInteger sum = BigInteger.ZERO; 
    for(int i = 0; i &lt; 100; i++)
    {
      sum = sum.add( new BigInteger(num[i]));
    }
    System.out.println(""First 10 digits are "" + sum.toString().substring(0, 10));
  }
}
[/java]
[java]Execution time: 77 ms.[/java]","Problem 13: Large Sum",,"inherit","open","open",,"51-revision-v1",,,"2014-06-07 10:04:05","2014-06-07 10:04:05",,"51","http://euler.lvtran.com/51-revision-v1/","0","revision",,"0"
"62","1","2014-06-07 10:13:25","2014-06-07 10:13:25","<p>Work out the first ten digits of the sum of the following one-hundred 50-digit numbers (one number on each line).<!--more-->


<div align=""center""><p>
				37107287533902102798797998220837590246510135740250<br>
				46376937677490009712648124896970078050417018260538<br>
				74324986199524741059474233309513058123726617309629<br>
				91942213363574161572522430563301811072406154908250<br>
				23067588207539346171171980310421047513778063246676<br>
				89261670696623633820136378418383684178734361726757<br>
				28112879812849979408065481931592621691275889832738<br>
				44274228917432520321923589422876796487670272189318<br>
				47451445736001306439091167216856844588711603153276<br>
				70386486105843025439939619828917593665686757934951<br>
				62176457141856560629502157223196586755079324193331<br>
				64906352462741904929101432445813822663347944758178<br>
				92575867718337217661963751590579239728245598838407<br>
				58203565325359399008402633568948830189458628227828<br>
				80181199384826282014278194139940567587151170094390<br>
				35398664372827112653829987240784473053190104293586<br>
				86515506006295864861532075273371959191420517255829<br>
				71693888707715466499115593487603532921714970056938<br>
				54370070576826684624621495650076471787294438377604<br>
				53282654108756828443191190634694037855217779295145<br>
				36123272525000296071075082563815656710885258350721<br>
				45876576172410976447339110607218265236877223636045<br>
				17423706905851860660448207621209813287860733969412<br>
				81142660418086830619328460811191061556940512689692<br>
				51934325451728388641918047049293215058642563049483<br>
				62467221648435076201727918039944693004732956340691<br>
				15732444386908125794514089057706229429197107928209<br>
				55037687525678773091862540744969844508330393682126<br>
				18336384825330154686196124348767681297534375946515<br>
				80386287592878490201521685554828717201219257766954<br>
				78182833757993103614740356856449095527097864797581<br>
				16726320100436897842553539920931837441497806860984<br>
				48403098129077791799088218795327364475675590848030<br>
				87086987551392711854517078544161852424320693150332<br>
				59959406895756536782107074926966537676326235447210<br>
				69793950679652694742597709739166693763042633987085<br>
				41052684708299085211399427365734116182760315001271<br>
				65378607361501080857009149939512557028198746004375<br>
				35829035317434717326932123578154982629742552737307<br>
				94953759765105305946966067683156574377167401875275<br>
				88902802571733229619176668713819931811048770190271<br>
				25267680276078003013678680992525463401061632866526<br>
				36270218540497705585629946580636237993140746255962<br>
				24074486908231174977792365466257246923322810917141<br>
				91430288197103288597806669760892938638285025333403<br>
				34413065578016127815921815005561868836468420090470<br>
				23053081172816430487623791969842487255036638784583<br>
				11487696932154902810424020138335124462181441773470<br>
				63783299490636259666498587618221225225512486764533<br>
				67720186971698544312419572409913959008952310058822<br>
				95548255300263520781532296796249481641953868218774<br>
				76085327132285723110424803456124867697064507995236<br>
				37774242535411291684276865538926205024910326572967<br>
				23701913275725675285653248258265463092207058596522<br>
				29798860272258331913126375147341994889534765745501<br>
				18495701454879288984856827726077713721403798879715<br>
				38298203783031473527721580348144513491373226651381<br>
				34829543829199918180278916522431027392251122869539<br>
				40957953066405232632538044100059654939159879593635<br>
				29746152185502371307642255121183693803580388584903<br>
				41698116222072977186158236678424689157993532961922<br>
				62467957194401269043877107275048102390895523597457<br>
				23189706772547915061505504953922979530901129967519<br>
				86188088225875314529584099251203829009407770775672<br>
				11306739708304724483816533873502340845647058077308<br>
				82959174767140363198008187129011875491310547126581<br>
				97623331044818386269515456334926366572897563400500<br>
				42846280183517070527831839425882145521227251250327<br>
				55121603546981200581762165212827652751691296897789<br>
				32238195734329339946437501907836945765883352399886<br>
				75506164965184775180738168837861091527357929701337<br>
				62177842752192623401942399639168044983993173312731<br>
				32924185707147349566916674687634660915035914677504<br>
				99518671430235219628894890102423325116913619626622<br>
				73267460800591547471830798392868535206946944540724<br>
				76841822524674417161514036427982273348055556214818<br>
				97142617910342598647204516893989422179826088076852<br>
				87783646182799346313767754307809363333018982642090<br>
				10848802521674670883215120185883543223812876952786<br>
				71329612474782464538636993009049310363619763878039<br>
				62184073572399794223406235393808339651327408011116<br>
				66627891981488087797941876876144230030984490851411<br>
				60661826293682836764744779239180335110989069790714<br>
				85786944089552990653640447425576083659976645795096<br>
				66024396409905389607120198219976047599490197230297<br>
				64913982680032973156037120041377903785566085089252<br>
				16730939319872750275468906903707539413042652315011<br>
				94809377245048795150954100921645863754710598436791<br>
				78639167021187492431995700641917969777599028300699<br>
				15368713711936614952811305876380278410754449733078<br>
				40789923115535562561142322423255033685442488917353<br>
				44889911501440648020369068063960672322193204149535<br>
				41503128880339536053299340368006977710650566631954<br>
				81234880673210146739058568557934581403627822703280<br>
				82616570773948327592232845941706525094512325230608<br>
				22918802058777319719839450180888072429661980811197<br>
				77158542502016545090413245809786882778948721859617<br>
				72107838435069186155435662884062257473692284509516<br>
				20849603980134001723930671666823555245252804609722<br>
				53503534226472524250874054075591789781264330331690<br>
</p></div>

<h2>The Catch</h2>
<p>How to store and quickly calculate extremely large numbers.</p>

<h2>The Light</h2>
<p>Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem13
{
  public static void main(String[] args)
  {
    String[] num = 
    {
      ""37107287533902102798797998220837590246510135740250"",
      ""46376937677490009712648124896970078050417018260538"",
      ""74324986199524741059474233309513058123726617309629"",
      ""91942213363574161572522430563301811072406154908250"",
      ""23067588207539346171171980310421047513778063246676"",
      ""89261670696623633820136378418383684178734361726757"",
      ""28112879812849979408065481931592621691275889832738"",
      ""44274228917432520321923589422876796487670272189318"",
      ""47451445736001306439091167216856844588711603153276"",
      ""70386486105843025439939619828917593665686757934951"",
      ""62176457141856560629502157223196586755079324193331"",
      ""64906352462741904929101432445813822663347944758178"",
      ""92575867718337217661963751590579239728245598838407"",
      ""58203565325359399008402633568948830189458628227828"",
      ""80181199384826282014278194139940567587151170094390"",
      ""35398664372827112653829987240784473053190104293586"",
      ""86515506006295864861532075273371959191420517255829"",
      ""71693888707715466499115593487603532921714970056938"",
      ""54370070576826684624621495650076471787294438377604"",
      ""53282654108756828443191190634694037855217779295145"",
      ""36123272525000296071075082563815656710885258350721"",
      ""45876576172410976447339110607218265236877223636045"",
      ""17423706905851860660448207621209813287860733969412"",
      ""81142660418086830619328460811191061556940512689692"",
      ""51934325451728388641918047049293215058642563049483"",
      ""62467221648435076201727918039944693004732956340691"",
      ""15732444386908125794514089057706229429197107928209"",
      ""55037687525678773091862540744969844508330393682126"",
      ""18336384825330154686196124348767681297534375946515"",
      ""80386287592878490201521685554828717201219257766954"",
      ""78182833757993103614740356856449095527097864797581"",
      ""16726320100436897842553539920931837441497806860984"",
      ""48403098129077791799088218795327364475675590848030"",
      ""87086987551392711854517078544161852424320693150332"",
      ""59959406895756536782107074926966537676326235447210"",
      ""69793950679652694742597709739166693763042633987085"",
      ""41052684708299085211399427365734116182760315001271"",
      ""65378607361501080857009149939512557028198746004375"",
      ""35829035317434717326932123578154982629742552737307"",
      ""94953759765105305946966067683156574377167401875275"",
      ""88902802571733229619176668713819931811048770190271"",
      ""25267680276078003013678680992525463401061632866526"",
      ""36270218540497705585629946580636237993140746255962"",
      ""24074486908231174977792365466257246923322810917141"",
      ""91430288197103288597806669760892938638285025333403"",
      ""34413065578016127815921815005561868836468420090470"",
      ""23053081172816430487623791969842487255036638784583"",
      ""11487696932154902810424020138335124462181441773470"",
      ""63783299490636259666498587618221225225512486764533"",
      ""67720186971698544312419572409913959008952310058822"",
      ""95548255300263520781532296796249481641953868218774"",
      ""76085327132285723110424803456124867697064507995236"",
      ""37774242535411291684276865538926205024910326572967"",
      ""23701913275725675285653248258265463092207058596522"",
      ""29798860272258331913126375147341994889534765745501"",
      ""18495701454879288984856827726077713721403798879715"",
      ""38298203783031473527721580348144513491373226651381"",
      ""34829543829199918180278916522431027392251122869539"",
      ""40957953066405232632538044100059654939159879593635"",
      ""29746152185502371307642255121183693803580388584903"",
      ""41698116222072977186158236678424689157993532961922"",
      ""62467957194401269043877107275048102390895523597457"",
      ""23189706772547915061505504953922979530901129967519"",
      ""86188088225875314529584099251203829009407770775672"",
      ""11306739708304724483816533873502340845647058077308"",
      ""82959174767140363198008187129011875491310547126581"",
      ""97623331044818386269515456334926366572897563400500"",
      ""42846280183517070527831839425882145521227251250327"",
      ""55121603546981200581762165212827652751691296897789"",
      ""32238195734329339946437501907836945765883352399886"",
      ""75506164965184775180738168837861091527357929701337"",
      ""62177842752192623401942399639168044983993173312731"",
      ""32924185707147349566916674687634660915035914677504"",
      ""99518671430235219628894890102423325116913619626622"",
      ""73267460800591547471830798392868535206946944540724"",
      ""76841822524674417161514036427982273348055556214818"",
      ""97142617910342598647204516893989422179826088076852"",
      ""87783646182799346313767754307809363333018982642090"",
      ""10848802521674670883215120185883543223812876952786"",
      ""71329612474782464538636993009049310363619763878039"",
      ""62184073572399794223406235393808339651327408011116"",
      ""66627891981488087797941876876144230030984490851411"",
      ""60661826293682836764744779239180335110989069790714"",
      ""85786944089552990653640447425576083659976645795096"",
      ""66024396409905389607120198219976047599490197230297"",
      ""64913982680032973156037120041377903785566085089252"",
      ""16730939319872750275468906903707539413042652315011"",
      ""94809377245048795150954100921645863754710598436791"",
      ""78639167021187492431995700641917969777599028300699"",
      ""15368713711936614952811305876380278410754449733078"",
      ""40789923115535562561142322423255033685442488917353"",
      ""44889911501440648020369068063960672322193204149535"",
      ""41503128880339536053299340368006977710650566631954"",
      ""81234880673210146739058568557934581403627822703280"",
      ""82616570773948327592232845941706525094512325230608"",
      ""22918802058777319719839450180888072429661980811197"",
      ""77158542502016545090413245809786882778948721859617"",
      ""72107838435069186155435662884062257473692284509516"",
      ""20849603980134001723930671666823555245252804609722"",
      ""53503534226472524250874054075591789781264330331690"",
    };
    BigInteger sum = BigInteger.ZERO; 
    for(int i = 0; i &lt; 100; i++)
    {
      sum = sum.add( new BigInteger(num[i]));
    }
    System.out.println(""First 10 digits are "" + sum.toString().substring(0, 10));
  }
}
[/java]
[java]Execution time: 77 ms.[/java]","Problem 13: Large Sum",,"inherit","open","open",,"51-revision-v1",,,"2014-06-07 10:13:25","2014-06-07 10:13:25",,"51","http://euler.lvtran.com/51-revision-v1/","0","revision",,"0"
"53","1","2014-06-07 10:04:28","2014-06-07 10:04:28","<h2>The Problem</h2> 
<p>Work out the first ten digits of the sum of the following one-hundred 50-digit numbers (one number on each line).<!--more-->


<div align=""center""><p>
				37107287533902102798797998220837590246510135740250<br>
				46376937677490009712648124896970078050417018260538<br>
				74324986199524741059474233309513058123726617309629<br>
				91942213363574161572522430563301811072406154908250<br>
				23067588207539346171171980310421047513778063246676<br>
				89261670696623633820136378418383684178734361726757<br>
				28112879812849979408065481931592621691275889832738<br>
				44274228917432520321923589422876796487670272189318<br>
				47451445736001306439091167216856844588711603153276<br>
				70386486105843025439939619828917593665686757934951<br>
				62176457141856560629502157223196586755079324193331<br>
				64906352462741904929101432445813822663347944758178<br>
				92575867718337217661963751590579239728245598838407<br>
				58203565325359399008402633568948830189458628227828<br>
				80181199384826282014278194139940567587151170094390<br>
				35398664372827112653829987240784473053190104293586<br>
				86515506006295864861532075273371959191420517255829<br>
				71693888707715466499115593487603532921714970056938<br>
				54370070576826684624621495650076471787294438377604<br>
				53282654108756828443191190634694037855217779295145<br>
				36123272525000296071075082563815656710885258350721<br>
				45876576172410976447339110607218265236877223636045<br>
				17423706905851860660448207621209813287860733969412<br>
				81142660418086830619328460811191061556940512689692<br>
				51934325451728388641918047049293215058642563049483<br>
				62467221648435076201727918039944693004732956340691<br>
				15732444386908125794514089057706229429197107928209<br>
				55037687525678773091862540744969844508330393682126<br>
				18336384825330154686196124348767681297534375946515<br>
				80386287592878490201521685554828717201219257766954<br>
				78182833757993103614740356856449095527097864797581<br>
				16726320100436897842553539920931837441497806860984<br>
				48403098129077791799088218795327364475675590848030<br>
				87086987551392711854517078544161852424320693150332<br>
				59959406895756536782107074926966537676326235447210<br>
				69793950679652694742597709739166693763042633987085<br>
				41052684708299085211399427365734116182760315001271<br>
				65378607361501080857009149939512557028198746004375<br>
				35829035317434717326932123578154982629742552737307<br>
				94953759765105305946966067683156574377167401875275<br>
				88902802571733229619176668713819931811048770190271<br>
				25267680276078003013678680992525463401061632866526<br>
				36270218540497705585629946580636237993140746255962<br>
				24074486908231174977792365466257246923322810917141<br>
				91430288197103288597806669760892938638285025333403<br>
				34413065578016127815921815005561868836468420090470<br>
				23053081172816430487623791969842487255036638784583<br>
				11487696932154902810424020138335124462181441773470<br>
				63783299490636259666498587618221225225512486764533<br>
				67720186971698544312419572409913959008952310058822<br>
				95548255300263520781532296796249481641953868218774<br>
				76085327132285723110424803456124867697064507995236<br>
				37774242535411291684276865538926205024910326572967<br>
				23701913275725675285653248258265463092207058596522<br>
				29798860272258331913126375147341994889534765745501<br>
				18495701454879288984856827726077713721403798879715<br>
				38298203783031473527721580348144513491373226651381<br>
				34829543829199918180278916522431027392251122869539<br>
				40957953066405232632538044100059654939159879593635<br>
				29746152185502371307642255121183693803580388584903<br>
				41698116222072977186158236678424689157993532961922<br>
				62467957194401269043877107275048102390895523597457<br>
				23189706772547915061505504953922979530901129967519<br>
				86188088225875314529584099251203829009407770775672<br>
				11306739708304724483816533873502340845647058077308<br>
				82959174767140363198008187129011875491310547126581<br>
				97623331044818386269515456334926366572897563400500<br>
				42846280183517070527831839425882145521227251250327<br>
				55121603546981200581762165212827652751691296897789<br>
				32238195734329339946437501907836945765883352399886<br>
				75506164965184775180738168837861091527357929701337<br>
				62177842752192623401942399639168044983993173312731<br>
				32924185707147349566916674687634660915035914677504<br>
				99518671430235219628894890102423325116913619626622<br>
				73267460800591547471830798392868535206946944540724<br>
				76841822524674417161514036427982273348055556214818<br>
				97142617910342598647204516893989422179826088076852<br>
				87783646182799346313767754307809363333018982642090<br>
				10848802521674670883215120185883543223812876952786<br>
				71329612474782464538636993009049310363619763878039<br>
				62184073572399794223406235393808339651327408011116<br>
				66627891981488087797941876876144230030984490851411<br>
				60661826293682836764744779239180335110989069790714<br>
				85786944089552990653640447425576083659976645795096<br>
				66024396409905389607120198219976047599490197230297<br>
				64913982680032973156037120041377903785566085089252<br>
				16730939319872750275468906903707539413042652315011<br>
				94809377245048795150954100921645863754710598436791<br>
				78639167021187492431995700641917969777599028300699<br>
				15368713711936614952811305876380278410754449733078<br>
				40789923115535562561142322423255033685442488917353<br>
				44889911501440648020369068063960672322193204149535<br>
				41503128880339536053299340368006977710650566631954<br>
				81234880673210146739058568557934581403627822703280<br>
				82616570773948327592232845941706525094512325230608<br>
				22918802058777319719839450180888072429661980811197<br>
				77158542502016545090413245809786882778948721859617<br>
				72107838435069186155435662884062257473692284509516<br>
				20849603980134001723930671666823555245252804609722<br>
				53503534226472524250874054075591789781264330331690<br>
</p></div>

<h2>The Catch</h2>
<p>How to store and quickly calculate extremely large numbers.</p>

<h2>The Light</h2>
<p>Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem13
{
  public static void main(String[] args)
  {
    String[] num = 
    {
      ""37107287533902102798797998220837590246510135740250"",
      ""46376937677490009712648124896970078050417018260538"",
      ""74324986199524741059474233309513058123726617309629"",
      ""91942213363574161572522430563301811072406154908250"",
      ""23067588207539346171171980310421047513778063246676"",
      ""89261670696623633820136378418383684178734361726757"",
      ""28112879812849979408065481931592621691275889832738"",
      ""44274228917432520321923589422876796487670272189318"",
      ""47451445736001306439091167216856844588711603153276"",
      ""70386486105843025439939619828917593665686757934951"",
      ""62176457141856560629502157223196586755079324193331"",
      ""64906352462741904929101432445813822663347944758178"",
      ""92575867718337217661963751590579239728245598838407"",
      ""58203565325359399008402633568948830189458628227828"",
      ""80181199384826282014278194139940567587151170094390"",
      ""35398664372827112653829987240784473053190104293586"",
      ""86515506006295864861532075273371959191420517255829"",
      ""71693888707715466499115593487603532921714970056938"",
      ""54370070576826684624621495650076471787294438377604"",
      ""53282654108756828443191190634694037855217779295145"",
      ""36123272525000296071075082563815656710885258350721"",
      ""45876576172410976447339110607218265236877223636045"",
      ""17423706905851860660448207621209813287860733969412"",
      ""81142660418086830619328460811191061556940512689692"",
      ""51934325451728388641918047049293215058642563049483"",
      ""62467221648435076201727918039944693004732956340691"",
      ""15732444386908125794514089057706229429197107928209"",
      ""55037687525678773091862540744969844508330393682126"",
      ""18336384825330154686196124348767681297534375946515"",
      ""80386287592878490201521685554828717201219257766954"",
      ""78182833757993103614740356856449095527097864797581"",
      ""16726320100436897842553539920931837441497806860984"",
      ""48403098129077791799088218795327364475675590848030"",
      ""87086987551392711854517078544161852424320693150332"",
      ""59959406895756536782107074926966537676326235447210"",
      ""69793950679652694742597709739166693763042633987085"",
      ""41052684708299085211399427365734116182760315001271"",
      ""65378607361501080857009149939512557028198746004375"",
      ""35829035317434717326932123578154982629742552737307"",
      ""94953759765105305946966067683156574377167401875275"",
      ""88902802571733229619176668713819931811048770190271"",
      ""25267680276078003013678680992525463401061632866526"",
      ""36270218540497705585629946580636237993140746255962"",
      ""24074486908231174977792365466257246923322810917141"",
      ""91430288197103288597806669760892938638285025333403"",
      ""34413065578016127815921815005561868836468420090470"",
      ""23053081172816430487623791969842487255036638784583"",
      ""11487696932154902810424020138335124462181441773470"",
      ""63783299490636259666498587618221225225512486764533"",
      ""67720186971698544312419572409913959008952310058822"",
      ""95548255300263520781532296796249481641953868218774"",
      ""76085327132285723110424803456124867697064507995236"",
      ""37774242535411291684276865538926205024910326572967"",
      ""23701913275725675285653248258265463092207058596522"",
      ""29798860272258331913126375147341994889534765745501"",
      ""18495701454879288984856827726077713721403798879715"",
      ""38298203783031473527721580348144513491373226651381"",
      ""34829543829199918180278916522431027392251122869539"",
      ""40957953066405232632538044100059654939159879593635"",
      ""29746152185502371307642255121183693803580388584903"",
      ""41698116222072977186158236678424689157993532961922"",
      ""62467957194401269043877107275048102390895523597457"",
      ""23189706772547915061505504953922979530901129967519"",
      ""86188088225875314529584099251203829009407770775672"",
      ""11306739708304724483816533873502340845647058077308"",
      ""82959174767140363198008187129011875491310547126581"",
      ""97623331044818386269515456334926366572897563400500"",
      ""42846280183517070527831839425882145521227251250327"",
      ""55121603546981200581762165212827652751691296897789"",
      ""32238195734329339946437501907836945765883352399886"",
      ""75506164965184775180738168837861091527357929701337"",
      ""62177842752192623401942399639168044983993173312731"",
      ""32924185707147349566916674687634660915035914677504"",
      ""99518671430235219628894890102423325116913619626622"",
      ""73267460800591547471830798392868535206946944540724"",
      ""76841822524674417161514036427982273348055556214818"",
      ""97142617910342598647204516893989422179826088076852"",
      ""87783646182799346313767754307809363333018982642090"",
      ""10848802521674670883215120185883543223812876952786"",
      ""71329612474782464538636993009049310363619763878039"",
      ""62184073572399794223406235393808339651327408011116"",
      ""66627891981488087797941876876144230030984490851411"",
      ""60661826293682836764744779239180335110989069790714"",
      ""85786944089552990653640447425576083659976645795096"",
      ""66024396409905389607120198219976047599490197230297"",
      ""64913982680032973156037120041377903785566085089252"",
      ""16730939319872750275468906903707539413042652315011"",
      ""94809377245048795150954100921645863754710598436791"",
      ""78639167021187492431995700641917969777599028300699"",
      ""15368713711936614952811305876380278410754449733078"",
      ""40789923115535562561142322423255033685442488917353"",
      ""44889911501440648020369068063960672322193204149535"",
      ""41503128880339536053299340368006977710650566631954"",
      ""81234880673210146739058568557934581403627822703280"",
      ""82616570773948327592232845941706525094512325230608"",
      ""22918802058777319719839450180888072429661980811197"",
      ""77158542502016545090413245809786882778948721859617"",
      ""72107838435069186155435662884062257473692284509516"",
      ""20849603980134001723930671666823555245252804609722"",
      ""53503534226472524250874054075591789781264330331690"",
    };
    BigInteger sum = BigInteger.ZERO; 
    for(int i = 0; i &lt; 100; i++)
    {
      sum = sum.add( new BigInteger(num[i]));
    }
    System.out.println(""First 10 digits are "" + sum.toString().substring(0, 10));
  }
}
[/java]
[java]Execution time: 77 ms.[/java]","Problem 13: Large Sum",,"inherit","open","open",,"51-revision-v1",,,"2014-06-07 10:04:28","2014-06-07 10:04:28",,"51","http://euler.lvtran.com/51-revision-v1/","0","revision",,"0"
"55","1","2014-06-07 10:09:39","2014-06-07 10:09:39","<p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6<sup>th</sup> prime is 13. What is the 10,001<sup>st</sup> prime number?</p><!--more-->



<h2>The Catch</h2>
<p>How to determine whether an arbitrary number <strong>x</strong> is prime.</p>

<h2>The Light</h2>
<p>Reuse the prime checking code in <a href=""http://lvtran.com/p3"">Problem 3</a> to find the 10,100st prime number.</p>

<h2>The Code</h2>
[java]
public class Problem7
{
  public static void main(String[] args)
  {
    int count = 1; //Start count at 1 because 2 is the first prime number

    for(int i = 3;; i += 2) //Increment by 2 because primes from 3 onward are odd
    {
      if(isPrime(i))
        ++count;
      if(count == 10001)
      {
        System.out.println(i);
        break;
      }
    }
  }

  public static boolean isPrime(int n)
  {
    if(n &lt; 2)
      return false;

    if(n != 2 &amp;&amp; n % 2 == 0)
      return false;

    for(int i = 3; i*i &lt;= n; i += 2)
    {
      if(n % i == 0)
        return false;
    } 
    return true;
  }
}
[/java]
[java]Execution time: 8 ms.[/java]","Problem 7: 10,001<sup>st</sup> Prime",,"inherit","open","open",,"39-revision-v1",,,"2014-06-07 10:09:39","2014-06-07 10:09:39",,"39","http://euler.lvtran.com/39-revision-v1/","0","revision",,"0"
"59","1","2014-06-07 10:12:42","2014-06-07 10:12:42","<p>In the 20 x 20 grid below, four numbers along a diagonal line have been marked in red. The product of these numbers is 26 * 63 * 78 * 14 = 1788696. What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20 x 20 grid?</p>
<!--more-->


<p style=""text-align: center;"">08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br>
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br>
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br>
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br>
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br>
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br>
32 98 81 28 64 23 67 10 <span style=""color: #ff0000;""><b>26</b></span> 38 40 67 59 54 70 66 18 38 64 70<br>
67 26 20 68 02 62 12 20 95 <span style=""color: #ff0000;""><b>63</b></span> 94 39 63 08 40 91 66 49 94 21<br>
24 55 58 05 66 73 99 26 97 17 <span style=""color: #ff0000;""><b>78</b></span> 78 96 83 14 88 34 89 63 72<br>
21 36 23 09 75 00 76 44 20 45 35 <span style=""color: #ff0000;""><b>14</b></span> 00 61 33 97 34 31 33 95<br>
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br>
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br>
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br>
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br>
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br>
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br>
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br>
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br>
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br>
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48<br></p>
<br>

<h2>The Catch</h2>
<p>This problem is fairly straightforward; there is no other way but to check all routes of the 20 x 20 grid.</p>

<h2>The Light</h2>
<p>Checking columns and rows are simple: just loop through each row and column and find the product of every 4 entries. Checking 2 left	and right diagonals require more check points to prevent out of bound exception.</p>

<h2>The Code</h2>
[java]
public class Problem11
{
  public static void main( String[] args )
  {
    int[][] a = new int[20][20];
    int[] a1d = { 8, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91,  8,
                 49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00,
                 81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65,
                 52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91,
                 22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80,
                 24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50,
                 32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70,
                 67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63,  8, 40, 91, 66, 49, 94, 21,
                 24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72,
                 21, 36, 23,  9, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95,
                 78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14,  9, 53, 56, 92,
                 16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57,
                 86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58,
                 19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40,
                 04, 52,  8, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66,
                 88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69,
                 04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18,  8, 46, 29, 32, 40, 62, 76, 36,
                 20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16,
                 20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54,
                 01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48,};
    int index = 0;
    int max = 0;
    int product = 0;

    for(int x = 0; x &lt; a.length; x++)
    {
      for(int y = 0; y &lt; a.length; y++)
      {
        a[x][y] = a1d[index++];
      }
    }

    //Check columns
    int x3 = 0;
    for(int y = 0; y &lt; a.length; y++)
    {
      while(x3 &lt; a.length - 3)       
      {         
        product = a[x3][y] *                    
                  a[x3 + 1][y] *
                  a[x3 + 2][y] *                    
                  a[x3 + 3][y];
        if(product &gt; max)
          max = product;

        ++x3;
      }
      x3 = 0;
    }

    //Check rows
    int y4 = 0;
    for( int x = 0; x &lt; a.length; x++)
    {
      while(y4 &lt; a.length - 3)       
      {         
        product = a[x][y4] *                    
                  a[x][y4 + 1] *                    
                  a[x][y4 + 2] *                    
                  a[x][y4 + 3];          
    
        if(product &gt; max)
          max = product;

        ++y4;
      }
      y4 = 0;
    }

    //Check left diagonal below
    int x = 1;
    int tmp = 1;
    while(x &lt; a.length - 3)
    {
      for(int y = 0; y &lt; a.length - 3 - tmp; y++)       
      {         
        product = a[x][y] *                    
                  a[x + 1][y + 1] *                    
                  a[x + 1][y + 2] *                    
                  a[x + 1][y + 3];               

        if(product &gt; max)
          max = product;

        ++x;
      }
      x = ++tmp;
    }

    //Chek left diagonal above
    int x2 = 1;
    int tmp2 = 1;
    while(x2 &lt; a.length - 3)
    {
      for(int y = 0; y &lt; a.length - 3 - tmp2; y++)       
      {         
        product = a[y][x2] *                    
                  a[y + 1][x2 + 1] *                    
                  a[y + 2][x2 + 2] *                    
                  a[y + 3][x2 + 3];          

        if(product &gt; max)
          max = product;

        ++x2;
      }
      x2 = ++tmp2;
    }

    //Check left diagonal middle line
    for(int i = 0; i &lt; a.length - 3; i++)     
    {       
      product = a[i][i] *                  
                a[i + 1][i + 1] *                  
                a[i + 2][i + 2] *                  
                a[i + 3][i + 3];        

      if(product &gt; max)
        max = product;
    }

    //Check right diagonal above and diagonal middle line
    int x5 = 3;
    int tmp5 = 3;
    int count = 16;
    while(x5 &lt; a.length)
    {
      for(int y = 0; y &lt; a.length - 3 - count; y++)       
      {         
        product = a[x5][y] *                    
                  a[x5 - 1][y + 1] *                    
                  a[x5 - 2][y + 2] *                    
                  a[x5 - 3][y + 3];          
 
        if(product &gt; max)
          max = product;

        x5--;
      }
      count--;
      x5 = ++tmp5;
    }

    //Check right diagonal below
    int y6 = 1;
    int tmp6 = 1;
    while(y6 &lt; a.length - 3)     
    {       
      for(x = a.length - 1; x &gt; 3 &amp;&amp; y6 &lt; a.length - 3; x--)       
      {         
        product = a[x][y6] *                    
                  a[x - 1][y6 + 1] *                    
                  a[x - 2][y6 + 2] *                    
                  a[x - 3][y6 + 3];          

        if(product &gt; max)
          max = product;

        y6++;
      }
      y6 = ++tmp6;	  
    }
    System.out.println(max);
  }
}
[/java]
[java]Execution time: 1 ms.[/java]","Problem 11: Largest Product in a Grid",,"inherit","open","open",,"47-autosave-v1",,,"2014-06-07 10:12:42","2014-06-07 10:12:42",,"47","http://euler.lvtran.com/47-autosave-v1/","0","revision",,"0"
"63","1","2014-06-07 10:16:25","2014-06-07 10:16:25","<p>A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, a<sup>2<sup> + b<sup>2</sup> = c<sup>2</sup>. For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>. There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product <i>abc</i>.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to generate Pythagorean triplets.</p>

<h2>The Light</h2>
<p>Utilize the <a href=""http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple"" target=""_blank"">Euclid's Formula</a> to create Pythagorean triplets: Given an arbitrary pair of positive integers m and n with m &gt; n</var>, the formula states that:
&nbsp;&nbsp;&nbsp;&nbsp;a = m<sup>2</sup> - n<sup>2</sup>
&nbsp;&nbsp;&nbsp;&nbsp;b = 2 * m * n
&nbsp;&nbsp;&nbsp;&nbsp;c = m<sup>2</sup> + n<sup>2</sup>
Check when their sum equals 1,000 and find their product.</p>

<h2>The Code</h2>
[java]
public class Problem9
{
  public static void main(String[] args)
  {
    for(int m = 2;; m++) 
    {
      for(int n = 1; n &lt; m; n++)
      {
        int a = m * m - n * n;
        int b = 2 * m * n;
        int c = m * m + n * n;

        int sum = a + b + c;
        if( sum == 1000 )
        {
          System.out.println(""a = "" + a);
          System.out.println(""b = "" + b);
          System.out.println(""c = "" + c);
          System.out.println(a * b * c );
          return;
        }
      }
    }
  }
}
[/java]
[java]Execution time: 2 ms.[/java]","Problem 9: Special Pythagorean Triplet",,"inherit","open","open",,"43-revision-v1",,,"2014-06-07 10:16:25","2014-06-07 10:16:25",,"43","http://euler.lvtran.com/43-revision-v1/","0","revision",,"0"
"64","1","2014-06-07 10:16:54","2014-06-07 10:16:54","<p>A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>. For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>. There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product <i>abc</i>.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to generate Pythagorean triplets.</p>

<h2>The Light</h2>
<p>Utilize the <a href=""http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple"" target=""_blank"">Euclid's Formula</a> to create Pythagorean triplets: Given an arbitrary pair of positive integers m and n with m &gt; n</var>, the formula states that:
&nbsp;&nbsp;&nbsp;&nbsp;a = m<sup>2</sup> - n<sup>2</sup>
&nbsp;&nbsp;&nbsp;&nbsp;b = 2 * m * n
&nbsp;&nbsp;&nbsp;&nbsp;c = m<sup>2</sup> + n<sup>2</sup>
Check when their sum equals 1,000 and find their product.</p>

<h2>The Code</h2>
[java]
public class Problem9
{
  public static void main(String[] args)
  {
    for(int m = 2;; m++) 
    {
      for(int n = 1; n &lt; m; n++)
      {
        int a = m * m - n * n;
        int b = 2 * m * n;
        int c = m * m + n * n;

        int sum = a + b + c;
        if( sum == 1000 )
        {
          System.out.println(""a = "" + a);
          System.out.println(""b = "" + b);
          System.out.println(""c = "" + c);
          System.out.println(a * b * c );
          return;
        }
      }
    }
  }
}
[/java]
[java]Execution time: 2 ms.[/java]","Problem 9: Special Pythagorean Triplet",,"inherit","open","open",,"43-revision-v1",,,"2014-06-07 10:16:54","2014-06-07 10:16:54",,"43","http://euler.lvtran.com/43-revision-v1/","0","revision",,"0"
"65","1","2014-06-07 10:17:37","2014-06-07 10:17:37","<p>A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, a^2 + b<sup>2</sup> = c<sup>2</sup>. For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>. There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product <i>abc</i>.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to generate Pythagorean triplets.</p>

<h2>The Light</h2>
<p>Utilize the <a href=""http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple"" target=""_blank"">Euclid's Formula</a> to create Pythagorean triplets: Given an arbitrary pair of positive integers m and n with m &gt; n</var>, the formula states that:
&nbsp;&nbsp;&nbsp;&nbsp;a = m<sup>2</sup> - n<sup>2</sup>
&nbsp;&nbsp;&nbsp;&nbsp;b = 2 * m * n
&nbsp;&nbsp;&nbsp;&nbsp;c = m<sup>2</sup> + n<sup>2</sup>
Check when their sum equals 1,000 and find their product.</p>

<h2>The Code</h2>
[java]
public class Problem9
{
  public static void main(String[] args)
  {
    for(int m = 2;; m++) 
    {
      for(int n = 1; n &lt; m; n++)
      {
        int a = m * m - n * n;
        int b = 2 * m * n;
        int c = m * m + n * n;

        int sum = a + b + c;
        if( sum == 1000 )
        {
          System.out.println(""a = "" + a);
          System.out.println(""b = "" + b);
          System.out.println(""c = "" + c);
          System.out.println(a * b * c );
          return;
        }
      }
    }
  }
}
[/java]
[java]Execution time: 2 ms.[/java]","Problem 9: Special Pythagorean Triplet",,"inherit","open","open",,"43-revision-v1",,,"2014-06-07 10:17:37","2014-06-07 10:17:37",,"43","http://euler.lvtran.com/43-revision-v1/","0","revision",,"0"
"66","1","2014-06-07 10:18:42","2014-06-07 10:18:42","<p>A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, a^2 + b^2 = c^2\, a^2 + b<sup>2</sup> = c<sup>2</sup>. For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>. There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product <i>abc</i>.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to generate Pythagorean triplets.</p>

<h2>The Light</h2>
<p>Utilize the <a href=""http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple"" target=""_blank"">Euclid's Formula</a> to create Pythagorean triplets: Given an arbitrary pair of positive integers m and n with m &gt; n</var>, the formula states that:
&nbsp;&nbsp;&nbsp;&nbsp;a = m<sup>2</sup> - n<sup>2</sup>
&nbsp;&nbsp;&nbsp;&nbsp;b = 2 * m * n
&nbsp;&nbsp;&nbsp;&nbsp;c = m<sup>2</sup> + n<sup>2</sup>
Check when their sum equals 1,000 and find their product.</p>

<h2>The Code</h2>
[java]
public class Problem9
{
  public static void main(String[] args)
  {
    for(int m = 2;; m++) 
    {
      for(int n = 1; n &lt; m; n++)
      {
        int a = m * m - n * n;
        int b = 2 * m * n;
        int c = m * m + n * n;

        int sum = a + b + c;
        if( sum == 1000 )
        {
          System.out.println(""a = "" + a);
          System.out.println(""b = "" + b);
          System.out.println(""c = "" + c);
          System.out.println(a * b * c );
          return;
        }
      }
    }
  }
}
[/java]
[java]Execution time: 2 ms.[/java]","Problem 9: Special Pythagorean Triplet",,"inherit","open","open",,"43-autosave-v1",,,"2014-06-07 10:18:42","2014-06-07 10:18:42",,"43","http://euler.lvtran.com/43-autosave-v1/","0","revision",,"0"
"68","1","2013-12-17 10:21:06","2013-12-17 10:21:06","<p>The following iterative sequence is defined for the set of positive integers:
<div align=""center""><p><var>n</var> &rarr; <var>n</var>/2 (<var>n</var> is even)
<var>n</var> &rarr; 3<var>n</var> + 1 (<var>n</var> is odd)</div>
<p>Using the rule above and starting with 13, we generate the following sequence:
<div align=""center""><p>13 &rarr; 40 &rarr; 20 &rarr; 10 &rarr; 5 &rarr; 16 &rarr; 8 &rarr; 4 &rarr; 2 &rarr; 1	</div>
<p>It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (<a href=""http://mathworld.wolfram.com/CollatzProblem.html"" target=""_blank"">Collatz Problem</a>), it is thought that all starting numbers finish at 1. Which starting number, under one million, produces the longest chain?<!--more-->


<b>NOTE:</b> Once the chain starts the terms are allowed to go above one million.</p>

<h2>The Catch</h2>
<p>How to minimize the amount of calculation for larger numbers; applying the chain-length-finding rule above to large numbers can take a very long time, not to mention there are 999,999 numbers to check.</p>

<h2>The Light</h2>
<p>Use the idea of caching: store the chain length of each starting number into an array so that the next time that starting number is needed, no extra calculations are required. 
<br>Example:
4 &rarr; 2 &rarr; 1 
Starting number 4 has a chain length of 3; store 3 into an array.
5 &rarr; 16 &rarr; 8 &rarr; <span style=""color: #ff0000;"">4</span>&rarr; 2 &rarr; 1 
Starting number 5 becomes 16, then 8, then 4, whose chain length is known and stored in the array. Thus, stop calculating at 4 to see that starting number 5 has a chain length of 1 + 1 + 1 + 3 = 6. Notice that the calculation sequence 4 &rarr; 2 &rarr; 1 is not repeated.
<br>Simply loop from n = 0 to n = 999,999 and store each n's chain length into an array. Whenever n value gets less than what it started with, stop and use the cached chain length.</p>

<h2>The Code</h2>
[java]
public class Problem14
{
  public static void main(String[] args)
  {
    int[] cachedChain = new int[1000000];
    int index = 0;
    int maxChain = 0;
    int chain = 1;
    long startNum = 0;
    long n = 0;
	
    for(int i = 1; i <= 1000000; i++)
    {
      n = i;
      while(n != 1)
      {
        if(n % 2 == 0)
          if(n < i)
          {
            chain += cachedChain[(int)n - 1];
            break;
          }
          else
          {
            n = (n / 2);
            ++chain;
          }
        else
          if( n < i )
          {
            chain += cachedChain[(int)n - 1];
            break;
          }
          else
          {
            n = (3 * n) + 1;
            chain++;
          }
      }
      cachedChain[i - 1] = chain;
      if( chain > maxChain )
      {
        maxChain = chain;
        startNum = i;
      }
      chain = 0;
    }
    System.out.println(startNum + "" has chain of "" + maxChain);
  }
}
[/java]
[java]Execution time: 246 ms.[/java]
","Problem 14: Longest Collatz Sequence",,"publish","closed","closed",,"p17",,,"2014-06-15 07:08:43","2014-06-15 07:08:43",,"0","http://euler.lvtran.com/?p=68","0","post",,"0"
"69","1","2014-06-07 10:21:06","2014-06-07 10:21:06","<p>The following iterative sequence is defined for the set of positive integers:
<div align=""center""><p><var>n</var> &rarr; <var>n</var>/2 (<var>n</var> is even)
<var>n</var> &rarr; 3<var>n</var> + 1 (<var>n</var> is odd)</div>
<p>Using the rule above and starting with 13, we generate the following sequence:
<div align=""center""><p>13 &rarr; 40 &rarr; 20 &rarr; 10 &rarr; 5 &rarr; 16 &rarr; 8 &rarr; 4 &rarr; 2 &rarr; 1	</div>
<p>It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (<a href=""http://mathworld.wolfram.com/CollatzProblem.html"" target=""_blank"">Collatz Problem</a>), it is thought that all starting numbers finish at 1. Which starting number, under one million, produces the longest chain?<!--more-->


<b>NOTE:</b> Once the chain starts the terms are allowed to go above one million.</p>

<h2>The Catch</h2>
<p>How to minimize the amount of calculation for larger numbers; applying the chain-length-finding rule above to large numbers can take a very long time, not to mention there are 999,999 numbers to check.</p>

<h2>The Light</h2>
<p>Use the idea of caching: store the chain length of each starting number into an array so that the next time that starting number is needed, no extra calculations are required. 
<br>Example:
4 &rarr; 2 &rarr; 1 
Starting number 4 has a chain length of 3; store 3 into an array.
5 &rarr; 16 &rarr; 8 &rarr; <span style=""color: #ff0000;"">4</span>&rarr; 2 &rarr; 1 
Starting number 5 becomes 16, then 8, then 4, whose chain length is known and stored in the array. Thus, stop calculating at 4 to see that starting number 5 has a chain length of 1 + 1 + 1 + 3 = 6. Notice that the calculation sequence 4 &rarr; 2 &rarr; 1 is not repeated.
<br>Simply loop from n = 0 to n = 999,999 and store each n's chain length into an array. Whenever n value gets less than what it started with, stop and use the cached chain length.</p>

<h2>The Code</h2>
[java]
public class Problem14
{
  public static void main(String[] args)
  {
    int[] cachedChain = new int[1000000];
    int index = 0;
    int maxChain = 0;
    int chain = 1;
    long startNum = 0;
    long n = 0;
	
    for(int i = 1; i <= 1000000; i++)
    {
      n = i;
      while(n != 1)
      {
        if(n % 2 == 0)
          if(n < i)
          {
            chain += cachedChain[(int)n - 1];
            break;
          }
          else
          {
            n = (n / 2);
            ++chain;
          }
        else
          if( n < i )
          {
            chain += cachedChain[(int)n - 1];
            break;
          }
          else
          {
            n = (3 * n) + 1;
            chain++;
          }
      }
      cachedChain[i - 1] = chain;
      if( chain > maxChain )
      {
        maxChain = chain;
        startNum = i;
      }
      chain = 0;
    }
    System.out.println(startNum + "" has chain of "" + maxChain);
  }
}
[/java]
[java]Execution time: 246 ms.[/java]
","Problem 14: Longest Collatz Sequence",,"inherit","open","open",,"68-revision-v1",,,"2014-06-07 10:21:06","2014-06-07 10:21:06",,"68","http://euler.lvtran.com/68-revision-v1/","0","revision",,"0"
"70","1","2013-12-15 10:21:34","2013-12-15 10:21:34","<p>Starting in the top left corner of a 2 x 2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner. How many such routes are there through a 20 x 20 grid?
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15.png"" alt=""15"" width=""227"" height=""161"" class=""aligncenter size-full wp-image-231"" />
<!--more-->


<h2>The Catch</h2>
<p>Discover the pattern of lattice paths.</p><br><br>

<h2>The Light</h2>
<p>Take a look at a smaller version of this problem:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15a.png"" alt=""15a"" width=""218"" height=""213"" class=""aligncenter size-full wp-image-232"" />
<p>If you start from the green point, there is only one way (marked as 1 next to the green point) to get to the destination D. Similarly, if you start from the blue point, there is also only one 			way to get to the destination. Now, let's move the positions of the green and blue points:</p>
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15b.png"" alt=""15b"" width=""206"" height=""188"" class=""aligncenter size-full wp-image-233"" />
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15c.png"" alt=""15c"" width=""212"" height=""192"" class=""aligncenter size-full wp-image-234"" />
<p>It can be seen that no matter where you start on the <strong>bottom and right edge</strong>, there is only one way to reach the destination. Now, observe the following square. If you start from the yellow point, there are 2 ways to reach the destination.</p>
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15d.png"" alt=""15d"" width=""195"" height=""206"" class=""aligncenter size-full wp-image-235"" />
<p>Similarly in the square below, if you start from the purple or gray point, there are 3 ways to reach the destination. If you start from the orange point, there will be 6 ways. Notice that this is the 	2 x 2 square mentioned in the problem's example.
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15e.png"" alt=""15e"" width=""188"" height=""189"" class=""aligncenter size-full wp-image-236"" />
<p>The number of lattice paths from any point can be computed by adding the number of lattice paths from the point immediately to the right and below it. For instance, the number of lattice paths of the yellow point can be computed by adding the number of lattice paths of the green point immediately to the right and the blue point immediately below, so we have 1 + 1 = 2. Similarly, the number of lattice paths of the gray point can be computed by adding the number of lattice paths of the yellow point immediately to the right and the number of lattice paths of the blue point immediately below, so we have 2 + 1 = 3. The same method is used to compute 6, the number of lattice paths of the orange point, which is the top left corner point of a 2 x 2 square.</p>
<p>Apply this pattern for a 20 x 20 square. Use type <b>long</b> to store your answer as the combinatorial value will get very large.</p>

<h2>The Code</h2>
[java]
public class Problem15
{
  public static void main(String[] args)
  {
    int gridsize = 20;
    long[][] grid = new long[gridsize + 1][gridsize + 1];
    for( int x = 0; x &lt; gridsize + 1; x++ )
    {
      for( int y = 0; y &lt; gridsize + 1; y++ )       
      {
        grid[gridsize][y] = 1;     	
        grid[x][gridsize] = 1;       
      }
    }

    for( int x = gridsize - 1; x &gt;= 0; x-- )
    {
      for( int y = gridsize  - 1; y &gt;= 0; y-- )
      {
        grid[x][y] = grid[x + 1][ y] + grid[x][ y + 1];
      }
    }

    System.out.println(""Top left grid = "" + grid[0][0]);
  }
}
[/java]
[java]Execution time: 0 ms.[/java]","Problem 19: Counting Sundays",,"publish","closed","closed",,"p15",,,"2014-06-15 07:08:44","2014-06-15 07:08:44",,"0","http://euler.lvtran.com/?p=70","0","post",,"0"
"71","1","2014-06-07 10:21:34","2014-06-07 10:21:34","<p>Starting in the top left corner of a 2 x 2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner. How many such routes are there through a 20 x 20 grid?
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15.png"" alt=""15"" width=""227"" height=""161"" class=""aligncenter size-full wp-image-231"" />
<!--more-->


<h2>The Catch</h2>
<p>Discover the pattern of lattice paths.</p><br><br>

<h2>The Light</h2>
<p>Take a look at a smaller version of this problem:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15a.png"" alt=""15a"" width=""218"" height=""213"" class=""aligncenter size-full wp-image-232"" />
<p>If you start from the green point, there is only one way (marked as 1 next to the green point) to get to the destination D. Similarly, if you start from the blue point, there is also only one 			way to get to the destination. Now, let's move the positions of the green and blue points:</p>
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15b.png"" alt=""15b"" width=""206"" height=""188"" class=""aligncenter size-full wp-image-233"" />
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15c.png"" alt=""15c"" width=""212"" height=""192"" class=""aligncenter size-full wp-image-234"" />
<p>It can be seen that no matter where you start on the <strong>bottom and right edge</strong>, there is only one way to reach the destination. Now, observe the following square. If you start from the yellow point, there are 2 ways to reach the destination.</p>
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15d.png"" alt=""15d"" width=""195"" height=""206"" class=""aligncenter size-full wp-image-235"" />
<p>Similarly in the square below, if you start from the purple or gray point, there are 3 ways to reach the destination. If you start from the orange point, there will be 6 ways. Notice that this is the 	2 x 2 square mentioned in the problem's example.
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/15e.png"" alt=""15e"" width=""188"" height=""189"" class=""aligncenter size-full wp-image-236"" />
<p>The number of lattice paths from any point can be computed by adding the number of lattice paths from the point immediately to the right and below it. For instance, the number of lattice paths of the yellow point can be computed by adding the number of lattice paths of the green point immediately to the right and the blue point immediately below, so we have 1 + 1 = 2. Similarly, the number of lattice paths of the gray point can be computed by adding the number of lattice paths of the yellow point immediately to the right and the number of lattice paths of the blue point immediately below, so we have 2 + 1 = 3. The same method is used to compute 6, the number of lattice paths of the orange point, which is the top left corner point of a 2 x 2 square.</p>
<p>Apply this pattern for a 20 x 20 square. Use type <b>long</b> to store your answer as the combinatorial value will get very large.</p>

<h2>The Code</h2>
[java]
public class Problem15
{
  public static void main(String[] args)
  {
    int gridsize = 20;
    long[][] grid = new long[gridsize + 1][gridsize + 1];
    for( int x = 0; x &lt; gridsize + 1; x++ )
    {
      for( int y = 0; y &lt; gridsize + 1; y++ )       
      {
        grid[gridsize][y] = 1;     	
        grid[x][gridsize] = 1;       
      }
    }

    for( int x = gridsize - 1; x &gt;= 0; x-- )
    {
      for( int y = gridsize  - 1; y &gt;= 0; y-- )
      {
        grid[x][y] = grid[x + 1][ y] + grid[x][ y + 1];
      }
    }

    System.out.println(""Top left grid = "" + grid[0][0]);
  }
}
[/java]
[java]Execution time: 0 ms.[/java]","Problem 15: Lattice Paths",,"inherit","open","open",,"70-revision-v1",,,"2014-06-07 10:21:34","2014-06-07 10:21:34",,"70","http://euler.lvtran.com/70-revision-v1/","0","revision",,"0"
"72","1","2013-12-12 10:21:58","2013-12-12 10:21:58","<p>2<sup>15</sup> = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26. What is the sum of the digits of the number 2<sup>1000</sup>?</p>
<!--more-->


<h2>The Catch</h2>
<p>How to store and quickly calculate extremely large numbers.</p>

<h2>The Light</h2>
<p>Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class as discussed in <a href=""http://lvtran.com/p13"">Problem 13</a>. Then parse the result into an array of digit-character to calculate their sum.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem16
{
  public static void main(String[] args)
  {
    BigInteger n = new BigInteger(""2"");
    n = n.pow(1000);
    System.out.println(""2^1000 = "" + n);

    String s = n.toString();
    int sum = 0;
    for(int i = 0; i &lt; s.length(); i++)
    {
      sum += Character.getNumericValue(s.charAt(i));  
    }
    System.out.println(""Sum of all digits = "" + sum);
 }
}
[/java]
[java]Execution time: 51 ms.[/java]","Problem 16: Power Digit Sum",,"publish","closed","closed",,"p16",,,"2014-06-15 07:08:44","2014-06-15 07:08:44",,"0","http://euler.lvtran.com/?p=72","0","post",,"0"
"73","1","2014-06-07 10:21:58","2014-06-07 10:21:58","<p>2<sup>15</sup> = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26. What is the sum of the digits of the number 2<sup>1000</sup>?</p>

<h2>The Catch</h2>
<p>How to store and quickly calculate extremely large numbers.</p>

<h2>The Light</h2>
<p>Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class as discussed in <a href=""http://lvtran.com/p13"">Problem 13</a>. Then parse the result into an array of digit-character to calculate their sum.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem16
{
  public static void main(String[] args)
  {
    BigInteger n = new BigInteger(""2"");
    n = n.pow(1000);
    System.out.println(""2^1000 = "" + n);

    String s = n.toString();
    int sum = 0;
    for(int i = 0; i &lt; s.length(); i++)
    {
      sum += Character.getNumericValue(s.charAt(i));  
    }
    System.out.println(""Sum of all digits = "" + sum);
 }
}
[/java]
[java]Execution time: 51 ms.[/java]","Problem 16: Power Digit Sum",,"inherit","open","open",,"72-revision-v1",,,"2014-06-07 10:21:58","2014-06-07 10:21:58",,"72","http://euler.lvtran.com/72-revision-v1/","0","revision",,"0"
"74","1","2013-12-11 10:22:24","2013-12-11 10:22:24","<p>If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total. If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?<!--more-->


<br><b>NOTE:</b> Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of ""and"" when writing out numbers is in compliance with British usage.</p>

<h2>The Catch</h2>
<p>How to efficiently calculate the number of letters of 1,000 numbers when they are spelled out.</p>

<h2>The Light</h2>
<p>The number Divide 1,000 numbers into groups based on the similarity of their spellings:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; 1 - 20
&nbsp;&nbsp;&nbsp;&nbsp;&diams; 21 - 99
&nbsp;&nbsp;&nbsp;&nbsp;&diams; 100 - 999
Reuse the result of previous groups on the latter groups. For example, 128 (one hundred twenty eight) can use 1 (one) from the first group and 28 (twenty eight) from the second group.</p>

<h2>The Code</h2>
[java]
public class Problem17
{
  public static void main(String[] args)
  {
    String[] arr1 = new String[99];
    int arr1Index = 0;

    String[] singleD = {""one"", ""two"", ""three"", ""four"", ""five"", 
                        ""six"", ""seven"", ""eight"", ""nine""};

    String ten = ""ten"";
    String eleven = ""eleven"";
    String twelve = ""twelve"";
    String thirteen = ""thirteen"";
    String fifteen = ""fifteen"";
    String eighteen = ""eighteen"";
    String teen = ""teen"";

    String ty = ""ty"";
    String twenty = ""twenty"";
    String thirty = ""thirty"";
    String forty = ""forty"";
    String fifty = ""fifty"";
    String eighty = ""eighty"";
    String[] tens = new String[8];
    for(int j = 0; j &lt; tens.length; j++)
    {
      if(j == 0) 
      {
        tens[j] = twenty;
        continue;
      }
      if(j == 1)
      {
        tens[j] = thirty;
        continue;
      }
      if(j == 2)
      {
        tens[j] = forty;
        continue;
      }
      if(j == 3)
      {
        tens[j] = fifty;
        continue;
      }
      if(j == 6)
      {
        tens[j] = eighty;
        continue;
      }
      tens[j] = singleD[ j + 1] + ty;
    }

    String and = ""and"";
    String hundred = ""hundred"";

    //PRINT OUT THE NUMBERS 1- 20
    for(int i = 1; i &lt;= 20; i++)
    { 
      if(i &lt; 10)
        arr1[arr1Index++] = singleD[i - 1];

      if(i &gt;= 10 &amp;&amp; i &lt;= 20)
        switch(i)
        {
          case 10: arr1[arr1Index++] = ten;
                   break;
          case 11: arr1[arr1Index++] = eleven;
                   break;
          case 12: arr1[arr1Index++] = twelve;
                   break;
          case 13: arr1[arr1Index++] = thirteen;
                   break;
          case 15: arr1[arr1Index++] = fifteen;
                   break;
          case 18: arr1[arr1Index++] = eighteen;
                   break;
          case 20: arr1[arr1Index++] = twenty;
                   break;
          default: arr1[arr1Index++] = (singleD[i - 10 - 1] + teen);
                   break;
        }		
    }

    //PRINT OUT NUMBER 21 - 99
    for(int x = 21, index = 0, sIndex = 0; x &lt;= 99; x++)
    { 	 
      if(x % 10 == 0)
      {
        arr1[arr1Index++] = tens[x/10 - 2] ;
        continue;
      }

      if(x &gt; 40 &amp;&amp; x &lt; 50)
      {
        arr1[arr1Index++] = ""forty"" + singleD[sIndex++];
        if(sIndex &gt; 8 &amp;&amp; index &lt; 8)
        {
          sIndex = 0;
          index++;
        }
        continue;
      }

      if(x &gt; 80 &amp;&amp; x &lt; 90)
      {
        arr1[arr1Index++] = ""eighty"" + singleD[sIndex++];
        if(sIndex &gt; 8 &amp;&amp; index &lt; 8)
        {
          sIndex = 0;
          index++;
        }
        continue;
      }

      arr1[arr1Index++] = tens[index] + singleD[sIndex++];
      if(sIndex &gt; 8 &amp;&amp; index &lt; 8)
      {
        sIndex = 0;
        index++;
      } 	  
    }

    String[] arr2 = new String[901];
    arr2[900] = ""onethousand"";
    int arr2Index = 0;

    //PRINT OUT NUMBER 100 - 999
    for(int y = 100, index2 = 0, index3 = 0; y &lt; 1000; y++)
    {
      if(y % 100 == 0)
      {
        arr2[arr2Index++] = singleD[y/100 - 1] + hundred;
        continue;
      }

      arr2[arr2Index++] = singleD[index2] + hundred + and + arr1[index3++];
      if(index3 &gt; 98)
      {
        index3 = 0;
        index2++;
      }	  
    }

    int sum = 0;

    for(int k = 0; k &lt; arr1.length; k++)
    {
      sum += arr1[k].length();
    }
    for(int o = 0; o &lt; arr2.length; o++)
    {
      sum += arr2[o].length();
    }
    System.out.println(""The total number of characters: "" + sum);
  }
}
[/java]
[java]Execution time: 3 ms.[/java]
","Problem 17: Number Letter Counts",,"publish","closed","closed",,"p17-2",,,"2014-06-15 07:08:45","2014-06-15 07:08:45",,"0","http://euler.lvtran.com/?p=74","0","post",,"0"
"75","1","2014-06-07 10:22:24","2014-06-07 10:22:24","<p>If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total. If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
<br><b>NOTE:</b> Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of ""and"" when writing out numbers is in compliance with British usage.</p>

<h2>The Catch</h2>
<p>How to efficiently calculate the number of letters of 1,000 numbers when they are spelled out.</p>

<h2>The Light</h2>
<p>The number Divide 1,000 numbers into groups based on the similarity of their spellings:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; 1 - 20
&nbsp;&nbsp;&nbsp;&nbsp;&diams; 21 - 99
&nbsp;&nbsp;&nbsp;&nbsp;&diams; 100 - 999
Reuse the result of previous groups on the latter groups. For example, 128 (one hundred twenty eight) can use 1 (one) from the first group and 28 (twenty eight) from the second group.</p>

<h2>The Code</h2>
[java]
public class Problem17
{
  public static void main(String[] args)
  {
    String[] arr1 = new String[99];
    int arr1Index = 0;

    String[] singleD = {""one"", ""two"", ""three"", ""four"", ""five"", 
                        ""six"", ""seven"", ""eight"", ""nine""};

    String ten = ""ten"";
    String eleven = ""eleven"";
    String twelve = ""twelve"";
    String thirteen = ""thirteen"";
    String fifteen = ""fifteen"";
    String eighteen = ""eighteen"";
    String teen = ""teen"";

    String ty = ""ty"";
    String twenty = ""twenty"";
    String thirty = ""thirty"";
    String forty = ""forty"";
    String fifty = ""fifty"";
    String eighty = ""eighty"";
    String[] tens = new String[8];
    for(int j = 0; j &lt; tens.length; j++)
    {
      if(j == 0) 
      {
        tens[j] = twenty;
        continue;
      }
      if(j == 1)
      {
        tens[j] = thirty;
        continue;
      }
      if(j == 2)
      {
        tens[j] = forty;
        continue;
      }
      if(j == 3)
      {
        tens[j] = fifty;
        continue;
      }
      if(j == 6)
      {
        tens[j] = eighty;
        continue;
      }
      tens[j] = singleD[ j + 1] + ty;
    }

    String and = ""and"";
    String hundred = ""hundred"";

    //PRINT OUT THE NUMBERS 1- 20
    for(int i = 1; i &lt;= 20; i++)
    { 
      if(i &lt; 10)
        arr1[arr1Index++] = singleD[i - 1];

      if(i &gt;= 10 &amp;&amp; i &lt;= 20)
        switch(i)
        {
          case 10: arr1[arr1Index++] = ten;
                   break;
          case 11: arr1[arr1Index++] = eleven;
                   break;
          case 12: arr1[arr1Index++] = twelve;
                   break;
          case 13: arr1[arr1Index++] = thirteen;
                   break;
          case 15: arr1[arr1Index++] = fifteen;
                   break;
          case 18: arr1[arr1Index++] = eighteen;
                   break;
          case 20: arr1[arr1Index++] = twenty;
                   break;
          default: arr1[arr1Index++] = (singleD[i - 10 - 1] + teen);
                   break;
        }		
    }

    //PRINT OUT NUMBER 21 - 99
    for(int x = 21, index = 0, sIndex = 0; x &lt;= 99; x++)
    { 	 
      if(x % 10 == 0)
      {
        arr1[arr1Index++] = tens[x/10 - 2] ;
        continue;
      }

      if(x &gt; 40 &amp;&amp; x &lt; 50)
      {
        arr1[arr1Index++] = ""forty"" + singleD[sIndex++];
        if(sIndex &gt; 8 &amp;&amp; index &lt; 8)
        {
          sIndex = 0;
          index++;
        }
        continue;
      }

      if(x &gt; 80 &amp;&amp; x &lt; 90)
      {
        arr1[arr1Index++] = ""eighty"" + singleD[sIndex++];
        if(sIndex &gt; 8 &amp;&amp; index &lt; 8)
        {
          sIndex = 0;
          index++;
        }
        continue;
      }

      arr1[arr1Index++] = tens[index] + singleD[sIndex++];
      if(sIndex &gt; 8 &amp;&amp; index &lt; 8)
      {
        sIndex = 0;
        index++;
      } 	  
    }

    String[] arr2 = new String[901];
    arr2[900] = ""onethousand"";
    int arr2Index = 0;

    //PRINT OUT NUMBER 100 - 999
    for(int y = 100, index2 = 0, index3 = 0; y &lt; 1000; y++)
    {
      if(y % 100 == 0)
      {
        arr2[arr2Index++] = singleD[y/100 - 1] + hundred;
        continue;
      }

      arr2[arr2Index++] = singleD[index2] + hundred + and + arr1[index3++];
      if(index3 &gt; 98)
      {
        index3 = 0;
        index2++;
      }	  
    }

    int sum = 0;

    for(int k = 0; k &lt; arr1.length; k++)
    {
      sum += arr1[k].length();
    }
    for(int o = 0; o &lt; arr2.length; o++)
    {
      sum += arr2[o].length();
    }
    System.out.println(""The total number of characters: "" + sum);
  }
}
[/java]
[java]Execution time: 3 ms.[/java]
","Problem 17: Number Letter Counts",,"inherit","open","open",,"74-revision-v1",,,"2014-06-07 10:22:24","2014-06-07 10:22:24",,"74","http://euler.lvtran.com/74-revision-v1/","0","revision",,"0"
"76","1","2013-12-10 10:22:54","2013-12-10 10:22:54","<p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18a.png"" alt=""18a"" width=""102"" height=""88"" class=""aligncenter size-full wp-image-247"" />
<p>That is, 3 + 7 + 4 + 9 = 23. Find the maximum total from top to bottom of the triangle below:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18b.png"" alt=""18b"" width=""459"" height=""274"" class=""aligncenter size-full wp-image-248"" /><!--more-->


<b>NOTE:</b> As there are only 16384 routes, it is possible to solve this problem by trying every route. However, <a href=""http://lvtran.com/p67"">Problem 67</a>, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method!)</p>

<h2>The Catch</h2>
<p>If you start from the top number of the triangle like in the example provided, you end up with an incorrect answer... Why is that? 
<br>If you try every route for each level, that is 16,384 routes to check, which might take more than 1 second to execute.</p>

<h2>The Light</h2>
<p>The reason for your incorrect answer if you start from the top of the triangle is because of the 			<a href=""http://en.wikipedia.org/wiki/Greedy_algorithm"" target=""_blank"">Greedy algorithm</a>, which is generally used to find the local extrema. For this problem, the answer should be a global extrema, or the greatest sum out of all possible routes.<br>

For example, if the example triangle was changed to<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18c.png"" alt=""18c"" width=""102"" height=""88"" class=""aligncenter size-full wp-image-249"" />then the global greatest sum is no longer 23. If you take the route 3 &rarr; 4 &rarr; 88 &rarr; 9, the correct global extrema will be 3 + 4 + 88 + 9 = 104. If you just follow the Greedy algorithm, however, you will miss better routes (just like in real life, I suppose...)
			
To avoid the Greedy algorithm, start from the bottom of the triangle instead of from the top. We will shrink the triangle from the bottom; notice that for every 2 numbers from 2nd row downward, there is a ""middle"" number on the row above. For instance, <strong>2</strong> in 3rd row is the middle number of <strong>8</strong> and <strong>5</strong> in the 4th row and <strong>4</strong> from the 3rd row is the middle number of <strong>5</strong> and <strong>9</strong> from the 4th row. Starting with the most bottom row, 			take every 2 numbers and add each of them (separately) to their middle number. Replace their middle number with the larger sum. Repeat until the triangle is shrunk to only one number - the answer.
			
<br>To demonstrate:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18d.png"" alt=""18d"" width=""102"" height=""88"" class=""aligncenter size-full wp-image-251"" />8 + 2 = 10 and 5 + 2 = 7, so replace 2 with 10. Repeat for the pair 5 and 9 and 9 and 3, we have <img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18e.png"" alt=""18e"" width=""64"" height=""48"" class=""aligncenter size-full wp-image-252"" /> Then repeat the procedure for the 3rd row; the triangle becomes <img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18f.png"" alt=""18f"" width=""50"" height=""30"" class=""aligncenter size-full wp-image-253"" />At this point, it is clear that the answer is 104, as expected.
			
<br>Copy and paste the triangle to a <a href=""https://www.dropbox.com/s/jt4gd5f441q5tef/triangleInput18.txt"" target=""_blank"">	triangleInput18.txt</a> file and use Java's <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html"" target=""_blank"">Scanner</a> 
class to read inputs.</p>

<h2>The Code</h2>
[java]
import java.io.*;
import java.util.*;

public class Problem18
{
  public static void main(String[] args) throws FileNotFoundException
  {
    int row = 15;
    int rowIndex = 0;
    int[][] tri = new int[row][];

    Scanner scan = new Scanner(new File(""triangleInput18.txt""));
    while(scan.hasNextLine())
    {
      String s = scan.nextLine();
      String[] input = s.split("" "");

      tri[rowIndex] = new int[input.length];
      for( int i = 0; i &lt; input.length; i++ )       
      {
         tri[rowIndex][i] = Integer.parseInt(input[i]);
      }       
      rowIndex++;	       
    } 	     

    for(int i = row - 1; i &gt; 0; i--)
    {
      int index = 0;
      for(int j = 0; j &lt; tri[i].length - 1; j++, index++)       
      {
        int tmp1 = tri[i][j] + tri[i - 1][index];         
        int tmp2 = tri[i][j + 1] + tri[i - 1][index];        
        if(tmp1 &gt; tmp2)
          tri[i - 1][index] = tmp1;
        else
          tri[i - 1][index] = tmp2;
      }  
    }
    System.out.println(""Maximum total from top to bottom: "" + tri[0][0]);
  }
}
[/java]
[java]Execution time: 18 ms.[/java]","Problem 18: Maximum Path Sum 1",,"publish","closed","closed",,"p18",,,"2014-06-15 07:08:45","2014-06-15 07:08:45",,"0","http://euler.lvtran.com/?p=76","0","post",,"0"
"77","1","2014-06-07 10:22:54","2014-06-07 10:22:54","<p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18a.png"" alt=""18a"" width=""102"" height=""88"" class=""aligncenter size-full wp-image-247"" />
<p>That is, 3 + 7 + 4 + 9 = 23. Find the maximum total from top to bottom of the triangle below:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18b.png"" alt=""18b"" width=""459"" height=""274"" class=""aligncenter size-full wp-image-248"" /><!--more-->


<b>NOTE:</b> As there are only 16384 routes, it is possible to solve this problem by trying every route. However, <a href=""http://lvtran.com/p67"">Problem 67</a>, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method!)</p>

<h2>The Catch</h2>
<p>If you start from the top number of the triangle like in the example provided, you end up with an incorrect answer... Why is that? 
<br>If you try every route for each level, that is 16,384 routes to check, which might take more than 1 second to execute.</p>

<h2>The Light</h2>
<p>The reason for your incorrect answer if you start from the top of the triangle is because of the 			<a href=""http://en.wikipedia.org/wiki/Greedy_algorithm"" target=""_blank"">Greedy algorithm</a>, which is generally used to find the local extrema. For this problem, the answer should be a global extrema, or the greatest sum out of all possible routes.<br>

For example, if the example triangle was changed to<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18c.png"" alt=""18c"" width=""102"" height=""88"" class=""aligncenter size-full wp-image-249"" />then the global greatest sum is no longer 23. If you take the route 3 &rarr; 4 &rarr; 88 &rarr; 9, the correct global extrema will be 3 + 4 + 88 + 9 = 104. If you just follow the Greedy algorithm, however, you will miss better routes (just like in real life, I suppose...)
			
To avoid the Greedy algorithm, start from the bottom of the triangle instead of from the top. We will shrink the triangle from the bottom; notice that for every 2 numbers from 2nd row downward, there is a ""middle"" number on the row above. For instance, <strong>2</strong> in 3rd row is the middle number of <strong>8</strong> and <strong>5</strong> in the 4th row and <strong>4</strong> from the 3rd row is the middle number of <strong>5</strong> and <strong>9</strong> from the 4th row. Starting with the most bottom row, 			take every 2 numbers and add each of them (separately) to their middle number. Replace their middle number with the larger sum. Repeat until the triangle is shrunk to only one number - the answer.
			
<br>To demonstrate:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18d.png"" alt=""18d"" width=""102"" height=""88"" class=""aligncenter size-full wp-image-251"" />8 + 2 = 10 and 5 + 2 = 7, so replace 2 with 10. Repeat for the pair 5 and 9 and 9 and 3, we have <img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18e.png"" alt=""18e"" width=""64"" height=""48"" class=""aligncenter size-full wp-image-252"" /> Then repeat the procedure for the 3rd row; the triangle becomes <img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18f.png"" alt=""18f"" width=""50"" height=""30"" class=""aligncenter size-full wp-image-253"" />At this point, it is clear that the answer is 104, as expected.
			
<br>Copy and paste the triangle to a <a href=""https://www.dropbox.com/s/jt4gd5f441q5tef/triangleInput18.txt"" target=""_blank"">	triangleInput18.txt</a> file and use Java's <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html"" target=""_blank"">Scanner</a> 
class to read inputs.</p>

<h2>The Code</h2>
[java]
import java.io.*;
import java.util.*;

public class Problem18
{
  public static void main(String[] args) throws FileNotFoundException
  {
    int row = 15;
    int rowIndex = 0;
    int[][] tri = new int[row][];

    Scanner scan = new Scanner(new File(""triangleInput18.txt""));
    while(scan.hasNextLine())
    {
      String s = scan.nextLine();
      String[] input = s.split("" "");

      tri[rowIndex] = new int[input.length];
      for( int i = 0; i &lt; input.length; i++ )       
      {
         tri[rowIndex][i] = Integer.parseInt(input[i]);
      }       
      rowIndex++;	       
    } 	     

    for(int i = row - 1; i &gt; 0; i--)
    {
      int index = 0;
      for(int j = 0; j &lt; tri[i].length - 1; j++, index++)       
      {
        int tmp1 = tri[i][j] + tri[i - 1][index];         
        int tmp2 = tri[i][j + 1] + tri[i - 1][index];        
        if(tmp1 &gt; tmp2)
          tri[i - 1][index] = tmp1;
        else
          tri[i - 1][index] = tmp2;
      }  
    }
    System.out.println(""Maximum total from top to bottom: "" + tri[0][0]);
  }
}
[/java]
[java]Execution time: 18 ms.[/java]","Problem 18: Maximum Path Sum 1",,"inherit","open","open",,"76-revision-v1",,,"2014-06-07 10:22:54","2014-06-07 10:22:54",,"76","http://euler.lvtran.com/76-revision-v1/","0","revision",,"0"
"78","1","2013-12-09 10:23:29","2013-12-09 10:23:29","<p>You are given the following information, but you may prefer to do some research for yourself.
<div align=""center""><p>
			1 Jan 1900 was a Monday.<br>
			Thirty days has September,<br>
			April, June and November.<br>
			All the rest have thirty-one,<br>
			Saving February alone,<br>
			Which has twenty-eight, rain or shine.<br>
			And on leap years, twenty-nine.<br>
			A leap year occurs on any year evenly divisible by 4, but not on a 
			century unless it is divisible by 400.
</div>
<p>How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</p>
<!--more-->


<h2>The Catch</h2>
<p>How to determine what day of a week any given date is.</p>

<h2>The Light</h2>
<p>There are plenty of methods to determine the day of week: from the <a href=""http://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Gauss.27s_algorithm"" target=""_blank"">Gauss's algorithm</a> to the <a href=""http://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Schwerdtfeger.27s_variation"" target=""_blank"">Schwerdtfeger's variation</a>, but there is also a simpler method. Given any date mm/dd/yyyy:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Refer to the Month-Offset Table below to find the offset value of mm.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>a = ((value found in step 1) + dd) % 7</strong>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>b = (the last 2 digits of yyyy) % 28</strong>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>c = b + b/4</strong>. Drop all the decimal (similar to (int) c).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Refer to the Century-Offset Table below to find the offset value of yyyy.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Add <strong>c</strong> to the value in step 5. If mm is Jan or Feb AND yyyy is a leap year, then subtract 1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>d = (a + c) % 7</strong>. Look for d in the Day of the Week Table below to determine the &nbsp;&nbsp;&nbsp;&nbsp;day of the week.<br>
			
<div align=""center"">
Month- Offset Table
<table align=""center"" border=""1"">
<tbody>
<tr>
			<td align=""center"">Jan</td>
			<td align=""center"">Feb</td>
			<td align=""center"">Mar</td>
			<td align=""center"">Apr</td>
			<td align=""center"">May</td>
			<td align=""center"">Jun</td>
			<td align=""center"">Jul</td>
			<td align=""center"">Aug</td>
			<td align=""center"">Sep</td>
			<td align=""center"">Oct</td>
			<td align=""center"">Nov</td>
			<td align=""center"">Dec</td>
			</tr>
			<tr>
			<td align=""center"">0</td>
			<td align=""center"">3</td>
			<td align=""center"">3</td>
			<td align=""center"">6</td>
			<td align=""center"">1</td>
			<td align=""center"">4</td>
			<td align=""center"">6</td>
			<td align=""center"">2</td>
			<td align=""center"">5</td>
			<td align=""center"">0</td>
			<td align=""center"">3</td>
			<td align=""center"">5</td>
			</tr>
			</tbody>
			</table>
			Century-Offset Table
			<table align=""center"" border=""1"">
			<tbody>
			<tr>
			<td align=""center"">1600's</td>
			<td align=""center"">1700's</td>
			<td align=""center"">1800's</td>
			<td align=""center"">1900's</td>
			<td align=""center"">2000's</td>
			</tr>
			<tr>
			<td align=""center"">0</td>
			<td align=""center"">5</td>
			<td align=""center"">3</td>
			<td align=""center"">1</td>
			<td align=""center"">0</td>
			</tr>
			</tbody>
			</table>
			Day of the Week Table
			<table align=""center"" border=""1"">
			<tbody>
			<tr>
			<td align=""center"">Sun</td>
			<td align=""center"">Mon</td>
			<td align=""center"">Tue</td>
			<td align=""center"">Wed</td>
			<td align=""center"">Thu</td>
			<td align=""center"">Fri</td>
			<td align=""center"">Sat</td>
			</tr>
			<tr>
			<td align=""center"">1</td>
			<td align=""center"">2</td>
			<td align=""center"">3</td>
			<td align=""center"">4</td>
			<td align=""center"">5</td>
			<td align=""center"">6</td>
			<td align=""center"">7 or 0</td>
			</tr>
			</tbody>
			</table></div>
			<br><p>Example: December 8th, 1994.
				a = (5 + 8) % 7 = 6
				b = 94 % 28 = 10
				c = 10 + 10/4 = 12.5 = 12
				c = 1 + c = 1 + 12 = 13
				d = (6 + 13) % 7 = 5, which is a Thursday.
		
This approach is straightforward and simple to implement, but... why not just let Java do the labor: utilize the <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Calendar.html"" target=""_blank"">Calendar</a> class.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem19
{
  public static void main(String[] args)
  {
    Calendar c = Calendar.getInstance();
    int count = 0;

    for(int i = 1; i &lt;= 100; i++) //Go from 1/1/1901 to 12/31/2000
    {
      for(int m = 0; m &lt; 12; m++) //0 is January
      { 
        c.set(1900 + i, m, 1);   //The first of every month
        Date d = c.getTime();
        if(d.getDay() == 0)
          count++;
      }
    }
    System.out.println(count);
  }
}
[/java]
[java]Execution time: 54 ms.[/java]","Problem 19: Counting Sundays",,"publish","closed","closed",,"p19",,,"2014-06-15 07:08:45","2014-06-15 07:08:45",,"0","http://euler.lvtran.com/?p=78","0","post",,"0"
"79","1","2014-06-07 10:23:29","2014-06-07 10:23:29","<h2>The Problem</h2> 
<p>You are given the following information, but you may prefer to do some research for yourself.
<div align=""center""><p>
			1 Jan 1900 was a Monday.<br>
			Thirty days has September,<br>
			April, June and November.<br>
			All the rest have thirty-one,<br>
			Saving February alone,<br>
			Which has twenty-eight, rain or shine.<br>
			And on leap years, twenty-nine.<br>
			A leap year occurs on any year evenly divisible by 4, but not on a 
			century unless it is divisible by 400.
</div>
<p>How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</p>
<!--more-->


<h2>The Catch</h2>
<p>How to determine what day of a week any given date is.</p>

<h2>The Light</h2>
<p>There are plenty of methods to determine the day of week: from the <a href=""http://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Gauss.27s_algorithm"" target=""_blank"">Gauss's algorithm</a> to the <a href=""http://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Schwerdtfeger.27s_variation"" target=""_blank"">Schwerdtfeger's variation</a>, but there is also a simpler method. Given any date mm/dd/yyyy:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Refer to the Month-Offset Table below to find the offset value of mm.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>a = ((value found in step 1) + dd) % 7</strong>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>b = (the last 2 digits of yyyy) % 28</strong>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>c = b + b/4</strong>. Drop all the decimal (similar to (int) c).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Refer to the Century-Offset Table below to find the offset value of yyyy.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Add <strong>c</strong> to the value in step 5. If mm is Jan or Feb AND yyyy is a leap year, then subtract 1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>d = (a + c) % 7</strong>. Look for d in the Day of the Week Table below to determine the &nbsp;&nbsp;&nbsp;&nbsp;day of the week.<br>
			
<div align=""center"">
Month- Offset Table
<table align=""center"" border=""1"">
<tbody>
<tr>
			<td align=""center"">Jan</td>
			<td align=""center"">Feb</td>
			<td align=""center"">Mar</td>
			<td align=""center"">Apr</td>
			<td align=""center"">May</td>
			<td align=""center"">Jun</td>
			<td align=""center"">Jul</td>
			<td align=""center"">Aug</td>
			<td align=""center"">Sep</td>
			<td align=""center"">Oct</td>
			<td align=""center"">Nov</td>
			<td align=""center"">Dec</td>
			</tr>
			<tr>
			<td align=""center"">0</td>
			<td align=""center"">3</td>
			<td align=""center"">3</td>
			<td align=""center"">6</td>
			<td align=""center"">1</td>
			<td align=""center"">4</td>
			<td align=""center"">6</td>
			<td align=""center"">2</td>
			<td align=""center"">5</td>
			<td align=""center"">0</td>
			<td align=""center"">3</td>
			<td align=""center"">5</td>
			</tr>
			</tbody>
			</table>
			Century-Offset Table
			<table align=""center"" border=""1"">
			<tbody>
			<tr>
			<td align=""center"">1600's</td>
			<td align=""center"">1700's</td>
			<td align=""center"">1800's</td>
			<td align=""center"">1900's</td>
			<td align=""center"">2000's</td>
			</tr>
			<tr>
			<td align=""center"">0</td>
			<td align=""center"">5</td>
			<td align=""center"">3</td>
			<td align=""center"">1</td>
			<td align=""center"">0</td>
			</tr>
			</tbody>
			</table>
			Day of the Week Table
			<table align=""center"" border=""1"">
			<tbody>
			<tr>
			<td align=""center"">Sun</td>
			<td align=""center"">Mon</td>
			<td align=""center"">Tue</td>
			<td align=""center"">Wed</td>
			<td align=""center"">Thu</td>
			<td align=""center"">Fri</td>
			<td align=""center"">Sat</td>
			</tr>
			<tr>
			<td align=""center"">1</td>
			<td align=""center"">2</td>
			<td align=""center"">3</td>
			<td align=""center"">4</td>
			<td align=""center"">5</td>
			<td align=""center"">6</td>
			<td align=""center"">7 or 0</td>
			</tr>
			</tbody>
			</table></div>
			<br><p>Example: December 8th, 1994.
				a = (5 + 8) % 7 = 6
				b = 94 % 28 = 10
				c = 10 + 10/4 = 12.5 = 12
				c = 1 + c = 1 + 12 = 13
				d = (6 + 13) % 7 = 5, which is a Thursday.
		
This approach is straightforward and simple to implement, but... why not just let Java do the labor: utilize the <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Calendar.html"" target=""_blank"">Calendar</a> class.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem19
{
  public static void main(String[] args)
  {
    Calendar c = Calendar.getInstance();
    int count = 0;

    for(int i = 1; i &lt;= 100; i++) //Go from 1/1/1901 to 12/31/2000
    {
      for(int m = 0; m &lt; 12; m++) //0 is January
      { 
        c.set(1900 + i, m, 1);   //The first of every month
        Date d = c.getTime();
        if(d.getDay() == 0)
          count++;
      }
    }
    System.out.println(count);
  }
}
[/java]
[java]Execution time: 54 ms.[/java]","Problem 19: Counting Sundays",,"inherit","open","open",,"78-revision-v1",,,"2014-06-07 10:23:29","2014-06-07 10:23:29",,"78","http://euler.lvtran.com/78-revision-v1/","0","revision",,"0"
"80","1","2014-06-07 10:23:44","2014-06-07 10:23:44","<p>You are given the following information, but you may prefer to do some research for yourself.
<div align=""center""><p>
			1 Jan 1900 was a Monday.<br>
			Thirty days has September,<br>
			April, June and November.<br>
			All the rest have thirty-one,<br>
			Saving February alone,<br>
			Which has twenty-eight, rain or shine.<br>
			And on leap years, twenty-nine.<br>
			A leap year occurs on any year evenly divisible by 4, but not on a 
			century unless it is divisible by 400.
</div>
<p>How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</p>
<!--more-->


<h2>The Catch</h2>
<p>How to determine what day of a week any given date is.</p>

<h2>The Light</h2>
<p>There are plenty of methods to determine the day of week: from the <a href=""http://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Gauss.27s_algorithm"" target=""_blank"">Gauss's algorithm</a> to the <a href=""http://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Schwerdtfeger.27s_variation"" target=""_blank"">Schwerdtfeger's variation</a>, but there is also a simpler method. Given any date mm/dd/yyyy:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Refer to the Month-Offset Table below to find the offset value of mm.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>a = ((value found in step 1) + dd) % 7</strong>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>b = (the last 2 digits of yyyy) % 28</strong>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>c = b + b/4</strong>. Drop all the decimal (similar to (int) c).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Refer to the Century-Offset Table below to find the offset value of yyyy.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Add <strong>c</strong> to the value in step 5. If mm is Jan or Feb AND yyyy is a leap year, then subtract 1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Define <strong>d = (a + c) % 7</strong>. Look for d in the Day of the Week Table below to determine the &nbsp;&nbsp;&nbsp;&nbsp;day of the week.<br>
			
<div align=""center"">
Month- Offset Table
<table align=""center"" border=""1"">
<tbody>
<tr>
			<td align=""center"">Jan</td>
			<td align=""center"">Feb</td>
			<td align=""center"">Mar</td>
			<td align=""center"">Apr</td>
			<td align=""center"">May</td>
			<td align=""center"">Jun</td>
			<td align=""center"">Jul</td>
			<td align=""center"">Aug</td>
			<td align=""center"">Sep</td>
			<td align=""center"">Oct</td>
			<td align=""center"">Nov</td>
			<td align=""center"">Dec</td>
			</tr>
			<tr>
			<td align=""center"">0</td>
			<td align=""center"">3</td>
			<td align=""center"">3</td>
			<td align=""center"">6</td>
			<td align=""center"">1</td>
			<td align=""center"">4</td>
			<td align=""center"">6</td>
			<td align=""center"">2</td>
			<td align=""center"">5</td>
			<td align=""center"">0</td>
			<td align=""center"">3</td>
			<td align=""center"">5</td>
			</tr>
			</tbody>
			</table>
			Century-Offset Table
			<table align=""center"" border=""1"">
			<tbody>
			<tr>
			<td align=""center"">1600's</td>
			<td align=""center"">1700's</td>
			<td align=""center"">1800's</td>
			<td align=""center"">1900's</td>
			<td align=""center"">2000's</td>
			</tr>
			<tr>
			<td align=""center"">0</td>
			<td align=""center"">5</td>
			<td align=""center"">3</td>
			<td align=""center"">1</td>
			<td align=""center"">0</td>
			</tr>
			</tbody>
			</table>
			Day of the Week Table
			<table align=""center"" border=""1"">
			<tbody>
			<tr>
			<td align=""center"">Sun</td>
			<td align=""center"">Mon</td>
			<td align=""center"">Tue</td>
			<td align=""center"">Wed</td>
			<td align=""center"">Thu</td>
			<td align=""center"">Fri</td>
			<td align=""center"">Sat</td>
			</tr>
			<tr>
			<td align=""center"">1</td>
			<td align=""center"">2</td>
			<td align=""center"">3</td>
			<td align=""center"">4</td>
			<td align=""center"">5</td>
			<td align=""center"">6</td>
			<td align=""center"">7 or 0</td>
			</tr>
			</tbody>
			</table></div>
			<br><p>Example: December 8th, 1994.
				a = (5 + 8) % 7 = 6
				b = 94 % 28 = 10
				c = 10 + 10/4 = 12.5 = 12
				c = 1 + c = 1 + 12 = 13
				d = (6 + 13) % 7 = 5, which is a Thursday.
		
This approach is straightforward and simple to implement, but... why not just let Java do the labor: utilize the <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Calendar.html"" target=""_blank"">Calendar</a> class.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem19
{
  public static void main(String[] args)
  {
    Calendar c = Calendar.getInstance();
    int count = 0;

    for(int i = 1; i &lt;= 100; i++) //Go from 1/1/1901 to 12/31/2000
    {
      for(int m = 0; m &lt; 12; m++) //0 is January
      { 
        c.set(1900 + i, m, 1);   //The first of every month
        Date d = c.getTime();
        if(d.getDay() == 0)
          count++;
      }
    }
    System.out.println(count);
  }
}
[/java]
[java]Execution time: 54 ms.[/java]","Problem 19: Counting Sundays",,"inherit","open","open",,"78-revision-v1",,,"2014-06-07 10:23:44","2014-06-07 10:23:44",,"78","http://euler.lvtran.com/78-revision-v1/","0","revision",,"0"
"81","1","2013-12-07 10:24:08","2013-12-07 10:24:08","<p>n! means n x (n - 1) x ... x 3 x 2 x 1
For example, 10! = 10 x 9 x ... x 3 x 2 x 1 = 3628800, and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.Find the sum of the digits in the number 100!</p>
<!--more-->


<h2>The Catch</h2>
<p>How to efficiently calculate factorial.
How to store an extremely large number.</p>

<h2>The Light</h2>
<p>&clubs; Factorial calculation is much more efficient using the iterative approach as opposed to the recursive one. To find <strong>x!</strong>, keep multiplying <strong>x</strong> by <strong>x - 1</strong> every time until <strong>x</strong> reaches <strong>1</strong>. That way, the factorial-finding loop is nothing but a sequence of simple multiplication, which is what computer is very good at.
<br>&clubs; Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class. Then parse the result into an array of digit-character to calculate their sum.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem20
{
  public static void main(String[] args)
  {
    BigInteger n = new BigInteger(""100"");
    BigInteger result = BigInteger.ONE;

    while(n.compareTo(BigInteger.ONE) == 1)
    {
      result =  result.multiply(n.subtract(BigInteger.ONE));
      n = n.subtract(BigInteger.ONE);
    }

    System.out.println(""Result: "" + result);

    String s = result.toString();
    char[] array = new char[s.length()];
    array = s.toCharArray();

    int sum = 0;
    for(int i = 0; i &lt; array.length; i++)
    {
      sum += Character.getNumericValue(array[i]);
    }

    System.out.println(sum);
  }
}
[/java]
[java]Execution time: 8 ms.[/java]","Problem 20: Factorial Digit Sum",,"publish","closed","closed",,"p20",,,"2014-06-15 07:09:32","2014-06-15 07:09:32",,"0","http://euler.lvtran.com/?p=81","0","post",,"0"
"82","1","2014-06-07 10:24:08","2014-06-07 10:24:08","<h2>The Problem</h2> 
<p>n! means n x (n - 1) x ... x 3 x 2 x 1
For example, 10! = 10 x 9 x ... x 3 x 2 x 1 = 3628800, and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.Find the sum of the digits in the number 100!</p>
<!--more-->


<h2>The Catch</h2>
<p>How to efficiently calculate factorial.
How to store an extremely large number.</p>

<h2>The Light</h2>
<p>&clubs; Factorial calculation is much more efficient using the iterative approach as opposed to the recursive one. To find <strong>x!</strong>, keep multiplying <strong>x</strong> by <strong>x - 1</strong> every time until <strong>x</strong> reaches <strong>1</strong>. That way, the factorial-finding loop is nothing but a sequence of simple multiplication, which is what computer is very good at.
<br>&clubs; Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class. Then parse the result into an array of digit-character to calculate their sum.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem20
{
  public static void main(String[] args)
  {
    BigInteger n = new BigInteger(""100"");
    BigInteger result = BigInteger.ONE;

    while(n.compareTo(BigInteger.ONE) == 1)
    {
      result =  result.multiply(n.subtract(BigInteger.ONE));
      n = n.subtract(BigInteger.ONE);
    }

    System.out.println(""Result: "" + result);

    String s = result.toString();
    char[] array = new char[s.length()];
    array = s.toCharArray();

    int sum = 0;
    for(int i = 0; i &lt; array.length; i++)
    {
      sum += Character.getNumericValue(array[i]);
    }

    System.out.println(sum);
  }
}
[/java]
[java]Execution time: 8 ms.[/java]","Problem 20: Factorial Digit Sum",,"inherit","open","open",,"81-revision-v1",,,"2014-06-07 10:24:08","2014-06-07 10:24:08",,"81","http://euler.lvtran.com/81-revision-v1/","0","revision",,"0"
"88","1","2013-12-06 10:16:18","2013-12-06 10:16:18","<p>Let d(<i>n</i>) be defined as the sum of proper divisors of	<i>n</i> (numbers less than <i>n</i> which divide evenly into <i>n</i>). If <strong>d(<i>a</i>) = <i>b</i></strong> and <strong>d(<i>b</i>) = <i>a</i></strong>, where <i>a</i> &ne; <i>b</i>, then <i>a</i> and <i>b</i> are an amicable pair and each of <i>a</i> and <i>b</i> are called amicable numbers. For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220. Evaluate the sum of all the amicable numbers under 10000.</p><br><br><!--more-->



<h2>The Catch</h2>
<p>How to find the sum of divisors of an arbitrary number x.
How to check whether a number is amicable.</p>

<h2>The Light</h2>
<p>&clubs; Utilize the concept of finding divisors discussed in <a href=""http://lvtran.com/p12/"">Problem 12</a>, find the sum of all divisors. Note that the problem asks for <b>proper divisors</b>, which means the set of all divisors except the number itself.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; The set of divisors of 8 is {1, 2, 4, 8}. The set of proper divisors of 8 is {1, 2, 4}.<br>
<br>&clubs; Loop from 1 to 10,000. For each iteration, find the sum <strong>b</strong> of all divisors of a number <strong>n</strong>. If the sum <strong>b</strong> is greater than the number <strong>n </strong>and less than 10,000, then the number <strong>n </strong>can have its amicable pair. Treating<strong> b</strong> as another number, find the sum <strong>a</strong> of all divisors of <strong>b </strong>and if <strong>a</strong> is the same as <strong>n</strong>, then <strong>n</strong> and <strong>b</strong> are an amicable pair. 
&nbsp;&nbsp;&nbsp;&nbsp;&diams; For example, while looping from 1 to 10,000, one of the iteration is the number <strong>n</strong> = 220. &nbsp;&nbsp;&nbsp;&nbsp;Let <strong>b</strong> be the sum of all divisors of the number <strong>n</strong>, so <strong>b = 284</strong>. Then let <strong>a</strong> be the sum of all &nbsp;&nbsp;&nbsp;&nbsp;divisors of <strong>b</strong>, so <strong>a = 220</strong>. Since <strong>a = n = 220</strong>, <strong>n</strong> and <strong>b</strong> must be an amicable pair.</p>

<h2>The Code</h2>
[java]
public class Problem21
{
  public static void main(String[] args)
  {
    int amicableSum = 0;
	
    for(int n = 1; n < 10000; n++)
    {
      int b = sumDiv(n);
      if(b > n && b < 10000)
      {
        int a = sumDiv(b);
    	if(a == n)
    	  amicableSum = amicableSum + n + b;
      }
    }
	
    System.out.println(""Amicable sum = "" + amicableSum);
  }
  
  public static int sumDiv(int n)
  {
    int sum = 1; //1 is a proper divisor for all numbers
	
    for(int i = 2; i * i <= n; i++)
    {
      if(n % i == 0)
        sum = sum + i + n/i;
    }
    return sum;
  }
}
[/java]
[java]Execution time: 7 ms.[/java]","Problem 21: Amicable Numbers",,"publish","closed","closed",,"p21",,,"2014-06-15 07:09:32","2014-06-15 07:09:32",,"0","http://euler.lvtran.com/?p=88","0","post",,"0"
"89","1","2014-06-11 10:16:18","2014-06-11 10:16:18","<p>Let d(<i>n</i>) be defined as the sum of proper divisors of	<i>n</i> (numbers less than <i>n</i> which divide evenly into <i>n</i>). If <strong>d(<i>a</i>) = <i>b</i></strong> and <strong>d(<i>b</i>) = <i>a</i></strong>, where <i>a</i> &ne; <i>b</i>, then <i>a</i> and <i>b</i> are an amicable pair and each of <i>a</i> and <i>b</i> are called amicable numbers. For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220. Evaluate the sum of all the amicable numbers under 10000.</p><br><br><!--more-->



<h2>The Catch</h2>
<p>How to find the sum of divisors of an arbitrary number x.
How to check whether a number is amicable.</p>

<h2>The Light</h2>
<p>&clubs; Utilize the concept of finding divisors discussed in <a href=""http://lvtran.com/p12/"">Problem 12</a>, find the sum of all divisors. Note that the problem asks for <b>proper divisors</b>, which means the set of all divisors except the number itself.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; The set of divisors of 8 is {1, 2, 4, 8}. The set of proper divisors of 8 is {1, 2, 4}.<br>
<br>&clubs; Loop from 1 to 10,000. For each iteration, find the sum <strong>b</strong> of all divisors of a number <strong>n</strong>. If the sum <strong>b</strong> is greater than the number <strong>n </strong>and less than 10,000, then the number <strong>n </strong>can have its amicable pair. Treating<strong> b</strong> as another number, find the sum <strong>a</strong> of all divisors of <strong>b </strong>and if <strong>a</strong> is the same as <strong>n</strong>, then <strong>n</strong> and <strong>b</strong> are an amicable pair. 
&nbsp;&nbsp;&nbsp;&nbsp;&diams; For example, while looping from 1 to 10,000, one of the iteration is the number <strong>n</strong> = 220. &nbsp;&nbsp;&nbsp;&nbsp;Let <strong>b</strong> be the sum of all divisors of the number <strong>n</strong>, so <strong>b = 284</strong>. Then let <strong>a</strong> be the sum of all &nbsp;&nbsp;&nbsp;&nbsp;divisors of <strong>b</strong>, so <strong>a = 220</strong>. Since <strong>a = n = 220</strong>, <strong>n</strong> and <strong>b</strong> must be an amicable pair.</p>

<h2>The Code</h2>
[java]
public class Problem21
{
  public static void main(String[] args)
  {
    int amicableSum = 0;
	
    for(int n = 1; n < 10000; n++)
    {
      int b = sumDiv(n);
      if(b > n && b < 10000)
      {
        int a = sumDiv(b);
    	if(a == n)
    	  amicableSum = amicableSum + n + b;
      }
    }
	
    System.out.println(""Amicable sum = "" + amicableSum);
  }
  
  public static int sumDiv(int n)
  {
    int sum = 1; //1 is a proper divisor for all numbers
	
    for(int i = 2; i * i <= n; i++)
    {
      if(n % i == 0)
        sum = sum + i + n/i;
    }
    return sum;
  }
}
[/java]
[java]Execution time: 7 ms.[/java]","Problem 21: Amicable Numbers",,"inherit","open","open",,"88-revision-v1",,,"2014-06-11 10:16:18","2014-06-11 10:16:18",,"88","http://euler.lvtran.com/88-revision-v1/","0","revision",,"0"
"90","1","2013-12-05 10:17:38","2013-12-05 10:17:38","<p>Using <a href=""http://projecteuler.net/project/names.txt"" target=""_blank"">names.txt</a> (right click and 'Save Link/Target As...'), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.
For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 x 3 = 49714. What is the total of all the name scores in the file?</p><!--more-->



<h2>The Catch</h2>
<p>How to read all the name inputs from names.txt
How to sort the inputs in alphabetical order.<br>
How to efficiently determine the order of each letter in the alphabet.</p>

<h2>The Light</h2>
<p>&clubs; Use Java's <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html"" target=""_blank"">Scanner</a> class and split the inputs by commas (,) and then strip the opening and closing quotation marks.<br>
<br>&clubs; Sorting is a very interesting topic, which will be discussed later. As for now, use <a href=""http://docs.oracle.com/javase/6/docs/api/java/util/Arrays.html"" target=""_blank"">Arrays</a> class' built-in sort method.<br>
<br>&clubs; Each letter has its own unique <a href=""http://en.wikipedia.org/wiki/ASCII"" target=""_blank"">American Standard Code for Information Interchange (ASCII)</a> code, which can be used to find the order of a letter in the alphabet. To find the order of a letter in the alphabet, subtract its ASCII code from that of the letter 'A', which is the first letter in the alphabet, then add <strong>1</strong>. 
&nbsp;&nbsp;&nbsp;&nbsp;&diams; For example, the ASCII code of the letter 'A' is 65 and that of 'L' is 76, so the order of 'L' in the alphabet is 76 - 65 + 1 = 12. 
&nbsp;&nbsp;&nbsp;&nbsp;&diams; To find the ASCII code of a character in Java, simply do a type cast from a type <b>char</b> to a type <b>int</b>.
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/ascii.png"" alt=""ascii"" width=""788"" height=""526"" class=""aligncenter size-full wp-image-282"" /></p>

<h2>The Code</h2>
[java]
import java.io.*;
import java.util.*;

public class Problem22
{
  public static void main(String[] args) throws FileNotFoundException
  {
    File name = new File(""names.txt"");
    Scanner scan = new Scanner(name);

    String string = scan.nextLine();
    String[] s = string.split("","");

    for(int i = 0; i &lt; s.length; i++)
    {
      s[i] = s[i].substring(1, s[i].length() - 1);
    }

    Arrays.sort(s);
    char a = 'A';
    int first = (int)a;
    int total = 0;

    for(int i = 0; i &lt; s.length; i++)
    {
      char[] c = s[i].toCharArray();
      int score = 0;
      for(int y = 0; y &lt; c.length; y++)
      {
        int tmp = (int)c[y];
        int order = tmp - first + 1;
        score += order;
      }
      score *= (i + 1);
      total += score;
    }

    System.out.println(total);
  }
}
[/java]
[java]Execution time: 74 ms.[/java]","Problem 22: Name Scores",,"publish","closed","closed",,"p22",,,"2014-06-15 07:09:33","2014-06-15 07:09:33",,"0","http://euler.lvtran.com/?p=90","0","post",,"0"
"91","1","2014-06-11 10:17:38","2014-06-11 10:17:38","<p>Using <a href=""http://projecteuler.net/project/names.txt"" target=""_blank"">names.txt</a> (right click and 'Save Link/Target As...'), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.
For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 x 3 = 49714. What is the total of all the name scores in the file?</p><!--more-->



<h2>The Catch</h2>
<p>How to read all the name inputs from names.txt
How to sort the inputs in alphabetical order.<br>
How to efficiently determine the order of each letter in the alphabet.</p>

<h2>The Light</h2>
<p>&clubs; Use Java's <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html"" target=""_blank"">Scanner</a> class and split the inputs by commas (,) and then strip the opening and closing quotation marks.<br>
<br>&clubs; Sorting is a very interesting topic, which will be discussed later. As for now, use <a href=""http://docs.oracle.com/javase/6/docs/api/java/util/Arrays.html"" target=""_blank"">Arrays</a> class' built-in sort method.<br>
<br>&clubs; Each letter has its own unique <a href=""http://en.wikipedia.org/wiki/ASCII"" target=""_blank"">American Standard Code for Information Interchange (ASCII)</a> code, which can be used to find the order of a letter in the alphabet. To find the order of a letter in the alphabet, subtract its ASCII code from that of the letter 'A', which is the first letter in the alphabet, then add <strong>1</strong>. 
&nbsp;&nbsp;&nbsp;&nbsp;&diams; For example, the ASCII code of the letter 'A' is 65 and that of 'L' is 76, so the order of 'L' in the alphabet is 76 - 65 + 1 = 12. 
&nbsp;&nbsp;&nbsp;&nbsp;&diams; To find the ASCII code of a character in Java, simply do a type cast from a type <b>char</b> to a type <b>int</b>.
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/ascii.png"" alt=""ascii"" width=""788"" height=""526"" class=""aligncenter size-full wp-image-282"" /></p>

<h2>The Code</h2>
[java]
import java.io.*;
import java.util.*;

public class Problem22
{
  public static void main(String[] args) throws FileNotFoundException
  {
    File name = new File(""names.txt"");
    Scanner scan = new Scanner(name);

    String string = scan.nextLine();
    String[] s = string.split("","");

    for(int i = 0; i &lt; s.length; i++)
    {
      s[i] = s[i].substring(1, s[i].length() - 1);
    }

    Arrays.sort(s);
    char a = 'A';
    int first = (int)a;
    int total = 0;

    for(int i = 0; i &lt; s.length; i++)
    {
      char[] c = s[i].toCharArray();
      int score = 0;
      for(int y = 0; y &lt; c.length; y++)
      {
        int tmp = (int)c[y];
        int order = tmp - first + 1;
        score += order;
      }
      score *= (i + 1);
      total += score;
    }

    System.out.println(total);
  }
}
[/java]
[java]Execution time: 74 ms.[/java]","Problem 22: Name Scores",,"inherit","open","open",,"90-revision-v1",,,"2014-06-11 10:17:38","2014-06-11 10:17:38",,"90","http://euler.lvtran.com/90-revision-v1/","0","revision",,"0"
"92","1","2013-12-04 10:18:04","2013-12-04 10:18:04","<p>A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number. 
<br><br>A number <i>n</i> is called deficient if the sum of its proper divisors is less than <i>n</i> and it is called abundant if this sum exceeds <i>n</i>.
<br><br>As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit. 
<br><br>Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.</p><!--more-->



<h2>The Catch</h2>
<p>How to efficiently find the sum of all proper divisors.
How to determine if a number can be written as a sum of 2 abundant numbers.</p>

<h2>The Light</h2>
<p>&clubs; We can certainly use the implementation in <a href=""http://lvtran.com/p21/"">Problem 21</a> to find the sum of all proper divisors. There is another	way, however, that is just as elegant: the <a href=""http://en.wikipedia.org/wiki/Prime_factor#Omega_functions"" target=""_blank"">Omega function</a>:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/23a.png"" alt=""23a"" width=""669"" height=""158"" class=""aligncenter size-full wp-image-292"" />
&nbsp;&nbsp;&nbsp;&nbsp;&diams; For example, the sum of all factors of 120 = 2<sup>3</sup> x 3 x 5 is (1 + 2 + 2<sup>3</sup> + 2<sup>3</sup>)(1 + 3)(1 + 5) = 15 x 4 x 6 = 360.<br>
&nbsp;&nbsp;&nbsp;&diams; To find the sum of all <a href=""http://mathworld.wolfram.com/ProperDivisor.html"" target=""_blank"">proper divisors,</a> subtract the original number <strong>n</strong> from the sum found above. Make some modification to the prime factorization in <a href=""http://lvtran.com/p12/"">Problem 12</a> to implement the Omega function.<br><br>
&clubs; To determine if a number can be written as the sum of 2 abundant numbers, make a boolean array of size 28,123. Create a list of abundant number up to 28,123 using the modified prime factorization method. Then make 2 for loops: the outer loops from the first abundant number <strong>a</strong> to the last one in the list and the inner loops from <strong>a</strong> to the last one in the list. If the sum of the number from these 2 loops is less than or equal to 28,123, then that sum can be written as the sum of 2 abundant numbers. Mark this number in the boolean array. When the two loops terminate, sum up all the numbers that were not marked (i.e numbers that cannot be written as the sum of 2 abundant numbers).<p>
<p>&clubs; Wolfram Alpha's <a href=""http://mathworld.wolfram.com/AbundantNumber.html"" target=""_blank"">article</a> on abundant numbers states that the upper bound is actually <strong>20,161</strong>, so use that as the upper bound instead of 28,123 (saving almost 8,000 iterations!)</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem23
{
  static List primeList = generatePrimes(20161);

  public static void main(String[] args)
  {
    List abundant = new ArrayList();
    long sum = 0;

    for(int i = 12; i &lt; 20161; i++) 	
    {
      if(sumProperDiv(i) &gt; i)
        abundant.add(new Integer(i));
    }

    boolean[] sumOfAbundant = new boolean[20161 + 1];
    for(int i = 0; i &lt; abundant.size(); i++)
    {
      for(int j = i; j &lt; abundant.size(); j++)
      {
        if(abundant.get(i) + abundant.get(j) &lt;= 20161)
    	  sumOfAbundant[abundant.get(i) + abundant.get(j)] = true;
    	else
    	  break;
      }
    }

    for(int i = 0; i &lt;= 20161; i++) 	
    {
      if(!sumOfAbundant[i])
        sum += i;
    }
    System.out.println(sum);
  }

  public static int sumProperDiv(int n)   
  {
    int notProper = n;
    int index = 0;
    double sum = 1.0;
    while(n &gt; 1)
    {
      int pow = 1;
      double subSum = 1.0;
      while(n % primeList.get(index) == 0)
      {
        n /= primeList.get(index);
    	subSum += Math.pow(primeList.get(index),pow++);
      }
      sum *= subSum;
      index++;
    }

    return (int)sum - notProper;
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 75 ms.[/java]","Problem 23: Non-abundant Sums",,"publish","closed","closed",,"p23",,,"2014-06-15 07:09:33","2014-06-15 07:09:33",,"0","http://euler.lvtran.com/?p=92","0","post",,"0"
"93","1","2014-06-11 10:18:04","2014-06-11 10:18:04","<p>A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number. 
<br><br>A number <i>n</i> is called deficient if the sum of its proper divisors is less than <i>n</i> and it is called abundant if this sum exceeds <i>n</i>.
<br><br>As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit. 
<br><br>Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.</p><!--more-->



<h2>The Catch</h2>
<p>How to efficiently find the sum of all proper divisors.
How to determine if a number can be written as a sum of 2 abundant numbers.</p>

<h2>The Light</h2>
<p>&clubs; We can certainly use the implementation in <a href=""http://lvtran.com/p21/"">Problem 21</a> to find the sum of all proper divisors. There is another	way, however, that is just as elegant: the <a href=""http://en.wikipedia.org/wiki/Prime_factor#Omega_functions"" target=""_blank"">Omega function</a>:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/23a.png"" alt=""23a"" width=""669"" height=""158"" class=""aligncenter size-full wp-image-292"" />
&nbsp;&nbsp;&nbsp;&nbsp;&diams; For example, the sum of all factors of 120 = 2<sup>3</sup> x 3 x 5 is (1 + 2 + 2<sup>3</sup> + 2<sup>3</sup>)(1 + 3)(1 + 5) = 15 x 4 x 6 = 360.<br>
&nbsp;&nbsp;&nbsp;&diams; To find the sum of all <a href=""http://mathworld.wolfram.com/ProperDivisor.html"" target=""_blank"">proper divisors,</a> subtract the original number <strong>n</strong> from the sum found above. Make some modification to the prime factorization in <a href=""http://lvtran.com/p12/"">Problem 12</a> to implement the Omega function.<br><br>
&clubs; To determine if a number can be written as the sum of 2 abundant numbers, make a boolean array of size 28,123. Create a list of abundant number up to 28,123 using the modified prime factorization method. Then make 2 for loops: the outer loops from the first abundant number <strong>a</strong> to the last one in the list and the inner loops from <strong>a</strong> to the last one in the list. If the sum of the number from these 2 loops is less than or equal to 28,123, then that sum can be written as the sum of 2 abundant numbers. Mark this number in the boolean array. When the two loops terminate, sum up all the numbers that were not marked (i.e numbers that cannot be written as the sum of 2 abundant numbers).<p>
<p>&clubs; Wolfram Alpha's <a href=""http://mathworld.wolfram.com/AbundantNumber.html"" target=""_blank"">article</a> on abundant numbers states that the upper bound is actually <strong>20,161</strong>, so use that as the upper bound instead of 28,123 (saving almost 8,000 iterations!)</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem23
{
  static List primeList = generatePrimes(20161);

  public static void main(String[] args)
  {
    List abundant = new ArrayList();
    long sum = 0;

    for(int i = 12; i &lt; 20161; i++) 	
    {
      if(sumProperDiv(i) &gt; i)
        abundant.add(new Integer(i));
    }

    boolean[] sumOfAbundant = new boolean[20161 + 1];
    for(int i = 0; i &lt; abundant.size(); i++)
    {
      for(int j = i; j &lt; abundant.size(); j++)
      {
        if(abundant.get(i) + abundant.get(j) &lt;= 20161)
    	  sumOfAbundant[abundant.get(i) + abundant.get(j)] = true;
    	else
    	  break;
      }
    }

    for(int i = 0; i &lt;= 20161; i++) 	
    {
      if(!sumOfAbundant[i])
        sum += i;
    }
    System.out.println(sum);
  }

  public static int sumProperDiv(int n)   
  {
    int notProper = n;
    int index = 0;
    double sum = 1.0;
    while(n &gt; 1)
    {
      int pow = 1;
      double subSum = 1.0;
      while(n % primeList.get(index) == 0)
      {
        n /= primeList.get(index);
    	subSum += Math.pow(primeList.get(index),pow++);
      }
      sum *= subSum;
      index++;
    }

    return (int)sum - notProper;
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 75 ms.[/java]","Problem 23: Non-abundant Sums",,"inherit","open","open",,"92-revision-v1",,,"2014-06-11 10:18:04","2014-06-11 10:18:04",,"92","http://euler.lvtran.com/92-revision-v1/","0","revision",,"0"
"94","1","2013-12-03 10:18:47","2013-12-03 10:18:47","<p>The Fibonacci sequence is defined by the recurrence relation: 
F<sub><i>n</i></sub> = F<sub><i>n</i> - 1</sub> + F<sub><i>n</i> - 2</sub>, where F<sub>1</sub> = 1 and F<sub>2</sub> = 1. Hence the first 12 terms will be:<br>
F<sub>1</sub> = 1<br>
F<sub>2</sub> = 1<br>
F<sub>3</sub> = 2<br>
F<sub>4</sub> = 3<br>
F<sub>5</sub> = 5<br>
F<sub>6</sub> = 8<br>
F<sub>7</sub> = 13<br>
F<sub>8</sub> = 21<br>
F<sub>9</sub> = 34<br>
F<sub>10</sub> = 55<br>
F<sub>11</sub> = 89<br>
F<sub>12</sub> = 144<br>
The 12th term, F<sub>12</sub>, is the first term to contain three digits. What is the first term in the Fibonacci sequence to contain 1000 digits?</p>
<!--more-->

<h2>The Catch</h2>
<p>How to efficiently generate 1,000-digit Fibonacci sequence.</p>

<h2>The Light</h2>
<p>&clubs; Of course we can use Java's <a href=""http://docs.oracle.com/javase/6/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class and iteratively generate the Fibonacci sequence until the first instance of a 1,000-digit term appears. However, such approach might take a few hundred milliseconds.<br>
<br>&clubs; The <a href=""http://mathworld.wolfram.com/FibonacciNumber.html"" target=""_blank"">article on Fibonacci Number</a> from Wolfram Alpha offers the <a href=""http://en.wikipedia.org/wiki/Jacques_Philippe_Marie_Binet"" target=""_blank"">Binet's Fibonacci Formula</a>, which offers a closed form formula for generating the Fibonacci sequence:			
<a><img src=""http://www.lvtran.com/wp-content/uploads/2014/02/25.png"" alt=""25"" width=""655"" height=""430"" class=""aligncenter size-full wp-image-300"" /></a>
Thus, finding n would give the index of the first Fibonacci number that has 1,000 digits.

<h2>The Code</h2>
[java]
public class Problem25
{
  public static void main(String[] args)
  {
    System.out.println(Math.log10(10) * 999.0 + Math.log10(5)/2)/Math.log10(1.61803398875);
  }
}
[/java]
[java]Execution time: 0 ms.[/java]","Problem 25: 1000-digit Fibonacci Number",,"publish","closed","closed",,"p25",,,"2014-06-15 07:09:34","2014-06-15 07:09:34",,"0","http://euler.lvtran.com/?p=94","0","post",,"0"
"98","1","2014-06-11 10:27:36","2014-06-11 10:27:36",,"favicon",,"inherit","open","open",,"favicon",,,"2014-06-11 10:27:36","2014-06-11 10:27:36",,"0","http://euler.lvtran.com/wp-content/uploads/2014/06/favicon.png","0","attachment","image/png","0"
"95","1","2014-06-11 10:18:47","2014-06-11 10:18:47","<p>The Fibonacci sequence is defined by the recurrence relation: 
F<sub><i>n</i></sub> = F<sub><i>n</i> - 1</sub> + F<sub><i>n</i> - 2</sub>, where F<sub>1</sub> = 1 and F<sub>2</sub> = 1. Hence the first 12 terms will be:<br>
F<sub>1</sub> = 1<br>
F<sub>2</sub> = 1<br>
F<sub>3</sub> = 2<br>
F<sub>4</sub> = 3<br>
F<sub>5</sub> = 5<br>
F<sub>6</sub> = 8<br>
F<sub>7</sub> = 13<br>
F<sub>8</sub> = 21<br>
F<sub>9</sub> = 34<br>
F<sub>10</sub> = 55<br>
F<sub>11</sub> = 89<br>
F<sub>12</sub> = 144<br>
The 12th term, F<sub>12</sub>, is the first term to contain three digits. What is the first term in the Fibonacci sequence to contain 1000 digits?</p>
<!--more-->

<h2>The Catch</h2>
<p>How to efficiently generate 1,000-digit Fibonacci sequence.</p>

<h2>The Light</h2>
<p>&clubs; Of course we can use Java's <a href=""http://docs.oracle.com/javase/6/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class and iteratively generate the Fibonacci sequence until the first instance of a 1,000-digit term appears. However, such approach might take a few hundred milliseconds.<br>
<br>&clubs; The <a href=""http://mathworld.wolfram.com/FibonacciNumber.html"" target=""_blank"">article on Fibonacci Number</a> from Wolfram Alpha offers the <a href=""http://en.wikipedia.org/wiki/Jacques_Philippe_Marie_Binet"" target=""_blank"">Binet's Fibonacci Formula</a>, which offers a closed form formula for generating the Fibonacci sequence:			
<a><img src=""http://www.lvtran.com/wp-content/uploads/2014/02/25.png"" alt=""25"" width=""655"" height=""430"" class=""aligncenter size-full wp-image-300"" /></a>
Thus, finding n would give the index of the first Fibonacci number that has 1,000 digits.

<h2>The Code</h2>
[java]
public class Problem25
{
  public static void main(String[] args)
  {
    System.out.println(Math.log10(10) * 999.0 + Math.log10(5)/2)/Math.log10(1.61803398875);
  }
}
[/java]
[java]Execution time: 0 ms.[/java]","Problem 25: 1000-digit Fibonacci Number",,"inherit","open","open",,"94-revision-v1",,,"2014-06-11 10:18:47","2014-06-11 10:18:47",,"94","http://euler.lvtran.com/94-revision-v1/","0","revision",,"0"
"85","1","2014-06-07 10:31:35","2014-06-07 10:31:35","<p>2<sup>15</sup> = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26. What is the sum of the digits of the number 2<sup>1000</sup>?</p>
<!--more-->


<h2>The Catch</h2>
<p>How to store and quickly calculate extremely large numbers.</p>

<h2>The Light</h2>
<p>Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class as discussed in <a href=""http://lvtran.com/p13"">Problem 13</a>. Then parse the result into an array of digit-character to calculate their sum.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem16
{
  public static void main(String[] args)
  {
    BigInteger n = new BigInteger(""2"");
    n = n.pow(1000);
    System.out.println(""2^1000 = "" + n);

    String s = n.toString();
    int sum = 0;
    for(int i = 0; i &lt; s.length(); i++)
    {
      sum += Character.getNumericValue(s.charAt(i));  
    }
    System.out.println(""Sum of all digits = "" + sum);
 }
}
[/java]
[java]Execution time: 51 ms.[/java]","Problem 16: Power Digit Sum",,"inherit","open","open",,"72-revision-v1",,,"2014-06-07 10:31:35","2014-06-07 10:31:35",,"72","http://euler.lvtran.com/72-revision-v1/","0","revision",,"0"
"86","1","2014-06-07 10:32:04","2014-06-07 10:32:04","<p>If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total. If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?<!--more-->


<br><b>NOTE:</b> Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of ""and"" when writing out numbers is in compliance with British usage.</p>

<h2>The Catch</h2>
<p>How to efficiently calculate the number of letters of 1,000 numbers when they are spelled out.</p>

<h2>The Light</h2>
<p>The number Divide 1,000 numbers into groups based on the similarity of their spellings:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; 1 - 20
&nbsp;&nbsp;&nbsp;&nbsp;&diams; 21 - 99
&nbsp;&nbsp;&nbsp;&nbsp;&diams; 100 - 999
Reuse the result of previous groups on the latter groups. For example, 128 (one hundred twenty eight) can use 1 (one) from the first group and 28 (twenty eight) from the second group.</p>

<h2>The Code</h2>
[java]
public class Problem17
{
  public static void main(String[] args)
  {
    String[] arr1 = new String[99];
    int arr1Index = 0;

    String[] singleD = {""one"", ""two"", ""three"", ""four"", ""five"", 
                        ""six"", ""seven"", ""eight"", ""nine""};

    String ten = ""ten"";
    String eleven = ""eleven"";
    String twelve = ""twelve"";
    String thirteen = ""thirteen"";
    String fifteen = ""fifteen"";
    String eighteen = ""eighteen"";
    String teen = ""teen"";

    String ty = ""ty"";
    String twenty = ""twenty"";
    String thirty = ""thirty"";
    String forty = ""forty"";
    String fifty = ""fifty"";
    String eighty = ""eighty"";
    String[] tens = new String[8];
    for(int j = 0; j &lt; tens.length; j++)
    {
      if(j == 0) 
      {
        tens[j] = twenty;
        continue;
      }
      if(j == 1)
      {
        tens[j] = thirty;
        continue;
      }
      if(j == 2)
      {
        tens[j] = forty;
        continue;
      }
      if(j == 3)
      {
        tens[j] = fifty;
        continue;
      }
      if(j == 6)
      {
        tens[j] = eighty;
        continue;
      }
      tens[j] = singleD[ j + 1] + ty;
    }

    String and = ""and"";
    String hundred = ""hundred"";

    //PRINT OUT THE NUMBERS 1- 20
    for(int i = 1; i &lt;= 20; i++)
    { 
      if(i &lt; 10)
        arr1[arr1Index++] = singleD[i - 1];

      if(i &gt;= 10 &amp;&amp; i &lt;= 20)
        switch(i)
        {
          case 10: arr1[arr1Index++] = ten;
                   break;
          case 11: arr1[arr1Index++] = eleven;
                   break;
          case 12: arr1[arr1Index++] = twelve;
                   break;
          case 13: arr1[arr1Index++] = thirteen;
                   break;
          case 15: arr1[arr1Index++] = fifteen;
                   break;
          case 18: arr1[arr1Index++] = eighteen;
                   break;
          case 20: arr1[arr1Index++] = twenty;
                   break;
          default: arr1[arr1Index++] = (singleD[i - 10 - 1] + teen);
                   break;
        }		
    }

    //PRINT OUT NUMBER 21 - 99
    for(int x = 21, index = 0, sIndex = 0; x &lt;= 99; x++)
    { 	 
      if(x % 10 == 0)
      {
        arr1[arr1Index++] = tens[x/10 - 2] ;
        continue;
      }

      if(x &gt; 40 &amp;&amp; x &lt; 50)
      {
        arr1[arr1Index++] = ""forty"" + singleD[sIndex++];
        if(sIndex &gt; 8 &amp;&amp; index &lt; 8)
        {
          sIndex = 0;
          index++;
        }
        continue;
      }

      if(x &gt; 80 &amp;&amp; x &lt; 90)
      {
        arr1[arr1Index++] = ""eighty"" + singleD[sIndex++];
        if(sIndex &gt; 8 &amp;&amp; index &lt; 8)
        {
          sIndex = 0;
          index++;
        }
        continue;
      }

      arr1[arr1Index++] = tens[index] + singleD[sIndex++];
      if(sIndex &gt; 8 &amp;&amp; index &lt; 8)
      {
        sIndex = 0;
        index++;
      } 	  
    }

    String[] arr2 = new String[901];
    arr2[900] = ""onethousand"";
    int arr2Index = 0;

    //PRINT OUT NUMBER 100 - 999
    for(int y = 100, index2 = 0, index3 = 0; y &lt; 1000; y++)
    {
      if(y % 100 == 0)
      {
        arr2[arr2Index++] = singleD[y/100 - 1] + hundred;
        continue;
      }

      arr2[arr2Index++] = singleD[index2] + hundred + and + arr1[index3++];
      if(index3 &gt; 98)
      {
        index3 = 0;
        index2++;
      }	  
    }

    int sum = 0;

    for(int k = 0; k &lt; arr1.length; k++)
    {
      sum += arr1[k].length();
    }
    for(int o = 0; o &lt; arr2.length; o++)
    {
      sum += arr2[o].length();
    }
    System.out.println(""The total number of characters: "" + sum);
  }
}
[/java]
[java]Execution time: 3 ms.[/java]
","Problem 17: Number Letter Counts",,"inherit","open","open",,"74-revision-v1",,,"2014-06-07 10:32:04","2014-06-07 10:32:04",,"74","http://euler.lvtran.com/74-revision-v1/","0","revision",,"0"
"87","1","2014-06-07 10:33:14","2014-06-07 10:33:14","<p>n! means n x (n - 1) x ... x 3 x 2 x 1
For example, 10! = 10 x 9 x ... x 3 x 2 x 1 = 3628800, and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.Find the sum of the digits in the number 100!</p>
<!--more-->


<h2>The Catch</h2>
<p>How to efficiently calculate factorial.
How to store an extremely large number.</p>

<h2>The Light</h2>
<p>&clubs; Factorial calculation is much more efficient using the iterative approach as opposed to the recursive one. To find <strong>x!</strong>, keep multiplying <strong>x</strong> by <strong>x - 1</strong> every time until <strong>x</strong> reaches <strong>1</strong>. That way, the factorial-finding loop is nothing but a sequence of simple multiplication, which is what computer is very good at.
<br>&clubs; Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class. Then parse the result into an array of digit-character to calculate their sum.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem20
{
  public static void main(String[] args)
  {
    BigInteger n = new BigInteger(""100"");
    BigInteger result = BigInteger.ONE;

    while(n.compareTo(BigInteger.ONE) == 1)
    {
      result =  result.multiply(n.subtract(BigInteger.ONE));
      n = n.subtract(BigInteger.ONE);
    }

    System.out.println(""Result: "" + result);

    String s = result.toString();
    char[] array = new char[s.length()];
    array = s.toCharArray();

    int sum = 0;
    for(int i = 0; i &lt; array.length; i++)
    {
      sum += Character.getNumericValue(array[i]);
    }

    System.out.println(sum);
  }
}
[/java]
[java]Execution time: 8 ms.[/java]","Problem 20: Factorial Digit Sum",,"inherit","open","open",,"81-revision-v1",,,"2014-06-07 10:33:14","2014-06-07 10:33:14",,"81","http://euler.lvtran.com/81-revision-v1/","0","revision",,"0"
"96","1","2013-12-02 10:19:13","2013-12-02 10:19:13","<p>A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:
1/2 = 0.5
1/3 = 0.(3)
1/4 = 0.25
1/5 = 0.2
1/6 = 0.1(6)
1/7 = 0.(142857)
1/8 = 0.125
1/9 = 0.(1)
1/10 = 0.1
<br>Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that <sup>1</sup>/<sub>7</sub> has a 6-digit recurring cycle. Find the value of <i>d</i> < 1000 for which <sup>1</sup>/<sub><i>d</i></sub> contains the longest recurring cycle in its decimal fraction part.</p><!--more-->



<h2>The Catch</h2>
<p>How to find the length of a recurring cycle of <sup>1</sup>/<sub><i>d</i></sub></p>

<h2>The Light</h2>
<p>An algorithm which uses modulus operation to find the length of a recurring cycle:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Take the modulus 1 % d. Call the result x.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Times x by 10.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Take the modulus x % d.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Keep track of all found values for x.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat step 2 - 3 until x repeats again or x = 0.
<br>For example, to find the recurring cycle length of 1/8:
&nbsp;&nbsp;&nbsp;&nbsp;1 % 8 = 1
&nbsp;&nbsp;&nbsp;&nbsp;10 % 8 = 2
&nbsp;&nbsp;&nbsp;&nbsp;20 % 8 = 4
&nbsp;&nbsp;&nbsp;&nbsp;40 % 8 = 0 (Stop the algorithm here; 1/8 has a recurring cycle length of 3)
</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem26
{
  public static void main(String[] args)
  {
    int count = 1; 
    int remainder = 0;
    int tmp = 10;
    int max = 0;
    int result = 0;

    for(int d = 2; d &lt; 1000; d++)
    {
      ArrayList list = new ArrayList();
      list.add(new Integer(1));
      while(true)
      {
        remainder = tmp % d;
        if(list.contains(remainder) || remainder == 0)
        {
          if(count &gt; max)
          {
            max = count;
            result = d;
          }
          count = 1;
          tmp = 10;
          break;
        }
        else
        {
          list.add(new Integer(remainder));
          tmp = remainder * 10;
          count++;
        }	
      }
    }
    System.out.println(result);
  }
}
[/java]
[java]Execution time: 175 ms.[/java]
","Problem 26: Reciprocal Cycles",,"publish","closed","closed",,"p26",,,"2014-06-15 07:09:35","2014-06-15 07:09:35",,"0","http://euler.lvtran.com/?p=96","0","post",,"0"
"97","1","2014-06-11 10:19:13","2014-06-11 10:19:13","<p>A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:
1/2 = 0.5
1/3 = 0.(3)
1/4 = 0.25
1/5 = 0.2
1/6 = 0.1(6)
1/7 = 0.(142857)
1/8 = 0.125
1/9 = 0.(1)
1/10 = 0.1
<br>Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that <sup>1</sup>/<sub>7</sub> has a 6-digit recurring cycle. Find the value of <i>d</i> < 1000 for which <sup>1</sup>/<sub><i>d</i></sub> contains the longest recurring cycle in its decimal fraction part.</p><!--more-->



<h2>The Catch</h2>
<p>How to find the length of a recurring cycle of <sup>1</sup>/<sub><i>d</i></sub></p>

<h2>The Light</h2>
<p>An algorithm which uses modulus operation to find the length of a recurring cycle:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Take the modulus 1 % d. Call the result x.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Times x by 10.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Take the modulus x % d.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Keep track of all found values for x.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat step 2 - 3 until x repeats again or x = 0.
<br>For example, to find the recurring cycle length of 1/8:
&nbsp;&nbsp;&nbsp;&nbsp;1 % 8 = 1
&nbsp;&nbsp;&nbsp;&nbsp;10 % 8 = 2
&nbsp;&nbsp;&nbsp;&nbsp;20 % 8 = 4
&nbsp;&nbsp;&nbsp;&nbsp;40 % 8 = 0 (Stop the algorithm here; 1/8 has a recurring cycle length of 3)
</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem26
{
  public static void main(String[] args)
  {
    int count = 1; 
    int remainder = 0;
    int tmp = 10;
    int max = 0;
    int result = 0;

    for(int d = 2; d &lt; 1000; d++)
    {
      ArrayList list = new ArrayList();
      list.add(new Integer(1));
      while(true)
      {
        remainder = tmp % d;
        if(list.contains(remainder) || remainder == 0)
        {
          if(count &gt; max)
          {
            max = count;
            result = d;
          }
          count = 1;
          tmp = 10;
          break;
        }
        else
        {
          list.add(new Integer(remainder));
          tmp = remainder * 10;
          count++;
        }	
      }
    }
    System.out.println(result);
  }
}
[/java]
[java]Execution time: 175 ms.[/java]
","Problem 26: Reciprocal Cycles",,"inherit","open","open",,"96-revision-v1",,,"2014-06-11 10:19:13","2014-06-11 10:19:13",,"96","http://euler.lvtran.com/96-revision-v1/","0","revision",,"0"
"100","1","2013-11-26 06:26:44","2013-11-26 06:26:44","<p>The fraction <sup>49</sup>/<sub>98</sub> is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that <sup>49</sup>/<sub>98</sub> = <sup>4</sup>/<sub>8</sub>, which is correct, is obtained by cancelling the 9s. We shall consider fractions like, <sup>30</sup>/<sub>50</sub> = <sup>3</sup>/<sub>5</sub>, to be trivial examples.
<br>There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator. 
<br>If the product of these four fractions is given in its lowest common terms, find the value of the denominator.</p><!--more-->



<h2>The Catch</h2>
<p style=""margin-right: 30px;"">How to speed up the current search range (90 * 90 = 8,100 iterations) and avoid trivial cases.<br><br>

<h2>The Light</h2>
<p style=""margin-right: 30px;"">&clubs; While looping, skip numbers that are divisible by 10 because they are trivial cases.
<br><br>&clubs; Given ab/cd, where a, b are digits of the numerator and c, d are digits of the denominator (a and b &lt; c and d), ab/cd can only be a curious fraction under one of these four circumstances:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; a = c
&nbsp;&nbsp;&nbsp;&nbsp;&diams; a = d
&nbsp;&nbsp;&nbsp;&nbsp;&diams; b = c
&nbsp;&nbsp;&nbsp;&nbsp;&diams; b = d</p>

<h2>The Code</h2>
[java]
public class Problem33
{
  public static void main(String[] args)
  {
    for(double n = 10.0; n &lt; 100.0; n++)
    {
      for(double d = 10.0; d &lt; 100.0; d++)
      {		  
        String sn = Double.toString(n);
        String sd = Double.toString(d);
        if(n &lt; d &amp;&amp; n % 10.0 != 0.0 &amp;&amp; d % 10.0 != 0.0)
        {
          double tmp = n/d;
          double tmp2 = 0.0;
          double tmpn = 0.0;
          double tmpd = 0.0; 
          if(sn.charAt(0) == (sd.charAt(0)))			   
          {
            tmpn = Character.getNumericValue(sn.charAt(1));
            tmpd = Character.getNumericValue(sd.charAt(1));
            tmp2 = tmpn/tmpd;
            if(tmp2 == tmp)
              System.out.println(n + ""/"" + d);
            continue;
          }
          if(sn.charAt(0) == (sd.charAt(1)))			   
          {
            tmpn = Character.getNumericValue(sn.charAt(1));
            tmpd = Character.getNumericValue(sd.charAt(0));
            tmp2 = tmpn/tmpd;
            if(tmp2 == tmp)
              System.out.println(n + ""/"" + d);
            continue;
          }
          if(sn.charAt(1) == (sd.charAt(0)))			   
          {
            tmpn = Character.getNumericValue(sn.charAt(0));
            tmpd = Character.getNumericValue(sd.charAt(1));
            tmp2 = tmpn/tmpd;
            if(tmp2 == tmp)
              System.out.println(n + ""/"" + d);
            continue;
          }
          if(sn.charAt(1) == (sd.charAt(1)))			   
          {
            tmpn = Character.getNumericValue(sn.charAt(0));
            tmpd = Character.getNumericValue(sd.charAt(0));
            tmp2 = tmpn/tmpd;
            if(tmp2 == tmp)
              System.out.println(n + ""/"" + d);
            continue;
          }		
        }
      }
    }
  }
}
[/java]
<p>After execution, 4 fractions are found: 16/64, 19/95, 26/65, 49/98. Their products = 387296/38729600 = <strong>1/100</strong></p>
[java]Execution time: 55 ms. [/java]","Problem 33: Digit Canceling Fractions",,"publish","closed","closed",,"p33",,,"2014-06-15 07:09:37","2014-06-15 07:09:37",,"0","http://euler.lvtran.com/?p=100","0","post",,"0"
"101","1","2014-06-15 06:26:44","2014-06-15 06:26:44","<p>The fraction <sup>49</sup>/<sub>98</sub> is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that <sup>49</sup>/<sub>98</sub> = <sup>4</sup>/<sub>8</sub>, which is correct, is obtained by cancelling the 9s. We shall consider fractions like, <sup>30</sup>/<sub>50</sub> = <sup>3</sup>/<sub>5</sub>, to be trivial examples.
<br>There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator. 
<br>If the product of these four fractions is given in its lowest common terms, find the value of the denominator.</p><!--more-->



<h2>The Catch</h2>
<p style=""margin-right: 30px;"">How to speed up the current search range (90 * 90 = 8,100 iterations) and avoid trivial cases.<br><br>

<h2>The Light</h2>
<p style=""margin-right: 30px;"">&clubs; While looping, skip numbers that are divisible by 10 because they are trivial cases.
<br><br>&clubs; Given ab/cd, where a, b are digits of the numerator and c, d are digits of the denominator (a and b &lt; c and d), ab/cd can only be a curious fraction under one of these four circumstances:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; a = c
&nbsp;&nbsp;&nbsp;&nbsp;&diams; a = d
&nbsp;&nbsp;&nbsp;&nbsp;&diams; b = c
&nbsp;&nbsp;&nbsp;&nbsp;&diams; b = d</p>

<h2>The Code</h2>
[java]
public class Problem33
{
  public static void main(String[] args)
  {
    for(double n = 10.0; n &lt; 100.0; n++)
    {
      for(double d = 10.0; d &lt; 100.0; d++)
      {		  
        String sn = Double.toString(n);
        String sd = Double.toString(d);
        if(n &lt; d &amp;&amp; n % 10.0 != 0.0 &amp;&amp; d % 10.0 != 0.0)
        {
          double tmp = n/d;
          double tmp2 = 0.0;
          double tmpn = 0.0;
          double tmpd = 0.0; 
          if(sn.charAt(0) == (sd.charAt(0)))			   
          {
            tmpn = Character.getNumericValue(sn.charAt(1));
            tmpd = Character.getNumericValue(sd.charAt(1));
            tmp2 = tmpn/tmpd;
            if(tmp2 == tmp)
              System.out.println(n + ""/"" + d);
            continue;
          }
          if(sn.charAt(0) == (sd.charAt(1)))			   
          {
            tmpn = Character.getNumericValue(sn.charAt(1));
            tmpd = Character.getNumericValue(sd.charAt(0));
            tmp2 = tmpn/tmpd;
            if(tmp2 == tmp)
              System.out.println(n + ""/"" + d);
            continue;
          }
          if(sn.charAt(1) == (sd.charAt(0)))			   
          {
            tmpn = Character.getNumericValue(sn.charAt(0));
            tmpd = Character.getNumericValue(sd.charAt(1));
            tmp2 = tmpn/tmpd;
            if(tmp2 == tmp)
              System.out.println(n + ""/"" + d);
            continue;
          }
          if(sn.charAt(1) == (sd.charAt(1)))			   
          {
            tmpn = Character.getNumericValue(sn.charAt(0));
            tmpd = Character.getNumericValue(sd.charAt(0));
            tmp2 = tmpn/tmpd;
            if(tmp2 == tmp)
              System.out.println(n + ""/"" + d);
            continue;
          }		
        }
      }
    }
  }
}
[/java]
<p>After execution, 4 fractions are found: 16/64, 19/95, 26/65, 49/98. Their products = 387296/38729600 = <strong>1/100</strong></p>
[java]Execution time: 55 ms. [/java]","Problem 33: Digit Canceling Fractions",,"inherit","open","open",,"100-revision-v1",,,"2014-06-15 06:26:44","2014-06-15 06:26:44",,"100","http://euler.lvtran.com/100-revision-v1/","0","revision",,"0"
"102","1","2013-11-27 06:27:22","2013-11-27 06:27:22","<p>Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:
<br>1634 = 1<sup>4</sup> + 6<sup>4</sup> + 3<sup>4</sup> + 4<sup>4</sup>
8208 = 8<sup>4</sup> + 2<sup>4</sup> + 0<sup>4</sup> + 8<sup>4</sup>
9474 = 9<sup>4</sup> + 4<sup>4</sup> + 7<sup>4</sup> + 4<sup>4</sup>
<p>As 1 = 1<sup>4</sup> is not a sum it is not included. The sum of these numbers is 1634 + 8208 + 9474 = 19316. Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.</p>
<!--more-->


<h2>The Catch</h2>
<p style=""margin-right: 30px;"">How to find the upper bound, or the stop point for checking if numbers can be written as the sum of fifth powers of their digits.<br><br>

<h2>The Light</h2>
<p style=""margin-right: 30px;"">&clubs; The lowest 4-digit number is 1,000, maximum digit-5th power sum is 9<sup>5</sup> * 4 = 236,196. That means out of all 4-digit numbers, there are some numbers that can be written as the sum of fifth power of their digits (1,000 &lt; 236,196).<br><br>
&clubs; The lowest 5-digit number is 10,000, maximum digit-5th power sum is 9<sup>5</sup> * 5 = 295,245. That means out of all 5-digit numbers, there are some numbers that can be written as the sum of fifth power of their digits (10,000 &lt; 295,245).<br><br>
&clubs; The lowest 6-digit number is 100,000, maximum digit-5th power sum is 9<sup>5</sup> * 6 = 354,294. That means out of all 5-digit numbers, there are some numbers that can be written as the sum of fifth power of their digits (100,000 &lt; 354,294).<br><br>
&clubs; The lowest 7-digit is 1,000,000, but their maximum digit-5th power sum only goes up to 9<sup>5</sup> * 7 = 413,343. This indicates all 7-digit numbers cannot be written as the sum of fifth power of their digits (1,000,000 &gt; 413,343. Since all 7-digit numbers are not valid, any numbers with more digits are also invalid. Thus, the 6-digit number can be a reasonable boundary. Upper limit is 9<sup>5</sup> * 6 = <strong>354,294</strong>.</p><br><br>

<h2>The Code</h2>
[java]
public class Problem30
{
  public static void main(String[] args)
  {
    int sum = 0;
    for(int i = 10; i &lt; 354294; i++)
    {
      String s = Integer.toString(i);
      int tmpSum = 0;

      for(int y = 0; y &lt; s.length(); y++)
      {
        tmpSum += (Character.getNumericValue(s.charAt(y)) *
                   Character.getNumericValue(s.charAt(y)) *
                   Character.getNumericValue(s.charAt(y)) *
                   Character.getNumericValue(s.charAt(y)) *
                   Character.getNumericValue(s.charAt(y)));  
      }

      if(tmpSum == i)
        sum += i;	  
    }
    System.out.println(sum);
  }
}
[/java]
[java]Execution time: 55 ms.[/java]
","Problem 30: Digit Fifth Powers",,"publish","closed","closed",,"p30",,,"2014-06-15 07:09:36","2014-06-15 07:09:36",,"0","http://euler.lvtran.com/?p=102","0","post",,"0"
"103","1","2014-06-15 06:27:22","2014-06-15 06:27:22","<p>Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:
<br>1634 = 1<sup>4</sup> + 6<sup>4</sup> + 3<sup>4</sup> + 4<sup>4</sup>
8208 = 8<sup>4</sup> + 2<sup>4</sup> + 0<sup>4</sup> + 8<sup>4</sup>
9474 = 9<sup>4</sup> + 4<sup>4</sup> + 7<sup>4</sup> + 4<sup>4</sup>
<p>As 1 = 1<sup>4</sup> is not a sum it is not included. The sum of these numbers is 1634 + 8208 + 9474 = 19316. Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.</p>
<!--more-->


<h2>The Catch</h2>
<p style=""margin-right: 30px;"">How to find the upper bound, or the stop point for checking if numbers can be written as the sum of fifth powers of their digits.<br><br>

<h2>The Light</h2>
<p style=""margin-right: 30px;"">&clubs; The lowest 4-digit number is 1,000, maximum digit-5th power sum is 9<sup>5</sup> * 4 = 236,196. That means out of all 4-digit numbers, there are some numbers that can be written as the sum of fifth power of their digits (1,000 &lt; 236,196).<br><br>
&clubs; The lowest 5-digit number is 10,000, maximum digit-5th power sum is 9<sup>5</sup> * 5 = 295,245. That means out of all 5-digit numbers, there are some numbers that can be written as the sum of fifth power of their digits (10,000 &lt; 295,245).<br><br>
&clubs; The lowest 6-digit number is 100,000, maximum digit-5th power sum is 9<sup>5</sup> * 6 = 354,294. That means out of all 5-digit numbers, there are some numbers that can be written as the sum of fifth power of their digits (100,000 &lt; 354,294).<br><br>
&clubs; The lowest 7-digit is 1,000,000, but their maximum digit-5th power sum only goes up to 9<sup>5</sup> * 7 = 413,343. This indicates all 7-digit numbers cannot be written as the sum of fifth power of their digits (1,000,000 &gt; 413,343. Since all 7-digit numbers are not valid, any numbers with more digits are also invalid. Thus, the 6-digit number can be a reasonable boundary. Upper limit is 9<sup>5</sup> * 6 = <strong>354,294</strong>.</p><br><br>

<h2>The Code</h2>
[java]
public class Problem30
{
  public static void main(String[] args)
  {
    int sum = 0;
    for(int i = 10; i &lt; 354294; i++)
    {
      String s = Integer.toString(i);
      int tmpSum = 0;

      for(int y = 0; y &lt; s.length(); y++)
      {
        tmpSum += (Character.getNumericValue(s.charAt(y)) *
                   Character.getNumericValue(s.charAt(y)) *
                   Character.getNumericValue(s.charAt(y)) *
                   Character.getNumericValue(s.charAt(y)) *
                   Character.getNumericValue(s.charAt(y)));  
      }

      if(tmpSum == i)
        sum += i;	  
    }
    System.out.println(sum);
  }
}
[/java]
[java]Execution time: 55 ms.[/java]
","Problem 30: Digit Fifth Powers",,"inherit","open","open",,"102-revision-v1",,,"2014-06-15 06:27:22","2014-06-15 06:27:22",,"102","http://euler.lvtran.com/102-revision-v1/","0","revision",,"0"
"104","1","2013-11-28 06:27:52","2013-11-28 06:27:52","<p>Consider all integer combinations of <i>a</i><sup><i>b</i></sup> for 2 &le; <i>a</i> &le; 5 and 2 &le; <i>b</i> &le; 5:
<br>2<sup>2</sup>=4, 2<sup>3</sup>=8, 2<sup>4</sup>=16, 2<sup>5</sup>=32
3<sup>2</sup>=9, 3<sup>3</sup>=27, 3<sup>4</sup>=81, 3<sup>5</sup>=243
4<sup>2</sup>=16, 4<sup>3</sup>=64, 4<sup>4</sup>=256, 4<sup>5</sup>=1024
5<sup>2</sup>=25, 5<sup>3</sup>=125, 5<sup>4</sup>=625, 5<sup>5</sup>=3125
<br>If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms: 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125. How many distinct terms are in the sequence generated by <i>a</i><sup><i>b</i></sup> for 2 &le;<i>a</i> &le; 100 and 2 &le; <i>b</i> &le; 100?</p><!--more-->



<h2>The Catch</h2>
<p>How to store found terms and filter out duplicates so that all terms are distinct.</p>

<h2>The Light</h2>
<p>In mathematics, a <a href=""http://en.wikipedia.org/wiki/Set_(mathematics)"" target=""_blank"">set</a> is a collection of distinct objects. Use Java's <a href=""http://docs.oracle.com/javase/6/docs/api/java/util/TreeSet.html"" target=""_blank"">TreeSet </a>class to store a collection of distinct elements and <a href=""http://docs.oracle.com/javase/6/docs/api/java/lang/Math.html"" target=""_blank"">Math </a>class for exponent operation. There is no need to sort the set because all the problem is asking for is the number of distinct elements, or the set's size.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem29
{
  public static void main(String[] args)
  {
    TreeSet unique = new TreeSet();
    for(double a = 2; a &lt;= 100.0; a += 1.0)
    {
      for(double b = 2; b &lt;= 100.0; b += 1.0)
      {
        double tmp = Math.pow(a,b);
      	unique.add(tmp);
      }
    }
    System.out.println(unique.size());
  }
}
[/java]
[java]Execution time: 20 ms.[/java]","Problem 29: Distinct Powers",,"publish","closed","closed",,"p29",,,"2014-06-15 07:09:36","2014-06-15 07:09:36",,"0","http://euler.lvtran.com/?p=104","0","post",,"0"
"105","1","2014-06-15 06:27:52","2014-06-15 06:27:52","<p>Consider all integer combinations of <i>a</i><sup><i>b</i></sup> for 2 &le; <i>a</i> &le; 5 and 2 &le; <i>b</i> &le; 5:
<br>2<sup>2</sup>=4, 2<sup>3</sup>=8, 2<sup>4</sup>=16, 2<sup>5</sup>=32
3<sup>2</sup>=9, 3<sup>3</sup>=27, 3<sup>4</sup>=81, 3<sup>5</sup>=243
4<sup>2</sup>=16, 4<sup>3</sup>=64, 4<sup>4</sup>=256, 4<sup>5</sup>=1024
5<sup>2</sup>=25, 5<sup>3</sup>=125, 5<sup>4</sup>=625, 5<sup>5</sup>=3125
<br>If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms: 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125. How many distinct terms are in the sequence generated by <i>a</i><sup><i>b</i></sup> for 2 &le;<i>a</i> &le; 100 and 2 &le; <i>b</i> &le; 100?</p><!--more-->



<h2>The Catch</h2>
<p>How to store found terms and filter out duplicates so that all terms are distinct.</p>

<h2>The Light</h2>
<p>In mathematics, a <a href=""http://en.wikipedia.org/wiki/Set_(mathematics)"" target=""_blank"">set</a> is a collection of distinct objects. Use Java's <a href=""http://docs.oracle.com/javase/6/docs/api/java/util/TreeSet.html"" target=""_blank"">TreeSet </a>class to store a collection of distinct elements and <a href=""http://docs.oracle.com/javase/6/docs/api/java/lang/Math.html"" target=""_blank"">Math </a>class for exponent operation. There is no need to sort the set because all the problem is asking for is the number of distinct elements, or the set's size.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem29
{
  public static void main(String[] args)
  {
    TreeSet unique = new TreeSet();
    for(double a = 2; a &lt;= 100.0; a += 1.0)
    {
      for(double b = 2; b &lt;= 100.0; b += 1.0)
      {
        double tmp = Math.pow(a,b);
      	unique.add(tmp);
      }
    }
    System.out.println(unique.size());
  }
}
[/java]
[java]Execution time: 20 ms.[/java]","Problem 29: Distinct Powers",,"inherit","open","open",,"104-revision-v1",,,"2014-06-15 06:27:52","2014-06-15 06:27:52",,"104","http://euler.lvtran.com/104-revision-v1/","0","revision",,"0"
"106","1","2013-11-29 06:28:24","2013-11-29 06:28:24","<p>Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/28a.png"" alt=""28a"" width=""149"" height=""104"" class=""aligncenter size-full wp-image-314"" />
<p>It can be verified that the sum of the numbers on the diagonals is 101. What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?</p><!--more-->



<h2>The Catch</h2>
<p>Discover the pattern that generates the numbers that lay on the 2 diagonals.</p>

<h2>The Light</h2>
<p>Take a look at a smaller square:<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/28b.png"" alt=""28b"" width=""75"" height=""54"" class=""aligncenter size-full wp-image-315"" />
This is a 3 x 3 square with side equals 3. Notice that the top-right corner number <strong>a</strong> can be computed using the formula <strong>a</strong> = <strong> (2*i + 1)</strong><sup><strong>2</strong> </sup>where <strong>i</strong> &gt;= 1. Starting with <strong>i</strong> = 1, a = (2*1 + 1)<sup>2</sup> = 9.
<br>Then, notice that the top-left corner number <strong>b </strong>can be computed using the formula <strong>b</strong> = <strong>a</strong> - 2*<strong>i</strong> with the same i that formulated <strong>a</strong>. So <strong>b</strong> = 9 - 2*1 = 7.
<br>Similarly, bottom-left corner number <strong>c</strong> can be computed using <strong>c = b - 2*i</strong> with the same <strong>i</strong> that formulated<strong> b</strong>. So <strong>c</strong> = 7 - 2*1 = 5.
<br>Lastly, bottom-right corner number <strong>d</strong> can be computed using <strong>d = c - 2*i</strong> with the same <strong>i</strong> that formulated <strong>c</strong>. So <strong>d</strong> = 5 - 2*1 = 3.
<br>With the 3 x 3 square, <strong>i</strong> increments to 1. If you repeat this pattern for the 5 x 5 square<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/28a.png"" alt=""28a"" width=""149"" height=""104"" class=""aligncenter size-full wp-image-314"" /> the number <strong>i </strong>increments to 2. Due to the spiral nature of these n x n squares, n cannot be even. Thus <strong>i</strong> only increments to n/2, dropping all decimals.</p>

<h2>The Code</h2>
[java]
public class Problem28
{
  public static void main(String[] args)
  {
    int total = 1;                     //Sequence starts with 1, the ring number
    int width = 1001/2;                  
    for(int i = 1; i &lt;= width; i++)
    {
      int tmp = (2*i + 1) * (2*i + 1);
      total += tmp;

      //Moving counter clockwise
      tmp = tmp - 2*i;
      total += tmp;

      tmp = tmp - 2*i;
      total += tmp;

      tmp = tmp - 2*i;
      total += tmp;
    }
    System.out.println(total);
  }
}
[/java]
[java]Execution time: 0 ms.[/java]","Problem 28: Number Spiral Diagonals",,"publish","closed","closed",,"p28",,,"2014-06-15 07:09:35","2014-06-15 07:09:35",,"0","http://euler.lvtran.com/?p=106","0","post",,"0"
"107","1","2014-06-15 06:28:24","2014-06-15 06:28:24","<p>Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/28a.png"" alt=""28a"" width=""149"" height=""104"" class=""aligncenter size-full wp-image-314"" />
<p>It can be verified that the sum of the numbers on the diagonals is 101. What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?</p><!--more-->



<h2>The Catch</h2>
<p>Discover the pattern that generates the numbers that lay on the 2 diagonals.</p>

<h2>The Light</h2>
<p>Take a look at a smaller square:<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/28b.png"" alt=""28b"" width=""75"" height=""54"" class=""aligncenter size-full wp-image-315"" />
This is a 3 x 3 square with side equals 3. Notice that the top-right corner number <strong>a</strong> can be computed using the formula <strong>a</strong> = <strong> (2*i + 1)</strong><sup><strong>2</strong> </sup>where <strong>i</strong> &gt;= 1. Starting with <strong>i</strong> = 1, a = (2*1 + 1)<sup>2</sup> = 9.
<br>Then, notice that the top-left corner number <strong>b </strong>can be computed using the formula <strong>b</strong> = <strong>a</strong> - 2*<strong>i</strong> with the same i that formulated <strong>a</strong>. So <strong>b</strong> = 9 - 2*1 = 7.
<br>Similarly, bottom-left corner number <strong>c</strong> can be computed using <strong>c = b - 2*i</strong> with the same <strong>i</strong> that formulated<strong> b</strong>. So <strong>c</strong> = 7 - 2*1 = 5.
<br>Lastly, bottom-right corner number <strong>d</strong> can be computed using <strong>d = c - 2*i</strong> with the same <strong>i</strong> that formulated <strong>c</strong>. So <strong>d</strong> = 5 - 2*1 = 3.
<br>With the 3 x 3 square, <strong>i</strong> increments to 1. If you repeat this pattern for the 5 x 5 square<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/28a.png"" alt=""28a"" width=""149"" height=""104"" class=""aligncenter size-full wp-image-314"" /> the number <strong>i </strong>increments to 2. Due to the spiral nature of these n x n squares, n cannot be even. Thus <strong>i</strong> only increments to n/2, dropping all decimals.</p>

<h2>The Code</h2>
[java]
public class Problem28
{
  public static void main(String[] args)
  {
    int total = 1;                     //Sequence starts with 1, the ring number
    int width = 1001/2;                  
    for(int i = 1; i &lt;= width; i++)
    {
      int tmp = (2*i + 1) * (2*i + 1);
      total += tmp;

      //Moving counter clockwise
      tmp = tmp - 2*i;
      total += tmp;

      tmp = tmp - 2*i;
      total += tmp;

      tmp = tmp - 2*i;
      total += tmp;
    }
    System.out.println(total);
  }
}
[/java]
[java]Execution time: 0 ms.[/java]","Problem 28: Number Spiral Diagonals",,"inherit","open","open",,"106-revision-v1",,,"2014-06-15 06:28:24","2014-06-15 06:28:24",,"106","http://euler.lvtran.com/106-revision-v1/","0","revision",,"0"
"108","1","2013-11-30 06:29:22","2013-11-30 06:29:22","<p style=""margin-right: 30px;"">Euler discovered the remarkable quadratic formula: <strong><i>n<sup>2</sup></i> + <i>n</i> + 41</strong>. It turns out that the formula will produce 40 primes for the consecutive values <i>n</i> = 0 to 39. However, when <i>n</i> = 40, 40<sup>2</sup> + 40 + 41 = 40(40 + 1) + 41 is divisible by 41, and certainly when <i>n</i> = 41, 41<sup>2</sup>	+ 41 + 41 is clearly divisible by 41.
<br>The incredible formula <strong><i>n<sup>2</sup></i> - 79<i>n</i> + 1601</strong> was discovered, which produces 80 primes for the consecutive values <i>n</i> = 0 to 79. The product of the coefficients, -79 and 1601, is -126479.			
<br>Considering quadratics of the form: <strong><i>n<sup>2</sup></i> + <i>an</i> + <i>b</i></strong>, where <strong>|<i>a</i>| < 1000</strong> and <strong>|<i>b</i>| < 1000</strong>, where <strong>|<i>n</i>|</strong> is the modulus/absolute value of <i>n</i> (e.g. |11| = 11 and |-4| = 4). 
<br>Find the product of the coefficients, <i>a</i> and <i>b</i>, for the quadratic expression that produces the maximum number of primes for consecutive values of <i>n</i>, starting with <i>n</i> = 0.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to speed up the search from <strong>|<i>a</i>| < 1000</strong> and <strong>|<i>b</i>| < 1000.</strong> That is looping from -999 to 999 for a and b, totaling 1999 * 1999 = 3,996,001 iterations!</p>

<h2>The Light</h2>
<p>By doing a little mathematical analysis, it is obvious that for n = 0, n<sup>2</sup> + an + b = 0<sup>2</sup> + 0 + b = b. Since this function must return a prime number, b must be prime. 	Thus, we can skip all non-prime values for b and keep track of the streak. It can be shown that this simple tweak lowers the number of iterations to 355,822. Use the prime checking method discussed in <a href=""http://lvtran.com/p3/"">Problem 3</a> to check for prime number.</p>

<h2>The Code</h2>
[java]
public class Problem27
{
  public static void main(String[] args)
  {
    int maxA = 0, maxB = 0 , maxN = 0;
    int count = 0;

    for(int a = -999; a &lt; 1000; a++)
    {
      for(int b = -999; b &lt; 1000; b++)
      {
        if(!isPrime(b))
          continue;

        int n = 0;
        while(isPrime( n*n + a*n + b )) 		
        {
          n++;
        }

        if(n &gt; maxN)
        {
          maxN = n;
          maxA = a;
          maxB = b;
        }
      }
    }
    System.out.println(""a * b = "" + (maxA * maxB));
  }

  public static boolean isPrime(int n)
  {
    if( n &lt; 2 )
      return false;

    if(n % 2 == 0 &amp;&amp; n != 2)
      return false;

    for(int i = 3; i * i &lt; n; i++)
    {
      if(n % i == 0)
        return false;
    }
    return true;
  }
}
[/java]
[java]Execution time: 79 ms.[/java]","Problem 27: Quadratic Primes",,"publish","closed","closed",,"p27",,,"2014-06-15 07:09:35","2014-06-15 07:09:35",,"0","http://euler.lvtran.com/?p=108","0","post",,"0"
"109","1","2014-06-15 06:29:22","2014-06-15 06:29:22","<p style=""margin-right: 30px;"">Euler discovered the remarkable quadratic formula: <strong><i>n<sup>2</sup></i> + <i>n</i> + 41</strong>. It turns out that the formula will produce 40 primes for the consecutive values <i>n</i> = 0 to 39. However, when <i>n</i> = 40, 40<sup>2</sup> + 40 + 41 = 40(40 + 1) + 41 is divisible by 41, and certainly when <i>n</i> = 41, 41<sup>2</sup>	+ 41 + 41 is clearly divisible by 41.
<br>The incredible formula <strong><i>n<sup>2</sup></i> - 79<i>n</i> + 1601</strong> was discovered, which produces 80 primes for the consecutive values <i>n</i> = 0 to 79. The product of the coefficients, -79 and 1601, is -126479.			
<br>Considering quadratics of the form: <strong><i>n<sup>2</sup></i> + <i>an</i> + <i>b</i></strong>, where <strong>|<i>a</i>| < 1000</strong> and <strong>|<i>b</i>| < 1000</strong>, where <strong>|<i>n</i>|</strong> is the modulus/absolute value of <i>n</i> (e.g. |11| = 11 and |-4| = 4). 
<br>Find the product of the coefficients, <i>a</i> and <i>b</i>, for the quadratic expression that produces the maximum number of primes for consecutive values of <i>n</i>, starting with <i>n</i> = 0.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to speed up the search from <strong>|<i>a</i>| < 1000</strong> and <strong>|<i>b</i>| < 1000.</strong> That is looping from -999 to 999 for a and b, totaling 1999 * 1999 = 3,996,001 iterations!</p>

<h2>The Light</h2>
<p>By doing a little mathematical analysis, it is obvious that for n = 0, n<sup>2</sup> + an + b = 0<sup>2</sup> + 0 + b = b. Since this function must return a prime number, b must be prime. 	Thus, we can skip all non-prime values for b and keep track of the streak. It can be shown that this simple tweak lowers the number of iterations to 355,822. Use the prime checking method discussed in <a href=""http://lvtran.com/p3/"">Problem 3</a> to check for prime number.</p>

<h2>The Code</h2>
[java]
public class Problem27
{
  public static void main(String[] args)
  {
    int maxA = 0, maxB = 0 , maxN = 0;
    int count = 0;

    for(int a = -999; a &lt; 1000; a++)
    {
      for(int b = -999; b &lt; 1000; b++)
      {
        if(!isPrime(b))
          continue;

        int n = 0;
        while(isPrime( n*n + a*n + b )) 		
        {
          n++;
        }

        if(n &gt; maxN)
        {
          maxN = n;
          maxA = a;
          maxB = b;
        }
      }
    }
    System.out.println(""a * b = "" + (maxA * maxB));
  }

  public static boolean isPrime(int n)
  {
    if( n &lt; 2 )
      return false;

    if(n % 2 == 0 &amp;&amp; n != 2)
      return false;

    for(int i = 3; i * i &lt; n; i++)
    {
      if(n % i == 0)
        return false;
    }
    return true;
  }
}
[/java]
[java]Execution time: 79 ms.[/java]","Problem 27: Quadratic Primes",,"inherit","open","open",,"108-revision-v1",,,"2014-06-15 06:29:22","2014-06-15 06:29:22",,"108","http://euler.lvtran.com/108-revision-v1/","0","revision",,"0"
"110","1","2013-11-16 06:33:25","2013-11-16 06:33:25","<p>If <i>p</i> is the perimeter of a right angle triangle with integral length sides, {<i>a</i>,<i>b</i>,<i>c</i>}, there are exactly three solutions for <i>p</i> = 120: {20,48,52}, {24,45,51}, {30,40,50}. 
<br>For which value of <i>p</i> &le; 1000, is the number of solutions maximized?</p>
<!--more-->


<h2>The Catch</h2>
<p>For every value of p, how to find and check different values of the 3 sides a, b, c of a right triangle.</p>

<h2>The Light</h2>
<p>The 3 sides a, b, and c are related under a<sup>2</sup> + b<sup>2</sup> = c<sup>2 </sup>(<a href=""http://en.wikipedia.org/wiki/Pythagorean_theorem"" target=""_blank"">Pythagorean theorem</a>) and a + b + c = p. Taking advantage of these 2 equations, we have:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/39.png"" alt=""39"" width=""474"" height=""514"" class=""aligncenter size-full wp-image-373"" />
<p>So if b is an integer, that means a, b, and c are one of p's Pythagorean triplets.</p>
<p>Recall:
Sum of 2 odd numbers is even.
Sum of 2 even numbers is even.
Sum of an odd and an even number is odd.
Product of 2 odd numbers is odd.
Product of 2 even numbers is even.
Product of an odd and an even number is even.

<p>Analyzing a<sup>2</sup> + b<sup>2</sup> = c<sup>2 </sup>show that:
If a and b are both even, then c is even and p is even.
If a and b are both odd, then c is even and p is even.
If either of a or b is even and the other is odd, then c is odd and p is even.</p>

<p>Thus, <strong>only even values for p have Pythagorean triplets.</strong></p>
<p>Since a &le; b &lt; c, <strong>a &lt; p/3</strong> because if you divide p into 3 parts, c has to always be greater than the sum of a and b.</p>
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/39b.png"" alt=""39b"" width=""455"" height=""79"" class=""aligncenter size-full wp-image-374"" />

<h2>The Code</h2>
[java]
public class Problem39
{
  public static void main(String[] args)
  {
    int max = 0;
    int maxP = 0;
    for(int p = 2; p &lt;= 1000; p += 2)
    {
      int solution = 0;
      for(int a = 1; a &lt; p/3; a++)       
      {
        if((p*p - 2*p*a) % (2*p - 2*a) == 0)     	  
          solution++;       
      }
      if(solution &gt; max)
      {
        max = solution;
        maxP = p;
      }
    }
    System.out.println(maxP);
  }
}
[/java]
[java]Execution time: 2 ms.[/java]","Problem 39: Integer Right Triangles",,"publish","closed","closed",,"p39",,,"2014-06-15 07:09:39","2014-06-15 07:09:39",,"0","http://euler.lvtran.com/?p=110","0","post",,"0"
"111","1","2014-06-15 06:33:25","2014-06-15 06:33:25","<p>If <i>p</i> is the perimeter of a right angle triangle with integral length sides, {<i>a</i>,<i>b</i>,<i>c</i>}, there are exactly three solutions for <i>p</i> = 120: {20,48,52}, {24,45,51}, {30,40,50}. 
<br>For which value of <i>p</i> &le; 1000, is the number of solutions maximized?</p>
<!--more-->


<h2>The Catch</h2>
<p>For every value of p, how to find and check different values of the 3 sides a, b, c of a right triangle.</p>

<h2>The Light</h2>
<p>The 3 sides a, b, and c are related under a<sup>2</sup> + b<sup>2</sup> = c<sup>2 </sup>(<a href=""http://en.wikipedia.org/wiki/Pythagorean_theorem"" target=""_blank"">Pythagorean theorem</a>) and a + b + c = p. Taking advantage of these 2 equations, we have:
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/39.png"" alt=""39"" width=""474"" height=""514"" class=""aligncenter size-full wp-image-373"" />
<p>So if b is an integer, that means a, b, and c are one of p's Pythagorean triplets.</p>
<p>Recall:
Sum of 2 odd numbers is even.
Sum of 2 even numbers is even.
Sum of an odd and an even number is odd.
Product of 2 odd numbers is odd.
Product of 2 even numbers is even.
Product of an odd and an even number is even.

<p>Analyzing a<sup>2</sup> + b<sup>2</sup> = c<sup>2 </sup>show that:
If a and b are both even, then c is even and p is even.
If a and b are both odd, then c is even and p is even.
If either of a or b is even and the other is odd, then c is odd and p is even.</p>

<p>Thus, <strong>only even values for p have Pythagorean triplets.</strong></p>
<p>Since a &le; b &lt; c, <strong>a &lt; p/3</strong> because if you divide p into 3 parts, c has to always be greater than the sum of a and b.</p>
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/39b.png"" alt=""39b"" width=""455"" height=""79"" class=""aligncenter size-full wp-image-374"" />

<h2>The Code</h2>
[java]
public class Problem39
{
  public static void main(String[] args)
  {
    int max = 0;
    int maxP = 0;
    for(int p = 2; p &lt;= 1000; p += 2)
    {
      int solution = 0;
      for(int a = 1; a &lt; p/3; a++)       
      {
        if((p*p - 2*p*a) % (2*p - 2*a) == 0)     	  
          solution++;       
      }
      if(solution &gt; max)
      {
        max = solution;
        maxP = p;
      }
    }
    System.out.println(maxP);
  }
}
[/java]
[java]Execution time: 2 ms.[/java]","Problem 39: Integer Right Triangles",,"inherit","open","open",,"110-revision-v1",,,"2014-06-15 06:33:25","2014-06-15 06:33:25",,"110","http://euler.lvtran.com/110-revision-v1/","0","revision",,"0"
"112","1","2013-11-17 06:33:51","2013-11-17 06:33:51","<p>Take the number 192 and multiply it by each of 1, 2, and 3:
<br>192 x 1 = 192
192 x 2 = 384
192 x 3 = 576
<br>By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3). The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and (1,2,3,4,5). 			
<br>What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , <var>n</var>) where <var>n</var> > 1?</p>
<!--more-->


<h2>The Catch</h2>
<p style=""margin-right: 30px;"">How to find the optimal range of a candidate number<strong> c</strong>, which is to be multiplied with (1, 2, ... n) where <strong>n</strong> &gt; 1 to form the concatenated-product-pandigital number.
How to check if a number is pandigital.</p>

<h2>The Light</h2>
<p>&clubs; The desired pandigital number <strong>p</strong> has to have 9 digits from 1-9, exactly once each. A candidate number <strong>c</strong> has to be multiplied with 1 to strong>n</strong>, with <strong>n &gt; 1</strong>. The products are then concatenated to form <strong>p</strong>. Define the notation <strong>(a)(b)</strong> to be ""<strong>a</strong> concatenates<strong> b</strong>"", or <strong>ab</strong>. To find the range of <strong>c</strong>, observe:
<br>&diams; <strong>c</strong> has to have less than 5 digits because the smallest 5-digit number is 10,000 and the smallest possible value for <strong>n</strong> is 2 (n &gt; 1). This gives (10,000 * 1)(10,000 * 2) = 1,000,020,000, which has 10 digits and thus does not satisfy the 9-digit condition. Thus <strong>c</strong> &lt; 10,000.
&diams; We were given to start with 9, so <strong>c</strong> has to start with 9. Thus 9 &lt;=<strong> c</strong> &lt; 9,999.
&diams; If<strong> c</strong> has 2 digits, its lowest value is 90. Assume <strong>n = 2</strong> (lowest possible value), (90 * 1)(90 * 2) = 90,180, which does not satisfy the 9-digit condition. <strong>n = 3</strong> gives 90,180,270 and <strong>n = 4</strong> gives 90,180,270,360, both of which do not satisfy the 9-digit condition. Thus 90 &lt;= <strong>c</strong> &lt; 9,999.
&diams; If <strong>c</strong> has 3 digits, its lowest value is 900. Assume <strong>n = 2</strong> (lowest possible value), (900 * 1)(900 * 2) = 9,001,800, which does not satisfy the 9-digit condition. <strong>n = 3</strong> gives 90,018,002,700 and <strong>n = 4</strong> gives 900,180,027,003,600 both of which do not satisfy the 9-digit condition. Thus 900 &lt;= <strong>c</strong> &lt; 9,999.
&diams; If <strong>c</strong> has 4 digits, its lowest value is 9,000. Assume <strong>n = 2</strong> (lowest possible value), (9,000 * 1)(9,000 * 2) = 900,018,000, which SATISFIES the 9-digit condition. <strong>n = 3</strong> gives 90,001,800,027,000 violates the 9-digit condition, thus any <strong>n &gt; 2</strong> will not work.
&diams; Range for candidate <strong>c</strong> is <strong>9,000 &lt;= c &lt; 9,999</strong> and <strong>n</strong> can only be 2.
<p>&clubs; Since we're looking for the largest instance, start with the greatest possible <strong>c</strong> candidate and decrement downward.</p>
<p>&clubs; Follow the discussion in <a href=""p41.html"">Problem 41</a> to check if a number is pandigital.</p>

<h2>The Code</h2>
[java]
import java.util.Arrays;

public class Problem38
{
  public static char[][] p = {""1"".toCharArray(), ""12"".toCharArray(), 
                              ""123"".toCharArray(), ""1234"".toCharArray(),
                              ""12345"".toCharArray(), ""123456"".toCharArray(), 
                              ""1234567"".toCharArray(), ""12345678"".toCharArray(), 
                              ""123456789"".toCharArray()};

  public static void main(String[] args)
  {
    for(int i = 9999; i &gt;= 9000; i--)
    {
      String s = Integer.toString(i);
      s = s.concat(Integer.toString(i*2));	  
      if(isPan(s))
      {
        System.out.println(s);
    	break;
      }
    }
  }

  public static boolean isPan(String s)
  {
    char[] c = s.toCharArray();
    Arrays.sort(c);
    return (Arrays.equals(c, p[c.length - 1]));	
  }
} 
[/java]
[java]Execution time: 3 ms.[/java]","Problem 38: Pandigital Multiples",,"publish","closed","closed",,"p38",,,"2014-06-15 07:09:39","2014-06-15 07:09:39",,"0","http://euler.lvtran.com/?p=112","0","post",,"0"
"113","1","2014-06-15 06:33:51","2014-06-15 06:33:51","<p>Take the number 192 and multiply it by each of 1, 2, and 3:
<br>192 x 1 = 192
192 x 2 = 384
192 x 3 = 576
<br>By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3). The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and (1,2,3,4,5). 			
<br>What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , <var>n</var>) where <var>n</var> > 1?</p>
<!--more-->


<h2>The Catch</h2>
<p style=""margin-right: 30px;"">How to find the optimal range of a candidate number<strong> c</strong>, which is to be multiplied with (1, 2, ... n) where <strong>n</strong> &gt; 1 to form the concatenated-product-pandigital number.
How to check if a number is pandigital.</p>

<h2>The Light</h2>
<p>&clubs; The desired pandigital number <strong>p</strong> has to have 9 digits from 1-9, exactly once each. A candidate number <strong>c</strong> has to be multiplied with 1 to strong>n</strong>, with <strong>n &gt; 1</strong>. The products are then concatenated to form <strong>p</strong>. Define the notation <strong>(a)(b)</strong> to be ""<strong>a</strong> concatenates<strong> b</strong>"", or <strong>ab</strong>. To find the range of <strong>c</strong>, observe:
<br>&diams; <strong>c</strong> has to have less than 5 digits because the smallest 5-digit number is 10,000 and the smallest possible value for <strong>n</strong> is 2 (n &gt; 1). This gives (10,000 * 1)(10,000 * 2) = 1,000,020,000, which has 10 digits and thus does not satisfy the 9-digit condition. Thus <strong>c</strong> &lt; 10,000.
&diams; We were given to start with 9, so <strong>c</strong> has to start with 9. Thus 9 &lt;=<strong> c</strong> &lt; 9,999.
&diams; If<strong> c</strong> has 2 digits, its lowest value is 90. Assume <strong>n = 2</strong> (lowest possible value), (90 * 1)(90 * 2) = 90,180, which does not satisfy the 9-digit condition. <strong>n = 3</strong> gives 90,180,270 and <strong>n = 4</strong> gives 90,180,270,360, both of which do not satisfy the 9-digit condition. Thus 90 &lt;= <strong>c</strong> &lt; 9,999.
&diams; If <strong>c</strong> has 3 digits, its lowest value is 900. Assume <strong>n = 2</strong> (lowest possible value), (900 * 1)(900 * 2) = 9,001,800, which does not satisfy the 9-digit condition. <strong>n = 3</strong> gives 90,018,002,700 and <strong>n = 4</strong> gives 900,180,027,003,600 both of which do not satisfy the 9-digit condition. Thus 900 &lt;= <strong>c</strong> &lt; 9,999.
&diams; If <strong>c</strong> has 4 digits, its lowest value is 9,000. Assume <strong>n = 2</strong> (lowest possible value), (9,000 * 1)(9,000 * 2) = 900,018,000, which SATISFIES the 9-digit condition. <strong>n = 3</strong> gives 90,001,800,027,000 violates the 9-digit condition, thus any <strong>n &gt; 2</strong> will not work.
&diams; Range for candidate <strong>c</strong> is <strong>9,000 &lt;= c &lt; 9,999</strong> and <strong>n</strong> can only be 2.
<p>&clubs; Since we're looking for the largest instance, start with the greatest possible <strong>c</strong> candidate and decrement downward.</p>
<p>&clubs; Follow the discussion in <a href=""p41.html"">Problem 41</a> to check if a number is pandigital.</p>

<h2>The Code</h2>
[java]
import java.util.Arrays;

public class Problem38
{
  public static char[][] p = {""1"".toCharArray(), ""12"".toCharArray(), 
                              ""123"".toCharArray(), ""1234"".toCharArray(),
                              ""12345"".toCharArray(), ""123456"".toCharArray(), 
                              ""1234567"".toCharArray(), ""12345678"".toCharArray(), 
                              ""123456789"".toCharArray()};

  public static void main(String[] args)
  {
    for(int i = 9999; i &gt;= 9000; i--)
    {
      String s = Integer.toString(i);
      s = s.concat(Integer.toString(i*2));	  
      if(isPan(s))
      {
        System.out.println(s);
    	break;
      }
    }
  }

  public static boolean isPan(String s)
  {
    char[] c = s.toCharArray();
    Arrays.sort(c);
    return (Arrays.equals(c, p[c.length - 1]));	
  }
} 
[/java]
[java]Execution time: 3 ms.[/java]","Problem 38: Pandigital Multiples",,"inherit","open","open",,"112-revision-v1",,,"2014-06-15 06:33:51","2014-06-15 06:33:51",,"112","http://euler.lvtran.com/112-revision-v1/","0","revision",,"0"
"114","1","2013-11-18 06:34:19","2013-11-18 06:34:19","<p>The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.
<br>Find the sum of the only eleven primes that are both truncatable from left to right and right to left. <br><br>NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.</p><!--more-->



<h2>The Catch</h2>
<p>How to manipulate the digits of a number to check if it is prime truncatable.</p><br><br>

<h2>The Light</h2>
<p>&clubs; Parsing the number into a String to manipulate the digits and then parsing it back to integers is an inefficient method. Observe the following:
&nbsp;&nbsp;&nbsp;&nbsp;3797 / 10 = 379
&nbsp;&nbsp;&nbsp;&nbsp;3797 / 100 = 37
&nbsp;&nbsp;&nbsp;&nbsp;3797 / 1000 = 3
Dividing the number by multiples of 10 truncates digits from the right.
		
&nbsp;&nbsp;&nbsp;&nbsp;3797 % 10 = 7
&nbsp;&nbsp;&nbsp;&nbsp;3797 % 100 = 97
&nbsp;&nbsp;&nbsp;&nbsp;3797 % 1000 = 797
Modulus the number by multiples of 10 truncates digits from the left.</p>

<p>&clubs; Use prime checking method in <a href=""p3.html"">Problem 3</a> to determine primness.</p>

<h2>The Code</h2>
[java]
public class Problem37
{
  public static void main(String[] args)
  {
    int count = 0;
    int sum = 0;
    int ten = 10;
    boolean leftTrunc = true;
    boolean rightTrunc = true;

    for(int n = 11; count != 11; n += 2)
    {
      if(isPrime(n))
      {
        while(ten &lt; n)
        {
          if(!isPrime(n/ten))
    	  {
    	    leftTrunc = false;
            break;
    	  }
    	  if(!isPrime(n%ten))
    	  {
    	    rightTrunc = false;
    	    break;
    	  }
    	  ten *= 10;
        }
        if(leftTrunc &amp;&amp; rightTrunc)
        {
          ++count;
    	  sum += n;
        }
      }
      leftTrunc = true;
      rightTrunc = true;
      ten = 10;
    }	  
    System.out.println(""Sum = "" + sum);
  }

  public static boolean isPrime(int n)
  {
    if( n &lt; 2 )
      return false; 

    if(n % 2 == 0 &amp;&amp; n != 2)
      return false;

    for( int i = 3; i * i &lt;= n; i += 2)
    {
      if(n % i == 0)
        return false;
    }

    return true;
  }
}
[/java]
[java]Execution time: 87 ms.[/java]","Problem 37: Truncatable Primes",,"publish","closed","closed",,"p37",,,"2014-06-15 07:09:39","2014-06-15 07:09:39",,"0","http://euler.lvtran.com/?p=114","0","post",,"0"
"115","1","2014-06-15 06:34:19","2014-06-15 06:34:19","<p>The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.
<br>Find the sum of the only eleven primes that are both truncatable from left to right and right to left. <br><br>NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.</p><!--more-->



<h2>The Catch</h2>
<p>How to manipulate the digits of a number to check if it is prime truncatable.</p><br><br>

<h2>The Light</h2>
<p>&clubs; Parsing the number into a String to manipulate the digits and then parsing it back to integers is an inefficient method. Observe the following:
&nbsp;&nbsp;&nbsp;&nbsp;3797 / 10 = 379
&nbsp;&nbsp;&nbsp;&nbsp;3797 / 100 = 37
&nbsp;&nbsp;&nbsp;&nbsp;3797 / 1000 = 3
Dividing the number by multiples of 10 truncates digits from the right.
		
&nbsp;&nbsp;&nbsp;&nbsp;3797 % 10 = 7
&nbsp;&nbsp;&nbsp;&nbsp;3797 % 100 = 97
&nbsp;&nbsp;&nbsp;&nbsp;3797 % 1000 = 797
Modulus the number by multiples of 10 truncates digits from the left.</p>

<p>&clubs; Use prime checking method in <a href=""p3.html"">Problem 3</a> to determine primness.</p>

<h2>The Code</h2>
[java]
public class Problem37
{
  public static void main(String[] args)
  {
    int count = 0;
    int sum = 0;
    int ten = 10;
    boolean leftTrunc = true;
    boolean rightTrunc = true;

    for(int n = 11; count != 11; n += 2)
    {
      if(isPrime(n))
      {
        while(ten &lt; n)
        {
          if(!isPrime(n/ten))
    	  {
    	    leftTrunc = false;
            break;
    	  }
    	  if(!isPrime(n%ten))
    	  {
    	    rightTrunc = false;
    	    break;
    	  }
    	  ten *= 10;
        }
        if(leftTrunc &amp;&amp; rightTrunc)
        {
          ++count;
    	  sum += n;
        }
      }
      leftTrunc = true;
      rightTrunc = true;
      ten = 10;
    }	  
    System.out.println(""Sum = "" + sum);
  }

  public static boolean isPrime(int n)
  {
    if( n &lt; 2 )
      return false; 

    if(n % 2 == 0 &amp;&amp; n != 2)
      return false;

    for( int i = 3; i * i &lt;= n; i += 2)
    {
      if(n % i == 0)
        return false;
    }

    return true;
  }
}
[/java]
[java]Execution time: 87 ms.[/java]","Problem 37: Truncatable Primes",,"inherit","open","open",,"114-revision-v1",,,"2014-06-15 06:34:19","2014-06-15 06:34:19",,"114","http://euler.lvtran.com/114-revision-v1/","0","revision",,"0"
"116","1","2013-11-20 06:34:57","2013-11-20 06:34:57","<p>The decimal number, 585 = 1001001001<sub>2</sub> (binary), is palindromic in both bases.
<br>Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2. (Please note that the palindromic number, in either base, may not include leading zeros.)</p><!--more-->



<h2>The Catch</h2>
<p>How to convert a decimal number to binary.
How to check if a number is palindromic.</p>

<h2>The Light</h2>
<p>&clubs; To convert a decimal number to binary, divide the number by 2 and list out the remainders for every division until the quotient is reduced to 0. Reverse the remainder list to find the binary result. 

For example, convert 12 to binary:
<table>
<tr>
<td><p>Quotient</td>
<td><p>Remainer</td>
</tr>
<tr>
<td><p>12/2</td>
<td><p>0</td>
</tr>
<tr>
<td><p>6/2</td>
<td><p>0</td>
</tr>
<tr>
<td><p>3/2</td>
<td><p>1</td>
</tr>
<tr>
<td><p>1/2</td>
<td><p>1</td>
</tr>			
</table>
<p style=""margin-right: 30px;"">12 in binary is 1100. You can either implement this approach or use Java's <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Integer.html"" target=""_blank"">Integer</a> class' built-in function that converts decimal number to binary.</p>
			
<p>&clubs; Use the discussion in <a href=""http://lvtran.com/p4/"" target=""_blank"">Problem 4</a> on how to check if a number is palindromic.</li>
</ul></p><br><br>

<h2>The Code</h2>
[java]
public class Problem36
{
  public static void main(String[] args)
  {
    int sum = 0;

    for(int i = 1; i &lt; 1000000; i++)
    {
      String s = Integer.toString(i);
      if(isPalin(s) &amp;&amp; isPalin(Integer.toBinaryString(i)))
        sum += i;
    }
    System.out.println(sum);
  }

  public static boolean isPalin(String s)
  {
    for(int i = 0; i &lt; s.length()/2; i++)
    {
      if(s.charAt(i) != s.charAt(s.length() - 1 - i))
        return false;
    }
    return true;
  }
}    
[/java]
[java]Execution time: 72 ms.[/java]","Problem 36: Double-Base Palindromes",,"publish","closed","closed",,"p36",,,"2014-06-15 07:09:38","2014-06-15 07:09:38",,"0","http://euler.lvtran.com/?p=116","0","post",,"0"
"117","1","2014-06-15 06:34:57","2014-06-15 06:34:57","<p>The decimal number, 585 = 1001001001<sub>2</sub> (binary), is palindromic in both bases.
<br>Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2. (Please note that the palindromic number, in either base, may not include leading zeros.)</p><!--more-->



<h2>The Catch</h2>
<p>How to convert a decimal number to binary.
How to check if a number is palindromic.</p>

<h2>The Light</h2>
<p>&clubs; To convert a decimal number to binary, divide the number by 2 and list out the remainders for every division until the quotient is reduced to 0. Reverse the remainder list to find the binary result. 

For example, convert 12 to binary:
<table>
<tr>
<td><p>Quotient</td>
<td><p>Remainer</td>
</tr>
<tr>
<td><p>12/2</td>
<td><p>0</td>
</tr>
<tr>
<td><p>6/2</td>
<td><p>0</td>
</tr>
<tr>
<td><p>3/2</td>
<td><p>1</td>
</tr>
<tr>
<td><p>1/2</td>
<td><p>1</td>
</tr>			
</table>
<p style=""margin-right: 30px;"">12 in binary is 1100. You can either implement this approach or use Java's <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Integer.html"" target=""_blank"">Integer</a> class' built-in function that converts decimal number to binary.</p>
			
<p>&clubs; Use the discussion in <a href=""http://lvtran.com/p4/"" target=""_blank"">Problem 4</a> on how to check if a number is palindromic.</li>
</ul></p><br><br>

<h2>The Code</h2>
[java]
public class Problem36
{
  public static void main(String[] args)
  {
    int sum = 0;

    for(int i = 1; i &lt; 1000000; i++)
    {
      String s = Integer.toString(i);
      if(isPalin(s) &amp;&amp; isPalin(Integer.toBinaryString(i)))
        sum += i;
    }
    System.out.println(sum);
  }

  public static boolean isPalin(String s)
  {
    for(int i = 0; i &lt; s.length()/2; i++)
    {
      if(s.charAt(i) != s.charAt(s.length() - 1 - i))
        return false;
    }
    return true;
  }
}    
[/java]
[java]Execution time: 72 ms.[/java]","Problem 36: Double-Base Palindromes",,"inherit","open","open",,"116-revision-v1",,,"2014-06-15 06:34:57","2014-06-15 06:34:57",,"116","http://euler.lvtran.com/116-revision-v1/","0","revision",,"0"
"118","1","2013-11-21 06:35:35","2013-11-21 06:35:35","<p style=""margin-right: 30px;"">The number 197 is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime. There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97. How many circular primes are there below one million?</p><!--more-->


		
<h2>The Catch</h2>
<p>How to rotate a number.
How to speed up the execution time since the current search range is from 1 to 1,000,000. Even if only odd numbers are checked, the search range is still 500,000 iterations.</p>

<h2>The Light</h2>
<p>&clubs;&nbsp;Utilizing digit-manipulating technique like in <a href=""http://lvtran.com/p37/"">Problem 37</a>, to rotate a number <strong>n</strong>:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Find out how many<strong> rotation</strong> is needed. The number of rotation equals the number of digits <strong>n</strong> has. Divide <strong>(int) n</strong> by <strong>10</strong> to determine.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Find a multiplier for <strong>n</strong>. The multiplier should be <strong>10<sup>(number of digits of n)</sup></strong>.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; One of a rotated version of <strong>n = (n % 10 * multiplier) + (n/10)</strong>.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat for all rotation.

For example, to rotate the number 812:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; 812 has 3 digits, so there must be 3 rotations (but only <strong>2</strong> are necessary; the number 812 itself is counted as one rotation).
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Multiplier = 10<sup>2</sup> = 100
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Rotate 812 = 812%10 * 100 + (int)812/10 = 200 + 81 = 281
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Rotate 281 = 281%10 * 100 + (int)281/10 = 100 + 28 = 128
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Rotate 128 = 812 (which is why this 3rd rotation is unnecessary).</p>

<p>&clubs;&nbsp;If one digit of the number <strong>n </strong>is an even number or 5, then this number is not a prime and thus it not a ... circular prime.</p>
<p>&clubs;&nbsp;Instead of looping through every odd, positive, natural number (which results in 500,000 iterations), loop through a list of prime numbers below an upper bound. It can be checked that this will result in only 78,498 iterations. To create this list of prime numbers, it is not efficient to loop from 2 to the upper bound and use the traditional prime check. Instead, there is a method called <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"">Sieve of Eratosthenes</a> invented by
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/p35a.png"" alt=""p35a"" width=""278"" height=""275"" class=""aligncenter size-full wp-image-348"" />
It generates all prime numbers below 1,000,000 within 15-20 ms. The algorithm:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Create a list of natural number from <strong>2</strong> to the upper bound.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Set <strong>p = 2</strong>, the first number of the list.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; From <strong>p</strong> to the upper bound, mark <strong>p</strong> and all of its <strong>multiples</strong>.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Set <strong>p</strong> to the next number in the list.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat step 3 and 4 until <strong>p &lt;=</strong> <strong>sqrt(upper bound)</strong>. (NOTE: some numbers will be marked several times; this is okay)
&nbsp;&nbsp;&nbsp;&nbsp;&diams; The unmarked numbers left in the list are all prime.

<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/p35b.gif"" alt=""p35b"" width=""445"" height=""369"" class=""aligncenter size-full wp-image-349"" />
<p align=""center"">(image courtesy of Wikipedia)</p>
<p>&clubs;&nbsp;When creating the Sieve of Eratosthenes, it is best to store the result in a list L. It is, however, very costly (execution-time wise) to check if a number is prime by checking if 
it is in the list L. Thus, use the traditional prime check as discussed in <a href=""p3.html"">Problem 3</a>.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem35
{
  public static void main(String[] args)
  {
    int count = 2; //2 and 5 will be eliminated by the last digit test. These are the only 2 exceptions.
    List primeList = generatePrimes(1000000);

    for(int i = 0; i &lt; primeList.size(); i++)
    {
      int rotate = 0; //Number of rotations
      int multiplier = 1;
      int n = primeList.get(i);
      boolean circularPrime = true;
      boolean moveOn = false;

      while(n &gt; 0)
      {
        rotate++;
    	int lastDigit = n % 10;
    	n /= 10;
    	if(lastDigit % 2 == 0 || lastDigit == 5)
    	{
    	  moveOn = true;
    	  break;
    	}
    	multiplier *= 10;
      }		
      if(moveOn)
        continue;
      multiplier /= 10;

      n = primeList.get(i);
      while(rotate &gt; 0) //Last rotation is not needed
      {
        n = (n % 10 * multiplier) + (n/10);
        rotate--;
    	if(!isPrime(n))
    	{
    	  circularPrime = false;
    	  break;
    	}
      }
      if(circularPrime)
        count++;
    }
    System.out.println(count);
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }

  public static boolean isPrime(int n)
  {
    if(n &lt; 2)
      return false;

    if(n != 2 &amp;&amp; n % 2 == 0)
      return false;

    for(int i = 3; i*i &lt;= n; i += 2)
    {
      if( n % i == 0 )
        return false;
    } 
    return true;
  }
}
[/java]
[java]Execution time: 28 ms.[/java]","Problem 35: Circular Primes",,"publish","closed","closed",,"p35",,,"2014-06-15 07:09:38","2014-06-15 07:09:38",,"0","http://euler.lvtran.com/?p=118","0","post",,"0"
"119","1","2014-06-15 06:35:35","2014-06-15 06:35:35","<p style=""margin-right: 30px;"">The number 197 is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime. There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97. How many circular primes are there below one million?</p><!--more-->


		
<h2>The Catch</h2>
<p>How to rotate a number.
How to speed up the execution time since the current search range is from 1 to 1,000,000. Even if only odd numbers are checked, the search range is still 500,000 iterations.</p>

<h2>The Light</h2>
<p>&clubs;&nbsp;Utilizing digit-manipulating technique like in <a href=""http://lvtran.com/p37/"">Problem 37</a>, to rotate a number <strong>n</strong>:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Find out how many<strong> rotation</strong> is needed. The number of rotation equals the number of digits <strong>n</strong> has. Divide <strong>(int) n</strong> by <strong>10</strong> to determine.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Find a multiplier for <strong>n</strong>. The multiplier should be <strong>10<sup>(number of digits of n)</sup></strong>.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; One of a rotated version of <strong>n = (n % 10 * multiplier) + (n/10)</strong>.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat for all rotation.

For example, to rotate the number 812:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; 812 has 3 digits, so there must be 3 rotations (but only <strong>2</strong> are necessary; the number 812 itself is counted as one rotation).
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Multiplier = 10<sup>2</sup> = 100
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Rotate 812 = 812%10 * 100 + (int)812/10 = 200 + 81 = 281
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Rotate 281 = 281%10 * 100 + (int)281/10 = 100 + 28 = 128
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Rotate 128 = 812 (which is why this 3rd rotation is unnecessary).</p>

<p>&clubs;&nbsp;If one digit of the number <strong>n </strong>is an even number or 5, then this number is not a prime and thus it not a ... circular prime.</p>
<p>&clubs;&nbsp;Instead of looping through every odd, positive, natural number (which results in 500,000 iterations), loop through a list of prime numbers below an upper bound. It can be checked that this will result in only 78,498 iterations. To create this list of prime numbers, it is not efficient to loop from 2 to the upper bound and use the traditional prime check. Instead, there is a method called <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"">Sieve of Eratosthenes</a> invented by
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/p35a.png"" alt=""p35a"" width=""278"" height=""275"" class=""aligncenter size-full wp-image-348"" />
It generates all prime numbers below 1,000,000 within 15-20 ms. The algorithm:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Create a list of natural number from <strong>2</strong> to the upper bound.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Set <strong>p = 2</strong>, the first number of the list.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; From <strong>p</strong> to the upper bound, mark <strong>p</strong> and all of its <strong>multiples</strong>.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Set <strong>p</strong> to the next number in the list.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; Repeat step 3 and 4 until <strong>p &lt;=</strong> <strong>sqrt(upper bound)</strong>. (NOTE: some numbers will be marked several times; this is okay)
&nbsp;&nbsp;&nbsp;&nbsp;&diams; The unmarked numbers left in the list are all prime.

<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/p35b.gif"" alt=""p35b"" width=""445"" height=""369"" class=""aligncenter size-full wp-image-349"" />
<p align=""center"">(image courtesy of Wikipedia)</p>
<p>&clubs;&nbsp;When creating the Sieve of Eratosthenes, it is best to store the result in a list L. It is, however, very costly (execution-time wise) to check if a number is prime by checking if 
it is in the list L. Thus, use the traditional prime check as discussed in <a href=""p3.html"">Problem 3</a>.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem35
{
  public static void main(String[] args)
  {
    int count = 2; //2 and 5 will be eliminated by the last digit test. These are the only 2 exceptions.
    List primeList = generatePrimes(1000000);

    for(int i = 0; i &lt; primeList.size(); i++)
    {
      int rotate = 0; //Number of rotations
      int multiplier = 1;
      int n = primeList.get(i);
      boolean circularPrime = true;
      boolean moveOn = false;

      while(n &gt; 0)
      {
        rotate++;
    	int lastDigit = n % 10;
    	n /= 10;
    	if(lastDigit % 2 == 0 || lastDigit == 5)
    	{
    	  moveOn = true;
    	  break;
    	}
    	multiplier *= 10;
      }		
      if(moveOn)
        continue;
      multiplier /= 10;

      n = primeList.get(i);
      while(rotate &gt; 0) //Last rotation is not needed
      {
        n = (n % 10 * multiplier) + (n/10);
        rotate--;
    	if(!isPrime(n))
    	{
    	  circularPrime = false;
    	  break;
    	}
      }
      if(circularPrime)
        count++;
    }
    System.out.println(count);
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }

  public static boolean isPrime(int n)
  {
    if(n &lt; 2)
      return false;

    if(n != 2 &amp;&amp; n % 2 == 0)
      return false;

    for(int i = 3; i*i &lt;= n; i += 2)
    {
      if( n % i == 0 )
        return false;
    } 
    return true;
  }
}
[/java]
[java]Execution time: 28 ms.[/java]","Problem 35: Circular Primes",,"inherit","open","open",,"118-revision-v1",,,"2014-06-15 06:35:35","2014-06-15 06:35:35",,"118","http://euler.lvtran.com/118-revision-v1/","0","revision",,"0"
"120","1","2013-11-22 06:36:27","2013-11-22 06:36:27","<p>145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.
<br>Find the sum of all numbers which are equal to the sum of the factorial of their digits. <b>Note</b>: as 1! = 1 and 2! = 2 are not sums they are not included.</p><!--more-->



<h2>The Catch</h2>
<p>How to determine the upper bound of the search range.
How to efficiently calculate factorial.
How to efficiently manipulate the digits to find their sum.</p>

<h2>The Light</h2>
<p>&clubs; Similar to the analysis in <a href=""http://lvtran.com/p30/"" target=""_blank"">Problem 30</a>:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; The lowest 7-digit number is 1,000,000, the maximum sum of factorial of their digits is 9! * 7 = 2,540,160.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; The lowest 8-digit number is 10,000,000, the maximum sum of factorial of their digits is only 9! * 8 = 2,903,040. This indicates no 8-digit number can be written as the sum of factorial of their digit. Upper bound is <strong>2,540,160</strong>.
<p>&clubs; In this problem, only 0! to 9! are needed, so calculate their results and store in an array to avoid repeated calculations.<br>
<p>&clubs; Similar to the technique in <a href=""http://lvtran.com/p37"" target=""_blank"">Problem 37</a>, perform a modulus of 10 on a number to get its last digit. Take advantage of this to calculate the digit sum.</p>

<h2>The Code</h2>
[java]
public class Problem34
{
  public static void main(String[] args)
  {
    int sum = 0;
    int[] fact = fact();
	
    for(int i = 10; i <= 2540160; i++)
    {
      int tmp = i;	  
      int tmpSum = 0;
      while(tmp > 0)
      {
        tmpSum += fact[tmp % 10];
    	tmp /= 10;
      }
	  
      if(tmpSum == i)
        sum += i;
    }
    System.out.println(sum);
  }
  
  public static int[] fact()
  {
    int[] fact = new int[10];
    fact[0] = 1;
    for(int i = 1; i < fact.length; i++)
    {
      int tmp = i;
      int result = 1;
      while(tmp > 1)
      {
        result *= (tmp--);
      }
      fact[i] = result;
    }
    return fact;
  }
}
[/java]
[java]Execution time: 41 ms.[/java]","Problem 34: Digit Factorials",,"publish","closed","closed",,"p34",,,"2014-06-15 07:09:37","2014-06-15 07:09:37",,"0","http://euler.lvtran.com/?p=120","0","post",,"0"
"121","1","2014-06-15 06:36:27","2014-06-15 06:36:27","<p>145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.
<br>Find the sum of all numbers which are equal to the sum of the factorial of their digits. <b>Note</b>: as 1! = 1 and 2! = 2 are not sums they are not included.</p><!--more-->



<h2>The Catch</h2>
<p>How to determine the upper bound of the search range.
How to efficiently calculate factorial.
How to efficiently manipulate the digits to find their sum.</p>

<h2>The Light</h2>
<p>&clubs; Similar to the analysis in <a href=""http://lvtran.com/p30/"" target=""_blank"">Problem 30</a>:
&nbsp;&nbsp;&nbsp;&nbsp;&diams; The lowest 7-digit number is 1,000,000, the maximum sum of factorial of their digits is 9! * 7 = 2,540,160.
&nbsp;&nbsp;&nbsp;&nbsp;&diams; The lowest 8-digit number is 10,000,000, the maximum sum of factorial of their digits is only 9! * 8 = 2,903,040. This indicates no 8-digit number can be written as the sum of factorial of their digit. Upper bound is <strong>2,540,160</strong>.
<p>&clubs; In this problem, only 0! to 9! are needed, so calculate their results and store in an array to avoid repeated calculations.<br>
<p>&clubs; Similar to the technique in <a href=""http://lvtran.com/p37"" target=""_blank"">Problem 37</a>, perform a modulus of 10 on a number to get its last digit. Take advantage of this to calculate the digit sum.</p>

<h2>The Code</h2>
[java]
public class Problem34
{
  public static void main(String[] args)
  {
    int sum = 0;
    int[] fact = fact();
	
    for(int i = 10; i <= 2540160; i++)
    {
      int tmp = i;	  
      int tmpSum = 0;
      while(tmp > 0)
      {
        tmpSum += fact[tmp % 10];
    	tmp /= 10;
      }
	  
      if(tmpSum == i)
        sum += i;
    }
    System.out.println(sum);
  }
  
  public static int[] fact()
  {
    int[] fact = new int[10];
    fact[0] = 1;
    for(int i = 1; i < fact.length; i++)
    {
      int tmp = i;
      int result = 1;
      while(tmp > 1)
      {
        result *= (tmp--);
      }
      fact[i] = result;
    }
    return fact;
  }
}
[/java]
[java]Execution time: 41 ms.[/java]","Problem 34: Digit Factorials",,"inherit","open","open",,"120-revision-v1",,,"2014-06-15 06:36:27","2014-06-15 06:36:27",,"120","http://euler.lvtran.com/120-revision-v1/","0","revision",,"0"
"122","1","2013-11-08 06:45:13","2013-11-08 06:45:13","<p>Pentagonal numbers are generated by the formula, P<sub><i>n</i></sub> = <i>n</var>(3<i>n</i> - 1)/2. </i>The first ten pentagonal numbers are: 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
<p>It can be seen that P<sub>4</sub> + P<sub>7</sub> = 22 + 70 = 92 = P<sub>8</sub>. However, their difference, 70 - 22 = 48, is not pentagonal.
<p>Find the pair of pentagonal numbers, P<sub><i>j</i></sub> and P<sub><i>k</i></sub>, for which their sum and difference are pentagonal and D = |P<sub><var>k</var></sub> - P<sub><i>j</i></sub> | is minimized; what is the value of D?</p><!--more-->



<h2>The Catch</h2>
<p>How to check if a number is pentagonal.
How to make sure that D is minimized.</p>

<h2>The Light</h2>
<p>&clubs; As in the discussion in <a href=""http://lvtran.com/p42/"">Problem 42</a>, solve the inverse function to check if an integer is pentagonal.
<div class=""indent""><p>
P(n) = t = n(3n - 1)/2
2t = 3n<sup>2</sup> - n
0 = 3n<sup>2</sup> - n - 2t
<strong>n = (1 + sprt(1 + 24t))/6</strong> and
n = (1 - sqrt(1 + 24t) )/6 (discarded)</p>
	
<p>&clubs; To make sure that the difference is minimized, for each pentagonal number <strong>p</strong> found, find the sum and difference of <strong>p</strong> with each and every pentagonal number <strong>a</strong>, with <strong>a &lt; p</strong>. Stop at the first instance where both the sum and difference are pentagonal(i.e the difference D is minimized). This is because after this instance, the difference D will get larger as <b>p</b> and <b>a</b> get larger.</p>

<h2>The Code</h2>
[java]
public class Problem44
{
  public static void main(String[] args)
  {
    boolean found = false;
    long j = 1;
	
    while(!found)
    {
      long Pj = j * (3*j - 1)/2;
      
      for(long k = j - 1; k > 0; k--)
      {
        long Pk = k * (3*k - 1)/2;
        if(isPent(Pj - Pk) && isPent(Pj + Pk))
        {
          found = true;
          System.out.println(Pj - Pk);
          break;
        }
      }
      j++;	  
    }	
  }
  
  public static boolean isPent( long t )
  {
    double tmp = (1.0 + Math.sqrt(1 + 24 * t)) / 6.0;
    return tmp == (long)tmp;
  }
}
[/java]
[java]Execution time: 37 ms.[/java]","Problem 44: Pentagon Numbers",,"publish","closed","closed",,"p44",,,"2014-06-15 07:09:52","2014-06-15 07:09:52",,"0","http://euler.lvtran.com/?p=122","0","post",,"0"
"123","1","2014-06-15 06:45:13","2014-06-15 06:45:13","<p>Pentagonal numbers are generated by the formula, P<sub><i>n</i></sub> = <i>n</var>(3<i>n</i> - 1)/2. </i>The first ten pentagonal numbers are: 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
<p>It can be seen that P<sub>4</sub> + P<sub>7</sub> = 22 + 70 = 92 = P<sub>8</sub>. However, their difference, 70 - 22 = 48, is not pentagonal.
<p>Find the pair of pentagonal numbers, P<sub><i>j</i></sub> and P<sub><i>k</i></sub>, for which their sum and difference are pentagonal and D = |P<sub><var>k</var></sub> - P<sub><i>j</i></sub> | is minimized; what is the value of D?</p><!--more-->



<h2>The Catch</h2>
<p>How to check if a number is pentagonal.
How to make sure that D is minimized.</p>

<h2>The Light</h2>
<p>&clubs; As in the discussion in <a href=""http://lvtran.com/p42/"">Problem 42</a>, solve the inverse function to check if an integer is pentagonal.
<div class=""indent""><p>
P(n) = t = n(3n - 1)/2
2t = 3n<sup>2</sup> - n
0 = 3n<sup>2</sup> - n - 2t
<strong>n = (1 + sprt(1 + 24t))/6</strong> and
n = (1 - sqrt(1 + 24t) )/6 (discarded)</p>
	
<p>&clubs; To make sure that the difference is minimized, for each pentagonal number <strong>p</strong> found, find the sum and difference of <strong>p</strong> with each and every pentagonal number <strong>a</strong>, with <strong>a &lt; p</strong>. Stop at the first instance where both the sum and difference are pentagonal(i.e the difference D is minimized). This is because after this instance, the difference D will get larger as <b>p</b> and <b>a</b> get larger.</p>

<h2>The Code</h2>
[java]
public class Problem44
{
  public static void main(String[] args)
  {
    boolean found = false;
    long j = 1;
	
    while(!found)
    {
      long Pj = j * (3*j - 1)/2;
      
      for(long k = j - 1; k > 0; k--)
      {
        long Pk = k * (3*k - 1)/2;
        if(isPent(Pj - Pk) && isPent(Pj + Pk))
        {
          found = true;
          System.out.println(Pj - Pk);
          break;
        }
      }
      j++;	  
    }	
  }
  
  public static boolean isPent( long t )
  {
    double tmp = (1.0 + Math.sqrt(1 + 24 * t)) / 6.0;
    return tmp == (long)tmp;
  }
}
[/java]
[java]Execution time: 37 ms.[/java]","Problem 44: Pentagon Numbers",,"inherit","open","open",,"122-revision-v1",,,"2014-06-15 06:45:13","2014-06-15 06:45:13",,"122","http://euler.lvtran.com/122-revision-v1/","0","revision",,"0"
"124","1","2013-11-09 06:45:35","2013-11-09 06:45:35","<p>The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.
<p>Let <i>d</i><sub>1</sub> be the 1<sup>st</sup> digit, <i>d</i><sub>2</sub> be the 2<sup>nd</sup> digit, and so on. In this way, we note the following:

<i>d</i><sub>2</sub><i>d</i><sub>3</sub><i>d</i><sub>4</sub>= 406 is divisible by 2
<i>d</i><sub>3</sub><i>d</i><sub>4</sub><i>d</i><sub>5</sub>= 063 is divisible by 3
<i>d</i><sub>4</sub><i>d</i><sub>5</sub><i>d</i><sub>6</sub>= 635 is divisible by 5
<i>d</i><sub>5</sub><i>d</i><sub>6</sub><i>d</i><sub>7</sub>= 357 is divisible by 7
<i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub>= 572 is divisible by 11
<i>d</i><sub>7</sub><i>d</i><sub>8</sub><i>d</i><sub>9</sub>= 728 is divisible by 13
<i>d</i><sub>8</sub><i>d</i><sub>9</sub><i>d</i><sub>10</sub>= 289 is divisible by 17

<p>Find the sum of all 0 to 9 pandigital numbers with this property.</p>
<!--more-->


<h2>The Catch</h2>
<p>If we want to brute force the solution by going through all pandigital numbers, it will require a permutation algorithm (rather difficult to implement and understand) and might take several hundred milliseconds.</p>
			
<h2>The Light and The Code</h2>
<p>To help with the analysis below, it will be useful to have a method that checks whether a number contains repeated digits. The algorithm is fairly simple: parse the number into String and traverse through each character. Keep track of each character and return immediately when a second instance of any character is found.
[java]
public static boolean hasRepeatDigit(int n)
{
  if(n &lt; 10)
    return false;

  char[] found = new char[10];
  String s = Integer.toString(n);
  found[Character.getNumericValue(s.charAt(0))] = s.charAt(0);

  for(int i = 1; i &lt; s.length(); i++)
  {
    if(s.charAt(i) == found[Character.getNumericValue(s.charAt(i))])
      return true;
    else
      found[Character.getNumericValue(s.charAt(i))] = s.charAt(i);  
  }
  return false;
}
[/java]

<p>Analyzing smaller groups of digits using their given divisibility properties:
&diams; <strong><i>d</i><sub>4</sub><i>d</i><sub>5</sub><i>d</i></strong><sub><strong>6</strong> </sub>is divisible by <strong>5</strong>, which means <strong><i>d</i></strong><sub><strong>6</strong> </sub>must be <strong>0</strong> or <strong>5</strong>.
&diams; If <strong><i>d</i></strong><sub><strong>6</strong></sub> is <strong>0</strong>, then <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong> is divisible by <strong>11</strong> if and only if <strong><i>d</i><sub>7 </sub></strong>= <strong><i>d</i><sub>8</sub></strong>, or in another word, <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8 </sub></strong>= {011, 022, 033, 044, 055, 066, 077, 088, 099}. Pandigital numbers cannot have repeated digits, so <i>d</i><sub>6</sub> cannot be 0; <strong><span style=""color: #ff0000;""><i>d</i><sub>6</sub> = 5</span></strong>.
&diams; Since <strong><i>d</i><sub>6</sub> = 5</strong>, we can find all possible values for <strong><i>d</i><sub>7<i> </i></sub></strong>and <strong><i>d</i><sub>8</sub></strong> by looking for all numbers between 501 and 598 that are divisible by 11 and has no repeated digits.

[java]
  //Check d6d7d8 for divisibility by 11
  List d6d7d8 = new ArrayList();
  for(int i = 501; i &lt;= 598; i++)
  {
    if((i % 11 == 0) &amp;&amp; (i % 10 != 5) &amp;&amp; (i % 100/10 != 5) &amp;&amp; (i % 10 != i % 100/10) &amp;&amp; !hasRepeatDigit(i))
    {
      System.out.print(i + "" "");
      d6d7d8.add(i);
    }
  }
  System.out.println();
[/java]

<p>This outputs <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong> = {<span style=""color: #ff0000;""><strong>506, 517, 528, 539, 561, 572, 583, 594</strong><span style=""color: #000000;"">}</span></span>. Now that the sequence <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong> is formulated, limiting the possible values for the sequence <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9 </sub></strong>  by adding <strong><i>d</i><sub>9</sub></strong>
[java]
  //Check d6d7d8d9 
  List d6d7d8d9 = new ArrayList();
  for(int i = 0; i &lt; d6d7d8.size(); i++)
  {
    for( int d9 = 0; d9 &lt;= 9; d9++ )
    {
      int tmp = (d6d7d8.get(i) - 500) * 10 + d9;
      if(tmp % 13 == 0 &amp;&amp; !hasRepeatDigit(tmp + 5000))
      {
        System.out.print((5000 + tmp) + "" "");
        d6d7d8d9.add(5000 + tmp);
      }
    }
  }
  System.out.println();
[/java]

<p>This outputs <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9 </sub></strong>= {<strong><span style=""color: #ff0000;"">5286, 5390, 5728, 5832</span></strong>}. Similarly, add <strong><i>d</i><sub>10 </sub></strong>to find the sequence <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>
[java]
  //Check d8d9d10 for divisibility by 17
  List d6d7d8d9d10 = new ArrayList();
  for(int i = 0; i &lt; d6d7d8d9.size(); i++)
  {
    int d8d9 = d6d7d8d9.get(i) % 100;
    for(int d10 = 0; d10 &lt;= 9; d10++)
    {
      if((d8d9 * 10 + d10) % 17 == 0 &amp;&amp; !hasRepeatDigit(d6d7d8d9.get(i) * 10 + d10))
      {
        System.out.print( (d6d7d8d9.get(i) * 10 + d10) + "" "");
        d6d7d8d9d10.add((d6d7d8d9.get(i) * 10 + d10));
      }
    }
  }
  System.out.println();
[/java]

<p>This outputs <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>52867, 53901, 57289</strong></span>}. Continue with <strong><i>d</i><sub>5</sub><i></i></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>

[java]
  //Check d5d6d7 for divisibility by 7
  List d5d6d7d8d9d10 = new ArrayList();
  for(int i = 0; i &lt; d6d7d8d9d10.size(); i++)
  {
    int d6d7 = d6d7d8d9d10.get(i)/1000; 
    for(int d5 = 0; d5 &lt;= 9; d5++)
    {
      if((d5 * 100 + d6d7) % 7 == 0 &amp;&amp; !hasRepeatDigit(d5 * 100000 + d6d7d8d9d10.get(i)))
      {
        System.out.print((d5 * 100000 + d6d7d8d9d10.get(i)) + "" "");
        d5d6d7d8d9d10.add((d5 * 100000 + d6d7d8d9d10.get(i)));
      }
    }
  }
  System.out.println();
[/java]
	
<p>This outputs <strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>9</strong><strong>52867, 357289</strong></span>}. <strong><i>d</i><sub>2</sub><i>d</i><sub>3</sub><i>d</i><sub>4 </sub></strong>is divisible by 2, so <strong><i>d</i><sub>4</sub></strong><strong><sub> </sub></strong>must be an even number. Add <strong><i>d</i><sub>4</sub></strong> to the sequence <strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub></sub></strong>
[java]
  //Add (even) d4 to the sequence d5d6d7d8d9d10
  List d4d5d6d7d8d9d10 = new ArrayList();
  for(int i = 0; i &lt; d5d6d7d8d9d10.size(); i++)
  {
    for(int d4 = 0; d4 &lt; 9; d4 += 2)
    {
      if(!hasRepeatDigit((d4 * 1000000 + d5d6d7d8d9d10.get(i))))
      { 
        if(d4 == 0)
        {
          System.out.print(d4 * 1000000);
          System.out.print(d5d6d7d8d9d10.get(i) + "" "");
          d4d5d6d7d8d9d10.add(d4 * 1000000 + d5d6d7d8d9d10.get(i)); //Special leading 0 cases
        }
        else
        {
          System.out.print((d4 * 1000000 + d5d6d7d8d9d10.get(i)) + "" "");
          d4d5d6d7d8d9d10.add(d4 * 1000000 + d5d6d7d8d9d10.get(i));
        }
      }
    }
  }
  System.out.println();
[/java]
	
<p>This outputs <strong><i>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>0952867, 4952867, 0357289, 4357289, 6357289</strong></span>}</p>

<p>Now there are only 3 digits left to determine; we can switch to manual mode! Judging from the set above and the fact that <strong><i>d</i><sub>3 </sub><i>+ d</i><sub>4 </sub><i>+ d</i></strong><sub><strong>5</strong> </sub>must be divisible by <strong>3</strong>:
<p>
0952867 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {1, 3, 4} &rarr; <strong><i>d</i><sub>3 </sub></strong>= 3 is the only candidate that satisfies the divisibility requirement &rarr;<strong><span style=""color: #ff0000;""> 30952867</span></strong>
4952867 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {0, 1, 3} &rarr; Numbers in this set don't satisfy the divisibility requirement &rarr; discard 4952867
0357289 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {1, 4, 6} &rarr; <strong><i>d</i><sub>3 </sub></strong>= 6 is the only candidate that satisfies the divisibility requirement &rarr;<strong> <span style=""color: #ff0000;"">60357289</span></strong>
4357289 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {0, 1, 6} &rarr;   Numbers in this set don't satisfy the divisibility requirement &rarr; discard 4357289
6357289 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {0, 1, 4} &rarr; <strong><i>d</i><sub>3 </sub></strong>= 0 is the only candidate that satisfies the divisibility requirement &rarr;<strong> <span style=""color: #ff0000;"">06357289</span></strong>

<p><strong><i><strong><i>d</i><sub>3</sub></strong>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>30952867</strong><strong>, <strong>60357289</strong>, <strong>06357289</strong></strong></span>}</p>

<p><strong><i>d</i></strong><sub><strong>1</strong> </sub>and <strong><i>d</i></strong><sub><strong>2</strong> </sub>do not have any restriction except for the fact that they can be either <strong>1</strong> or<strong> 4</strong>, the only 2 digits left from 0 - 9. From the set above, there are only 6 simple permutations left to complete the sequence <strong><i>d</i></strong><sub><strong>1</strong></sub><strong><i>d</i></strong><sub><strong>2</strong></sub><strong><i><strong><i>d</i><sub>3</sub></strong>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>

<div align=""center""><p><b><i> <strong><i>d</i></strong><sub><strong>1</strong></sub><strong><i>d</i></strong><sub><strong>2</strong></sub><strong><i><strong><i>d</i><sub>3</sub></strong>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>= {<span style=""color: #ff0000;"">1430952867</strong></span><strong><span style=""color: #ff0000;"">, 14<strong>60357289 </strong>, 14</span><strong><span style=""color: #ff0000;"">06357289, 41<strong>30952867</strong><strong>, 41<strong>60357289 </strong>, 41<strong>06357289</strong></strong></span>}</strong></strong></i></b>

Sum = <i>1430952867 + 1460357289 + 1406357289 + 4130952867 + 4160357289 + 4106357289</i><b><i><strong><strong><strong><strong> = <span style=""color: #ff0000;"">16695334890</span></strong></strong></strong></strong></i></b></div>
		
[java]Execution time: 3 ms.[/java]","Problem 43: Sub-string Divisibility",,"publish","closed","closed",,"p43",,,"2014-06-15 07:09:51","2014-06-15 07:09:51",,"0","http://euler.lvtran.com/?p=124","0","post",,"0"
"125","1","2014-06-15 06:45:35","2014-06-15 06:45:35","<h2>The Problem</h2> 
<p>The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.
<p>Let <i>d</i><sub>1</sub> be the 1<sup>st</sup> digit, <i>d</i><sub>2</sub> be the 2<sup>nd</sup> digit, and so on. In this way, we note the following:

<i>d</i><sub>2</sub><i>d</i><sub>3</sub><i>d</i><sub>4</sub>= 406 is divisible by 2
<i>d</i><sub>3</sub><i>d</i><sub>4</sub><i>d</i><sub>5</sub>= 063 is divisible by 3
<i>d</i><sub>4</sub><i>d</i><sub>5</sub><i>d</i><sub>6</sub>= 635 is divisible by 5
<i>d</i><sub>5</sub><i>d</i><sub>6</sub><i>d</i><sub>7</sub>= 357 is divisible by 7
<i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub>= 572 is divisible by 11
<i>d</i><sub>7</sub><i>d</i><sub>8</sub><i>d</i><sub>9</sub>= 728 is divisible by 13
<i>d</i><sub>8</sub><i>d</i><sub>9</sub><i>d</i><sub>10</sub>= 289 is divisible by 17

<p>Find the sum of all 0 to 9 pandigital numbers with this property.</p>

<h2>The Catch</h2>
<p>If we want to brute force the solution by going through all pandigital numbers, it will require a permutation algorithm (rather difficult to implement and understand) and might take several hundred milliseconds.</p>
			
<h2>The Light and The Code</h2>
<p>To help with the analysis below, it will be useful to have a method that checks whether a number contains repeated digits. The algorithm is fairly simple: parse the number into String and traverse through each character. Keep track of each character and return immediately when a second instance of any character is found.
[java]
public static boolean hasRepeatDigit(int n)
{
  if(n &lt; 10)
    return false;

  char[] found = new char[10];
  String s = Integer.toString(n);
  found[Character.getNumericValue(s.charAt(0))] = s.charAt(0);

  for(int i = 1; i &lt; s.length(); i++)
  {
    if(s.charAt(i) == found[Character.getNumericValue(s.charAt(i))])
      return true;
    else
      found[Character.getNumericValue(s.charAt(i))] = s.charAt(i);  
  }
  return false;
}
[/java]

<p>Analyzing smaller groups of digits using their given divisibility properties:
&diams; <strong><i>d</i><sub>4</sub><i>d</i><sub>5</sub><i>d</i></strong><sub><strong>6</strong> </sub>is divisible by <strong>5</strong>, which means <strong><i>d</i></strong><sub><strong>6</strong> </sub>must be <strong>0</strong> or <strong>5</strong>.
&diams; If <strong><i>d</i></strong><sub><strong>6</strong></sub> is <strong>0</strong>, then <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong> is divisible by <strong>11</strong> if and only if <strong><i>d</i><sub>7 </sub></strong>= <strong><i>d</i><sub>8</sub></strong>, or in another word, <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8 </sub></strong>= {011, 022, 033, 044, 055, 066, 077, 088, 099}. Pandigital numbers cannot have repeated digits, so <i>d</i><sub>6</sub> cannot be 0; <strong><span style=""color: #ff0000;""><i>d</i><sub>6</sub> = 5</span></strong>.
&diams; Since <strong><i>d</i><sub>6</sub> = 5</strong>, we can find all possible values for <strong><i>d</i><sub>7<i> </i></sub></strong>and <strong><i>d</i><sub>8</sub></strong> by looking for all numbers between 501 and 598 that are divisible by 11 and has no repeated digits.

[java]
  //Check d6d7d8 for divisibility by 11
  List d6d7d8 = new ArrayList();
  for(int i = 501; i &lt;= 598; i++)
  {
    if((i % 11 == 0) &amp;&amp; (i % 10 != 5) &amp;&amp; (i % 100/10 != 5) &amp;&amp; (i % 10 != i % 100/10) &amp;&amp; !hasRepeatDigit(i))
    {
      System.out.print(i + "" "");
      d6d7d8.add(i);
    }
  }
  System.out.println();
[/java]

<p>This outputs <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong> = {<span style=""color: #ff0000;""><strong>506, 517, 528, 539, 561, 572, 583, 594</strong><span style=""color: #000000;"">}</span></span>. Now that the sequence <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong> is formulated, limiting the possible values for the sequence <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9 </sub></strong>  by adding <strong><i>d</i><sub>9</sub></strong>
[java]
  //Check d6d7d8d9 
  List d6d7d8d9 = new ArrayList();
  for(int i = 0; i &lt; d6d7d8.size(); i++)
  {
    for( int d9 = 0; d9 &lt;= 9; d9++ )
    {
      int tmp = (d6d7d8.get(i) - 500) * 10 + d9;
      if(tmp % 13 == 0 &amp;&amp; !hasRepeatDigit(tmp + 5000))
      {
        System.out.print((5000 + tmp) + "" "");
        d6d7d8d9.add(5000 + tmp);
      }
    }
  }
  System.out.println();
[/java]

<p>This outputs <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9 </sub></strong>= {<strong><span style=""color: #ff0000;"">5286, 5390, 5728, 5832</span></strong>}. Similarly, add <strong><i>d</i><sub>10 </sub></strong>to find the sequence <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>
[java]
  //Check d8d9d10 for divisibility by 17
  List d6d7d8d9d10 = new ArrayList();
  for(int i = 0; i &lt; d6d7d8d9.size(); i++)
  {
    int d8d9 = d6d7d8d9.get(i) % 100;
    for(int d10 = 0; d10 &lt;= 9; d10++)
    {
      if((d8d9 * 10 + d10) % 17 == 0 &amp;&amp; !hasRepeatDigit(d6d7d8d9.get(i) * 10 + d10))
      {
        System.out.print( (d6d7d8d9.get(i) * 10 + d10) + "" "");
        d6d7d8d9d10.add((d6d7d8d9.get(i) * 10 + d10));
      }
    }
  }
  System.out.println();
[/java]

<p>This outputs <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>52867, 53901, 57289</strong></span>}. Continue with <strong><i>d</i><sub>5</sub><i></i></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>

[java]
  //Check d5d6d7 for divisibility by 7
  List d5d6d7d8d9d10 = new ArrayList();
  for(int i = 0; i &lt; d6d7d8d9d10.size(); i++)
  {
    int d6d7 = d6d7d8d9d10.get(i)/1000; 
    for(int d5 = 0; d5 &lt;= 9; d5++)
    {
      if((d5 * 100 + d6d7) % 7 == 0 &amp;&amp; !hasRepeatDigit(d5 * 100000 + d6d7d8d9d10.get(i)))
      {
        System.out.print((d5 * 100000 + d6d7d8d9d10.get(i)) + "" "");
        d5d6d7d8d9d10.add((d5 * 100000 + d6d7d8d9d10.get(i)));
      }
    }
  }
  System.out.println();
[/java]
	
<p>This outputs <strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>9</strong><strong>52867, 357289</strong></span>}. <strong><i>d</i><sub>2</sub><i>d</i><sub>3</sub><i>d</i><sub>4 </sub></strong>is divisible by 2, so <strong><i>d</i><sub>4</sub></strong><strong><sub> </sub></strong>must be an even number. Add <strong><i>d</i><sub>4</sub></strong> to the sequence <strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub></sub></strong>
[java]
  //Add (even) d4 to the sequence d5d6d7d8d9d10
  List d4d5d6d7d8d9d10 = new ArrayList();
  for(int i = 0; i &lt; d5d6d7d8d9d10.size(); i++)
  {
    for(int d4 = 0; d4 &lt; 9; d4 += 2)
    {
      if(!hasRepeatDigit((d4 * 1000000 + d5d6d7d8d9d10.get(i))))
      { 
        if(d4 == 0)
        {
          System.out.print(d4 * 1000000);
          System.out.print(d5d6d7d8d9d10.get(i) + "" "");
          d4d5d6d7d8d9d10.add(d4 * 1000000 + d5d6d7d8d9d10.get(i)); //Special leading 0 cases
        }
        else
        {
          System.out.print((d4 * 1000000 + d5d6d7d8d9d10.get(i)) + "" "");
          d4d5d6d7d8d9d10.add(d4 * 1000000 + d5d6d7d8d9d10.get(i));
        }
      }
    }
  }
  System.out.println();
[/java]
	
<p>This outputs <strong><i>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>0952867, 4952867, 0357289, 4357289, 6357289</strong></span>}</p>

<p>Now there are only 3 digits left to determine; we can switch to manual mode! Judging from the set above and the fact that <strong><i>d</i><sub>3 </sub><i>+ d</i><sub>4 </sub><i>+ d</i></strong><sub><strong>5</strong> </sub>must be divisible by <strong>3</strong>:
<p>
0952867 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {1, 3, 4} &rarr; <strong><i>d</i><sub>3 </sub></strong>= 3 is the only candidate that satisfies the divisibility requirement &rarr;<strong><span style=""color: #ff0000;""> 30952867</span></strong>
4952867 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {0, 1, 3} &rarr; Numbers in this set don't satisfy the divisibility requirement &rarr; discard 4952867
0357289 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {1, 4, 6} &rarr; <strong><i>d</i><sub>3 </sub></strong>= 6 is the only candidate that satisfies the divisibility requirement &rarr;<strong> <span style=""color: #ff0000;"">60357289</span></strong>
4357289 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {0, 1, 6} &rarr;   Numbers in this set don't satisfy the divisibility requirement &rarr; discard 4357289
6357289 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {0, 1, 4} &rarr; <strong><i>d</i><sub>3 </sub></strong>= 0 is the only candidate that satisfies the divisibility requirement &rarr;<strong> <span style=""color: #ff0000;"">06357289</span></strong>

<p><strong><i><strong><i>d</i><sub>3</sub></strong>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>30952867</strong><strong>, <strong>60357289</strong>, <strong>06357289</strong></strong></span>}</p>

<p><strong><i>d</i></strong><sub><strong>1</strong> </sub>and <strong><i>d</i></strong><sub><strong>2</strong> </sub>do not have any restriction except for the fact that they can be either <strong>1</strong> or<strong> 4</strong>, the only 2 digits left from 0 - 9. From the set above, there are only 6 simple permutations left to complete the sequence <strong><i>d</i></strong><sub><strong>1</strong></sub><strong><i>d</i></strong><sub><strong>2</strong></sub><strong><i><strong><i>d</i><sub>3</sub></strong>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>

<div align=""center""><p><b><i> <strong><i>d</i></strong><sub><strong>1</strong></sub><strong><i>d</i></strong><sub><strong>2</strong></sub><strong><i><strong><i>d</i><sub>3</sub></strong>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>= {<span style=""color: #ff0000;"">1430952867</strong></span><strong><span style=""color: #ff0000;"">, 14<strong>60357289 </strong>, 14</span><strong><span style=""color: #ff0000;"">06357289, 41<strong>30952867</strong><strong>, 41<strong>60357289 </strong>, 41<strong>06357289</strong></strong></span>}</strong></strong></i></b>

Sum = <i>1430952867 + 1460357289 + 1406357289 + 4130952867 + 4160357289 + 4106357289</i><b><i><strong><strong><strong><strong> = <span style=""color: #ff0000;"">16695334890</span></strong></strong></strong></strong></i></b></div>
		
[java]Execution time: 3 ms.[/java]","Problem 43: Sub-string Divisibility",,"inherit","open","open",,"124-revision-v1",,,"2014-06-15 06:45:35","2014-06-15 06:45:35",,"124","http://euler.lvtran.com/124-revision-v1/","0","revision",,"0"
"126","1","2013-11-10 06:46:08","2013-11-10 06:46:08","<p>The <i>n</i><sup>th</sup> term of the sequence of triangle numbers is given by, <i>t<sub>n</sub></i> = 0.5<i>n</i>(<i>n</i>+1); so the first ten triangle numbers are: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
<p>By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is 19 + 11 + 25 =55 = <i>t</i><sub>10</sub>. If the word value is a triangle number then we shall call the word a triangle word.
<p>Using <a href=""http://www.lvtran.com/wp-content/uploads/2014/02/words.txt"">words.txt</a> (right click and 'Save Link/Target As...'), a 16K text file containing nearly two-thousand common English words, how many are triangle words?</p><!--more-->



<h2>The Catch</h2>
<p style=""margin-right: 30px;"">How to check if a number is a triangle numbers.
How to find the value of a word.</p>

<h2>The Light</h2>
<p>&clubs; Since a triangle number t is formulated by <i>t<sub>n</sub></i> = 0.5<i>n</i>(<i>n</i>+1), any number that satisfies the <a href=""http://en.wikipedia.org/wiki/Inverse_function"" target=""_blank"">inverse </a>of this equation is a triangle number.

t = 0.5*n(n + 1)
0 = 0.5*n(n + 1) - t
0 = n(n + 1) - 2t
0 = n<sup>2 </sup>+ n - 2t
<p>Use quadratic formula to solve for n:
n = (-1 + sqrt(1 + 8t))/2
n = (-1 - sqrt(1 + 8t))/2
Since n &gt; 0 (given), the second solution is eliminated. A number t is a triangle number if it makes the first solution an integer.</p>
<p>&clubs; Use the discussion in <a href=""http://lvtran.com/p22/"">Problem 22</a> to find the value of a word based on their letters' position on the alphabet. Also, use Java's <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html"" target=""_blank"">Scanner </a>class to read input from words.txt file.</p>

<h2>The Code</h2>
[java]
import java.util.*;
import java.io.*;

public class Problem42
{
  public static void main(String[] args) throws FileNotFoundException
  {
    Scanner scan = new Scanner(new File(""words.txt""));
    int count = 0;

    String input = scan.nextLine();
    String[] s = input.split("","");

    for(int i = 0; i &lt; s.length; i++)
    {
      String word = s[i].substring(1, s[i].length() -1);
      int t = value(word);
      double n = (Math.sqrt(1 + 8 * t) - 1) / 2.0;
      if( n == (int)n )
        count++;
    }

    System.out.println(""Total number of triangle words : "" + count);    
  }

  public static int value(String word)
  {
    int result = 0;
    int A = (int)'A';
    char[] c = word.toCharArray();

    for(int i = 0; i &lt; c.length; i++)
    {
      int position = (int)c[i] - A + 1;
      result += position;
    }
    return result;
  }
}
[/java]
[java]Execution time: 53 ms.[/java]","Problem 42: Coded Triangle Numbers",,"publish","closed","closed",,"p42",,,"2014-06-15 07:09:40","2014-06-15 07:09:40",,"0","http://euler.lvtran.com/?p=126","0","post",,"0"
"127","1","2014-06-15 06:46:08","2014-06-15 06:46:08","<p>The <i>n</i><sup>th</sup> term of the sequence of triangle numbers is given by, <i>t<sub>n</sub></i> = 0.5<i>n</i>(<i>n</i>+1); so the first ten triangle numbers are: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
<p>By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is 19 + 11 + 25 =55 = <i>t</i><sub>10</sub>. If the word value is a triangle number then we shall call the word a triangle word.
<p>Using <a href=""http://www.lvtran.com/wp-content/uploads/2014/02/words.txt"">words.txt</a> (right click and 'Save Link/Target As...'), a 16K text file containing nearly two-thousand common English words, how many are triangle words?</p><!--more-->



<h2>The Catch</h2>
<p style=""margin-right: 30px;"">How to check if a number is a triangle numbers.
How to find the value of a word.</p>

<h2>The Light</h2>
<p>&clubs; Since a triangle number t is formulated by <i>t<sub>n</sub></i> = 0.5<i>n</i>(<i>n</i>+1), any number that satisfies the <a href=""http://en.wikipedia.org/wiki/Inverse_function"" target=""_blank"">inverse </a>of this equation is a triangle number.

t = 0.5*n(n + 1)
0 = 0.5*n(n + 1) - t
0 = n(n + 1) - 2t
0 = n<sup>2 </sup>+ n - 2t
<p>Use quadratic formula to solve for n:
n = (-1 + sqrt(1 + 8t))/2
n = (-1 - sqrt(1 + 8t))/2
Since n &gt; 0 (given), the second solution is eliminated. A number t is a triangle number if it makes the first solution an integer.</p>
<p>&clubs; Use the discussion in <a href=""http://lvtran.com/p22/"">Problem 22</a> to find the value of a word based on their letters' position on the alphabet. Also, use Java's <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html"" target=""_blank"">Scanner </a>class to read input from words.txt file.</p>

<h2>The Code</h2>
[java]
import java.util.*;
import java.io.*;

public class Problem42
{
  public static void main(String[] args) throws FileNotFoundException
  {
    Scanner scan = new Scanner(new File(""words.txt""));
    int count = 0;

    String input = scan.nextLine();
    String[] s = input.split("","");

    for(int i = 0; i &lt; s.length; i++)
    {
      String word = s[i].substring(1, s[i].length() -1);
      int t = value(word);
      double n = (Math.sqrt(1 + 8 * t) - 1) / 2.0;
      if( n == (int)n )
        count++;
    }

    System.out.println(""Total number of triangle words : "" + count);    
  }

  public static int value(String word)
  {
    int result = 0;
    int A = (int)'A';
    char[] c = word.toCharArray();

    for(int i = 0; i &lt; c.length; i++)
    {
      int position = (int)c[i] - A + 1;
      result += position;
    }
    return result;
  }
}
[/java]
[java]Execution time: 53 ms.[/java]","Problem 42: Coded Triangle Numbers",,"inherit","open","open",,"126-revision-v1",,,"2014-06-15 06:46:08","2014-06-15 06:46:08",,"126","http://euler.lvtran.com/126-revision-v1/","0","revision",,"0"
"128","1","2013-11-11 06:46:45","2013-11-11 06:46:45","<p>We shall say that an <i>n</i>-digit number is pandigital if it makes use of all the digits 1 to <i>n</i> exactly once. For example, 2143 is a 4-digit pandigital and is also prime.
<p>What is the largest <i>n</i>-digit pandigital prime that exists?</p><!--more-->



<h2>The Catch</h2>
<p style=""margin-right: 30px;"">How to check if a number is pandigital.
How to efficiently check if pandigital numbers are also prime, since checking from 2 to 978,654,321 is extremely time consuming.</p>

<h2>The Light</h2>
<p>&clubs; A pandigital number uses each digit from 1 - 9 exactly once, thus there are essentially 9 ""templates"" for pandigital numbers. The only 1-digit pandigital number is 1. If you take the digits from any 2-digit pandigital number and sort them numerically, you will get <strong>12</strong>. Similarly, if you take the digits from any 3-digit pandigital number and sort them numerically, you will get <strong>123.</strong> This concept applies for all pandigital numbers, so make 9 static template pandigital numbers. To check if a number with n-digits is pandigital, sort all digits numerically and if the result matches with n-digit template, then the number is pandigital.
			
<p>&clubs; Recall that a number is divisible by 3 if and only if the digit sum of the number is divisible by 3. The list below shows that only 4-digit and 7-digit pandigital numbers can be prime, since the others are divisible by 3. Thus first check from the largest 7-digit pandigital number downward for the largest instance of a pandigital-prime-number. If it is not found, move to the 4-digit numbers range.
<p>
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 = 3
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 = 6
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 = 10
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 + 5 = 15
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 + 5 + 6 = 21
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 + 5 + 6 + 7 = 28
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45

<p>&clubs; Since primes are odd, eliminate all even numbers in the search to speed up execution. Use discussion in <a href=""http://lvtran.com/p3/"">Problem 3</a> to check for prime numbers.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem41
{
  public static char[][] p = {""1"".toCharArray(), ""12"".toCharArray(), 
                              ""123"".toCharArray(), ""1234"".toCharArray(),
                              ""12345"".toCharArray(), ""123456"".toCharArray(), 
                              ""1234567"".toCharArray(), ""12345678"".toCharArray(), 
                              ""123456789"".toCharArray()};

  public static void main(String[] args)
  {
    for(int i = 7654321; i &gt; 1000000; i -= 2)
    {
      if(isPan(i))
        if(isPrime(i))
        {
          System.out.println(i);
          break;
        }
    }
  }

  public static boolean isPrime(int n)
  {
    if(n &lt; 2)
      return false;

    if(n != 2 &amp;&amp; n % 2 == 0)
      return false;

    for(int i = 3; i * i &lt; n; i++)
    {
      if(n % i == 0)
        return false;
    }

    return true;
  }

  public static boolean isPan(int n)
  {
    String s = Integer.toString(n);
    char[] c = s.toCharArray();
    Arrays.sort(c);
    return (Arrays.equals(c, p[c.length - 1]));	
  }
}
[/java]
[java]Execution time: 3 ms.[/java]","Problem 41: Pandigital Prime",,"publish","closed","closed",,"p41",,,"2014-06-15 07:09:40","2014-06-15 07:09:40",,"0","http://euler.lvtran.com/?p=128","0","post",,"0"
"129","1","2014-06-15 06:46:45","2014-06-15 06:46:45","<p>We shall say that an <i>n</i>-digit number is pandigital if it makes use of all the digits 1 to <i>n</i> exactly once. For example, 2143 is a 4-digit pandigital and is also prime.
<p>What is the largest <i>n</i>-digit pandigital prime that exists?</p><!--more-->



<h2>The Catch</h2>
<p style=""margin-right: 30px;"">How to check if a number is pandigital.
How to efficiently check if pandigital numbers are also prime, since checking from 2 to 978,654,321 is extremely time consuming.</p>

<h2>The Light</h2>
<p>&clubs; A pandigital number uses each digit from 1 - 9 exactly once, thus there are essentially 9 ""templates"" for pandigital numbers. The only 1-digit pandigital number is 1. If you take the digits from any 2-digit pandigital number and sort them numerically, you will get <strong>12</strong>. Similarly, if you take the digits from any 3-digit pandigital number and sort them numerically, you will get <strong>123.</strong> This concept applies for all pandigital numbers, so make 9 static template pandigital numbers. To check if a number with n-digits is pandigital, sort all digits numerically and if the result matches with n-digit template, then the number is pandigital.
			
<p>&clubs; Recall that a number is divisible by 3 if and only if the digit sum of the number is divisible by 3. The list below shows that only 4-digit and 7-digit pandigital numbers can be prime, since the others are divisible by 3. Thus first check from the largest 7-digit pandigital number downward for the largest instance of a pandigital-prime-number. If it is not found, move to the 4-digit numbers range.
<p>
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 = 3
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 = 6
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 = 10
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 + 5 = 15
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 + 5 + 6 = 21
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 + 5 + 6 + 7 = 28
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36
&nbsp;&nbsp;&nbsp;&nbsp;1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45

<p>&clubs; Since primes are odd, eliminate all even numbers in the search to speed up execution. Use discussion in <a href=""http://lvtran.com/p3/"">Problem 3</a> to check for prime numbers.</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem41
{
  public static char[][] p = {""1"".toCharArray(), ""12"".toCharArray(), 
                              ""123"".toCharArray(), ""1234"".toCharArray(),
                              ""12345"".toCharArray(), ""123456"".toCharArray(), 
                              ""1234567"".toCharArray(), ""12345678"".toCharArray(), 
                              ""123456789"".toCharArray()};

  public static void main(String[] args)
  {
    for(int i = 7654321; i &gt; 1000000; i -= 2)
    {
      if(isPan(i))
        if(isPrime(i))
        {
          System.out.println(i);
          break;
        }
    }
  }

  public static boolean isPrime(int n)
  {
    if(n &lt; 2)
      return false;

    if(n != 2 &amp;&amp; n % 2 == 0)
      return false;

    for(int i = 3; i * i &lt; n; i++)
    {
      if(n % i == 0)
        return false;
    }

    return true;
  }

  public static boolean isPan(int n)
  {
    String s = Integer.toString(n);
    char[] c = s.toCharArray();
    Arrays.sort(c);
    return (Arrays.equals(c, p[c.length - 1]));	
  }
}
[/java]
[java]Execution time: 3 ms.[/java]","Problem 41: Pandigital Prime",,"inherit","open","open",,"128-revision-v1",,,"2014-06-15 06:46:45","2014-06-15 06:46:45",,"128","http://euler.lvtran.com/128-revision-v1/","0","revision",,"0"
"130","1","2013-11-12 06:47:13","2013-11-12 06:47:13","<p>An irrational decimal fraction is created by concatenating the positive integers: 0.12345678910<span style=""color:red"">1</span>112131415161718192021...
<br>It can be seen that the 12<sup>th</sup> digit of the fractional part is 1.
<br>If <i>d</i><sub><i>n</i></sub> represents the <i>n</i><sup>th</sup> digit of the fractional part, find the value of the following expression <i>d</i><sub>1</sub> x <i>d</i><sub>10</sub> x <i>d</i><sub>100</sub> x <i>d</i><sub>1000</sub> x <i>d</i><sub>10000</sub> x <i>d</i><sub>100000</sub> x <i>d</i><sub>1000000</sub></p><!--more-->



<h2>The Catch</h2>
<p>How to quickly construct the irrational number by concatenating incremented-positive-integers.</p>

<h2>The Light</h2>
<p>Use Java's <a href=""http://edelstein.pebbles.cs.cmu.edu/jadeite/main.php?api=java6&amp;state=class&amp;package=java.lang&amp;class=StringBuilder"" target=""_blank"">StringBuilder</a> class to concatenate incremented-positive-integers. Since there is no actual calculation involved, the construction should be very quick. Once the irrational number is constructed, pick out requested indexed-digits and find their product.</p>

<h2>The Code</h2>
[java]
public class Problem40
{
  public static void main(String[] args)
  {
    StringBuilder sb = new StringBuilder(1000000);
    int i = 1;
    int result = 1;

    while(i &lt;= 1000000)
    {
      sb = sb.append(i++);
    }
    String s = sb.toString();

    for(i = 1; i &lt;= 1000000; i *= 10)
    {
      result *= Character.getNumericValue(s.charAt(i - 1));
    }
    System.out.println(""Result = "" + result);
  }
}
[/java]
[java]Execution time: 46 ms.[/java]","Problem 40: Champernowne's Constant",,"publish","closed","closed",,"p40",,,"2014-06-15 07:09:40","2014-06-15 07:09:40",,"0","http://euler.lvtran.com/?p=130","0","post",,"0"
"131","1","2014-06-15 06:47:13","2014-06-15 06:47:13","<p>An irrational decimal fraction is created by concatenating the positive integers: 0.12345678910<span style=""color:red"">1</span>112131415161718192021...
<br>It can be seen that the 12<sup>th</sup> digit of the fractional part is 1.
<br>If <i>d</i><sub><i>n</i></sub> represents the <i>n</i><sup>th</sup> digit of the fractional part, find the value of the following expression <i>d</i><sub>1</sub> x <i>d</i><sub>10</sub> x <i>d</i><sub>100</sub> x <i>d</i><sub>1000</sub> x <i>d</i><sub>10000</sub> x <i>d</i><sub>100000</sub> x <i>d</i><sub>1000000</sub></p><!--more-->



<h2>The Catch</h2>
<p>How to quickly construct the irrational number by concatenating incremented-positive-integers.</p>

<h2>The Light</h2>
<p>Use Java's <a href=""http://edelstein.pebbles.cs.cmu.edu/jadeite/main.php?api=java6&amp;state=class&amp;package=java.lang&amp;class=StringBuilder"" target=""_blank"">StringBuilder</a> class to concatenate incremented-positive-integers. Since there is no actual calculation involved, the construction should be very quick. Once the irrational number is constructed, pick out requested indexed-digits and find their product.</p>

<h2>The Code</h2>
[java]
public class Problem40
{
  public static void main(String[] args)
  {
    StringBuilder sb = new StringBuilder(1000000);
    int i = 1;
    int result = 1;

    while(i &lt;= 1000000)
    {
      sb = sb.append(i++);
    }
    String s = sb.toString();

    for(i = 1; i &lt;= 1000000; i *= 10)
    {
      result *= Character.getNumericValue(s.charAt(i - 1));
    }
    System.out.println(""Result = "" + result);
  }
}
[/java]
[java]Execution time: 46 ms.[/java]","Problem 40: Champernowne's Constant",,"inherit","open","open",,"130-revision-v1",,,"2014-06-15 06:47:13","2014-06-15 06:47:13",,"130","http://euler.lvtran.com/130-revision-v1/","0","revision",,"0"
"132","1","2013-11-02 06:51:31","2013-11-02 06:51:31","<p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18a.png"" alt=""18a"" width=""102"" height=""88"" class=""aligncenter size-full wp-image-247"" />
<p>That is, 3 + 7 + 4 + 9 = 23.
<p>Find the maximum total from top to bottom in <a href=""http://www.lvtran.com/wp-content/uploads/2014/02/triangle.txt"">triangle.txt</a> (right click and 'Save Link/Target As...'), a 15K text file containing a triangle with one-hundred rows.
<b>NOTE:</b> This is a much more difficult version of <a href=""http://lvtran.com/p18/"">Problem 18</a>. It is not possible to try every route to solve this problem, as there are 2<sup>99 </sup>altogether! If you could check one trillion (10<sup>12</sup>) routes every second it would take over twenty billion years to check them all. There is an efficient algorithm to solve it.)</p>
<!--more-->


<h2>The Catch & The Light</h2>
<p>Check <a href=""http://lvtran.com/p18/"" target=""blank"">Problem 18</a> discussion on how to solve this type of problem.</p><br><br>

<h2>The Code</h2>
[java]
import java.io.*;
import java.util.*;

public class Problem67
{
  public static void main(String[] args) throws FileNotFoundException
  {
    int row = 100;
    int rowIndex = 0;
    int[][] tri = new int[row][];

    Scanner scan = new Scanner(new File(""triangle.txt""));
    while(scan.hasNextLine())
    {
      String s = scan.nextLine();
      String[] input = s.split("" "");

      tri[rowIndex] = new int[input.length];
      for(int i = 0; i &lt; input.length; i++)       
      { 	    
        tri[rowIndex][i] = Integer.parseInt(input[i]);       
      }       
      rowIndex++;	    	
    } 	     
    for(int i = row - 1; i &gt; 0; i--)
    {
      int index = 0;
      for(int j = 0; j &lt; tri[i].length - 1; j++, index++)       
      { 	     		
        int tmp1 = tri[i][j] + tri[i - 1][index]; 		
        int tmp2 = tri[i][j + 1] + tri[i - 1][index]; 		
        if(tmp1 &gt; tmp2)
          tri[i - 1][index] = tmp1;
        else
           tri[i - 1][index] = tmp2;
      }  
    }
    System.out.println(""Maximum total from top to bottom: "" + tri[0][0]);
  }
}
[/java]
[java]Execution time: 44 ms.[/java]","Problem 67: Maximum Path Sum 2",,"publish","closed","closed",,"p67",,,"2014-06-15 07:09:53","2014-06-15 07:09:53",,"0","http://euler.lvtran.com/?p=132","0","post",,"0"
"133","1","2014-06-15 06:51:31","2014-06-15 06:51:31","<p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18a.png"" alt=""18a"" width=""102"" height=""88"" class=""aligncenter size-full wp-image-247"" />
<p>That is, 3 + 7 + 4 + 9 = 23.
<p>Find the maximum total from top to bottom in <a href=""http://www.lvtran.com/wp-content/uploads/2014/02/triangle.txt"">triangle.txt</a> (right click and 'Save Link/Target As...'), a 15K text file containing a triangle with one-hundred rows.<!--more-->


<b>NOTE:</b> This is a much more difficult version of <a href=""http://lvtran.com/p18/"">Problem 18</a>. It is not possible to try every route to solve this problem, as there are 2<sup>99 </sup>altogether! If you could check one trillion (10<sup>12</sup>) routes every second it would take over twenty billion years to check them all. There is an efficient algorithm to solve it.)</p>

<h2>The Catch & The Light</h2>
<p>Check <a href=""http://lvtran.com/p18/"" target=""blank"">Problem 18</a> discussion on how to solve this type of problem.</p><br><br>

<h2>The Code</h2>
[java]
import java.io.*;
import java.util.*;

public class Problem67
{
  public static void main(String[] args) throws FileNotFoundException
  {
    int row = 100;
    int rowIndex = 0;
    int[][] tri = new int[row][];

    Scanner scan = new Scanner(new File(""triangle.txt""));
    while(scan.hasNextLine())
    {
      String s = scan.nextLine();
      String[] input = s.split("" "");

      tri[rowIndex] = new int[input.length];
      for(int i = 0; i &lt; input.length; i++)       
      { 	    
        tri[rowIndex][i] = Integer.parseInt(input[i]);       
      }       
      rowIndex++;	    	
    } 	     
    for(int i = row - 1; i &gt; 0; i--)
    {
      int index = 0;
      for(int j = 0; j &lt; tri[i].length - 1; j++, index++)       
      { 	     		
        int tmp1 = tri[i][j] + tri[i - 1][index]; 		
        int tmp2 = tri[i][j + 1] + tri[i - 1][index]; 		
        if(tmp1 &gt; tmp2)
          tri[i - 1][index] = tmp1;
        else
           tri[i - 1][index] = tmp2;
      }  
    }
    System.out.println(""Maximum total from top to bottom: "" + tri[0][0]);
  }
}
[/java]
[java]Execution time: 44 ms.[/java]","Problem 67: Maximum Path Sum 2",,"inherit","open","open",,"132-revision-v1",,,"2014-06-15 06:51:31","2014-06-15 06:51:31",,"132","http://euler.lvtran.com/132-revision-v1/","0","revision",,"0"
"134","1","2014-06-15 06:51:53","2014-06-15 06:51:53","<p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
<img src=""http://www.lvtran.com/wp-content/uploads/2014/02/18a.png"" alt=""18a"" width=""102"" height=""88"" class=""aligncenter size-full wp-image-247"" />
<p>That is, 3 + 7 + 4 + 9 = 23.
<p>Find the maximum total from top to bottom in <a href=""http://www.lvtran.com/wp-content/uploads/2014/02/triangle.txt"">triangle.txt</a> (right click and 'Save Link/Target As...'), a 15K text file containing a triangle with one-hundred rows.
<b>NOTE:</b> This is a much more difficult version of <a href=""http://lvtran.com/p18/"">Problem 18</a>. It is not possible to try every route to solve this problem, as there are 2<sup>99 </sup>altogether! If you could check one trillion (10<sup>12</sup>) routes every second it would take over twenty billion years to check them all. There is an efficient algorithm to solve it.)</p>
<!--more-->


<h2>The Catch & The Light</h2>
<p>Check <a href=""http://lvtran.com/p18/"" target=""blank"">Problem 18</a> discussion on how to solve this type of problem.</p><br><br>

<h2>The Code</h2>
[java]
import java.io.*;
import java.util.*;

public class Problem67
{
  public static void main(String[] args) throws FileNotFoundException
  {
    int row = 100;
    int rowIndex = 0;
    int[][] tri = new int[row][];

    Scanner scan = new Scanner(new File(""triangle.txt""));
    while(scan.hasNextLine())
    {
      String s = scan.nextLine();
      String[] input = s.split("" "");

      tri[rowIndex] = new int[input.length];
      for(int i = 0; i &lt; input.length; i++)       
      { 	    
        tri[rowIndex][i] = Integer.parseInt(input[i]);       
      }       
      rowIndex++;	    	
    } 	     
    for(int i = row - 1; i &gt; 0; i--)
    {
      int index = 0;
      for(int j = 0; j &lt; tri[i].length - 1; j++, index++)       
      { 	     		
        int tmp1 = tri[i][j] + tri[i - 1][index]; 		
        int tmp2 = tri[i][j + 1] + tri[i - 1][index]; 		
        if(tmp1 &gt; tmp2)
          tri[i - 1][index] = tmp1;
        else
           tri[i - 1][index] = tmp2;
      }  
    }
    System.out.println(""Maximum total from top to bottom: "" + tri[0][0]);
  }
}
[/java]
[java]Execution time: 44 ms.[/java]","Problem 67: Maximum Path Sum 2",,"inherit","open","open",,"132-revision-v1",,,"2014-06-15 06:51:53","2014-06-15 06:51:53",,"132","http://euler.lvtran.com/132-revision-v1/","0","revision",,"0"
"135","1","2013-11-03 06:52:30","2013-11-03 06:52:30","<p>A googol (10<sup>100</sup>) is a massive number: one followed by one-hundred zeros; 100<sup>100</sup> is almost unimaginably large: one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only 1. Considering natural numbers of the form, <i>a<sup>b</sup></i>, where <i>a, b</i> < 100, what is the maximum digital sum?</p><!--more-->



<h2>The Catch</h2>
<p>Even with the help from Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" 			target=""_blank"">BigInteger</a> class, looping from a = b = 2 to a = b = 99 (That's 98 * 98 = 9604 iterations) is very costly; the search range needs to be minimized.</p>

<h2>The Light</h2>
<p>&clubs; Knowing how many digits the number <i>a<sup>b</sup></i> has without having to calculate its actual value is going to be very useful. To achieve this, use the formula <strong>(int)(b * log a) + 1</strong>. For example, the number 81<sup>2</sup> has (int)(2 * log 81) + 1 = (int)3.90848501888 + 1 = 3 + 1 = <strong>4</strong> digits.
<p>&clubs; Another useful concept is <em>Expected Digit Sum</em>, which can be calculated by multiplying the number of digits by <strong>4.5</strong>. The reason: 4.5 is the mean of all digits ( (0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)/10 = 45/10 = <strong>4.5</strong>). So if these digits are distributed equally within a number, then the number's digit sum can be approximated by the mentioned formula. <br>
For example, the number 1234567890 has 10 digits and its expected digit sum is 10 * 4.5 = 45 and its actual digit sum is 45. The number 123456789 has 9 digits and its expected digit sum 				is 9 * 4.5 = 40.5 and its actual digit sum is 45. This is a fairly good estimation for larger numbers.
<p>&clubs; Using these concepts, consider the number <strong>90<sup>90</sup></strong>, which has 176 digits and whose expected digit	sum is 792 and the number <strong>90<sup>99</sup></strong>, which has 194 digits and whose expected digit sum is 873. Generally, more digits means greater digit sum. It can be seen that the maximum digit sum is not in the range from a = b = 2 to a = b = 90 (because <strong>90<sup>99</sup></strong> has more digits and thus a greater digit sum than <strong>90<sup>90</sup></strong>). Thus, it is safe to start the search range from <strong>a = b = 90</strong>.
<p>&clubs; Having the search range minimized, a brute force approach can be implemented using Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html""target=""_blank"">BigInteger</a> class. Use the discussion about ASCII values in <a href=""http://lvtran.com/p22/"" target=""_blank"">Problem 22</a> to tweak the method that calculates the digit sum.</p>

<h2>The Code</h2>
[java]
import java.math.*;

public class Problem56
{
  public static void main(String[] args)
  {
    int max = 0;

    for(int a = 90; a &lt;= 100; a++)
    {
      for(int b = 90; b &lt;= 100; b++)       
      {
        BigInteger base = new BigInteger(Integer.toString(a));         
        BigInteger tmp = base.pow(b); 	         
        int digitSum = digitSum(tmp.toString()); 		         
        if(digitSum &gt; max)
          max = digitSum;
      }
    }
    System.out.println(max);
  }

  public static int digitSum(String n)
  {
    char[] digit = n.toCharArray();
    int sum = 0;
    for(int i = 0; i &lt; digit.length; i++)
    {
      sum += ((int)digit[i] - 48); //48 is ASCII value for '0'
    }
    return sum;
  }
}
[/java]
[java]Execution time: 18 ms.[/java]","Problem 56: Powerful Digit Sum",,"publish","closed","closed",,"p56",,,"2014-06-15 07:09:53","2014-06-15 07:09:53",,"0","http://euler.lvtran.com/?p=135","0","post",,"0"
"136","1","2014-06-15 06:52:30","2014-06-15 06:52:30","<p>A googol (10<sup>100</sup>) is a massive number: one followed by one-hundred zeros; 100<sup>100</sup> is almost unimaginably large: one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only 1. Considering natural numbers of the form, <i>a<sup>b</sup></i>, where <i>a, b</i> < 100, what is the maximum digital sum?</p><!--more-->



<h2>The Catch</h2>
<p>Even with the help from Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" 			target=""_blank"">BigInteger</a> class, looping from a = b = 2 to a = b = 99 (That's 98 * 98 = 9604 iterations) is very costly; the search range needs to be minimized.</p>

<h2>The Light</h2>
<p>&clubs; Knowing how many digits the number <i>a<sup>b</sup></i> has without having to calculate its actual value is going to be very useful. To achieve this, use the formula <strong>(int)(b * log a) + 1</strong>. For example, the number 81<sup>2</sup> has (int)(2 * log 81) + 1 = (int)3.90848501888 + 1 = 3 + 1 = <strong>4</strong> digits.
<p>&clubs; Another useful concept is <em>Expected Digit Sum</em>, which can be calculated by multiplying the number of digits by <strong>4.5</strong>. The reason: 4.5 is the mean of all digits ( (0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)/10 = 45/10 = <strong>4.5</strong>). So if these digits are distributed equally within a number, then the number's digit sum can be approximated by the mentioned formula. <br>
For example, the number 1234567890 has 10 digits and its expected digit sum is 10 * 4.5 = 45 and its actual digit sum is 45. The number 123456789 has 9 digits and its expected digit sum 				is 9 * 4.5 = 40.5 and its actual digit sum is 45. This is a fairly good estimation for larger numbers.
<p>&clubs; Using these concepts, consider the number <strong>90<sup>90</sup></strong>, which has 176 digits and whose expected digit	sum is 792 and the number <strong>90<sup>99</sup></strong>, which has 194 digits and whose expected digit sum is 873. Generally, more digits means greater digit sum. It can be seen that the maximum digit sum is not in the range from a = b = 2 to a = b = 90 (because <strong>90<sup>99</sup></strong> has more digits and thus a greater digit sum than <strong>90<sup>90</sup></strong>). Thus, it is safe to start the search range from <strong>a = b = 90</strong>.
<p>&clubs; Having the search range minimized, a brute force approach can be implemented using Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html""target=""_blank"">BigInteger</a> class. Use the discussion about ASCII values in <a href=""http://lvtran.com/p22/"" target=""_blank"">Problem 22</a> to tweak the method that calculates the digit sum.</p>

<h2>The Code</h2>
[java]
import java.math.*;

public class Problem56
{
  public static void main(String[] args)
  {
    int max = 0;

    for(int a = 90; a &lt;= 100; a++)
    {
      for(int b = 90; b &lt;= 100; b++)       
      {
        BigInteger base = new BigInteger(Integer.toString(a));         
        BigInteger tmp = base.pow(b); 	         
        int digitSum = digitSum(tmp.toString()); 		         
        if(digitSum &gt; max)
          max = digitSum;
      }
    }
    System.out.println(max);
  }

  public static int digitSum(String n)
  {
    char[] digit = n.toCharArray();
    int sum = 0;
    for(int i = 0; i &lt; digit.length; i++)
    {
      sum += ((int)digit[i] - 48); //48 is ASCII value for '0'
    }
    return sum;
  }
}
[/java]
[java]Execution time: 18 ms.[/java]","Problem 56: Powerful Digit Sum",,"inherit","open","open",,"135-revision-v1",,,"2014-06-15 06:52:30","2014-06-15 06:52:30",,"135","http://euler.lvtran.com/135-revision-v1/","0","revision",,"0"
"137","1","2013-11-04 06:52:56","2013-11-04 06:52:56","<p>The series, 1<sup>1</sup> + 2<sup>2</sup> + 3<sup>3</sup> + ... + 10<sup>10</sup> = 10405071317.
<br>Find the  last ten digits of the series, 1<sup>1</sup> + 2<sup>2</sup> + 3<sup>3</sup> + ... + 1000<sup>1000</sup>.</p><!--more-->



<h2>The Catch</h2>
<p>How to store and quickly calculate extremely large numbers.</p><br><br>

<h2>The Light</h2>
<p>Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem48
{
  public static void main(String[] args)
  {
    BigInteger result = BigInteger.ZERO;
    BigInteger i = BigInteger.ONE;
    BigInteger index = BigInteger.ONE;
    BigInteger one = BigInteger.ONE;
    BigInteger limit = new BigInteger(""1001"");
    int exp = 1;

    for(; index.compareTo(limit) == -1; index = index.add(one))
    {
      BigInteger tmp = i.pow(exp++);
      result = result.add(tmp);
      i = i.add(one);
    }
    String s = result.toString();
    s = s.substring(s.length() - 10, s.length());
    System.out.println(""Last 10 digits are "" + s);
 }
}
[/java]
[java]Execution time: 66 ms.[/java]","Problem 56: Powerful Digit Sum",,"publish","closed","closed",,"p48",,,"2014-06-15 07:09:53","2014-06-15 07:09:53",,"0","http://euler.lvtran.com/?p=137","0","post",,"0"
"138","1","2014-06-15 06:52:56","2014-06-15 06:52:56","<p>The series, 1<sup>1</sup> + 2<sup>2</sup> + 3<sup>3</sup> + ... + 10<sup>10</sup> = 10405071317.
<br>Find the  last ten digits of the series, 1<sup>1</sup> + 2<sup>2</sup> + 3<sup>3</sup> + ... + 1000<sup>1000</sup>.</p><!--more-->



<h2>The Catch</h2>
<p>How to store and quickly calculate extremely large numbers.</p><br><br>

<h2>The Light</h2>
<p>Use Java's <a href=""http://docs.oracle.com/javase/1.4.2/docs/api/java/math/BigInteger.html"" target=""_blank"">BigInteger</a> class.</p>

<h2>The Code</h2>
[java]
import java.math.BigInteger;

public class Problem48
{
  public static void main(String[] args)
  {
    BigInteger result = BigInteger.ZERO;
    BigInteger i = BigInteger.ONE;
    BigInteger index = BigInteger.ONE;
    BigInteger one = BigInteger.ONE;
    BigInteger limit = new BigInteger(""1001"");
    int exp = 1;

    for(; index.compareTo(limit) == -1; index = index.add(one))
    {
      BigInteger tmp = i.pow(exp++);
      result = result.add(tmp);
      i = i.add(one);
    }
    String s = result.toString();
    s = s.substring(s.length() - 10, s.length());
    System.out.println(""Last 10 digits are "" + s);
 }
}
[/java]
[java]Execution time: 66 ms.[/java]","Problem 48: Self Powers",,"inherit","open","open",,"137-revision-v1",,,"2014-06-15 06:52:56","2014-06-15 06:52:56",,"137","http://euler.lvtran.com/137-revision-v1/","0","revision",,"0"
"139","1","2013-11-05 06:53:26","2013-11-05 06:53:26","<p style=""margin-right: 30px;"">The first two consecutive numbers to have two distinct prime factors are:
14 = 2 x 7
15 = 3 x 5

<p>The first three consecutive numbers to have three distinct prime factors are:
644 = 2<sup>2</sup> x 7 x 23
645 = 3 x 5 x 43
646 = 2 x 17 x 19.

<p>Find the first four consecutive integers to have four distinct prime factors. What is the first of these numbers?</p><!--more-->



<h2>The Catch</h2>
<p>How to find the number of distinct prime factors.</p>

<h2>The Light</h2>
<p>&clubs; If we use prime factorization as discussed in <a href=""http://lvtran.com/p3/"">Problem 3</a> to find a number's prime factors. Count repeated prime factors once only. This traditional prime factorization algorithm is, however, not as efficient when dealing with large number.

<br>Prime factorize 812:
812 / 2 = 406
406 / 2 = 203
203 % 2 != 0 (skip 2)
203 % 3 != 0 (skip 3)
203 / 7 = 29 
29 % 11 != 0 (skip 11)
29 % 13 != 0 (skip 13)
29 % 17 != 0 (skip 17)
29 % 19 != 0 (skip 19)
29 % 23 != 0 (skip 23)
29 / 29 = 1

<p>There is a series of primes numbers that are being checked unnecessarily after 7. For even larger numbers, this series of skipped primes will greatly slow down the execution time. 
<br>It is important to notice that after 7, there is only 1 prime factor left. Also notice that this last prime factor is greater than sqrt(812) = 28.4956. This is due to the fact that for any given 			integer n, there is only 1 prime factor that is greater than &radic;n. Use this fact to eliminate all unncessary checks.
<p style=""margin-right: 30px;"">&clubs; To prime factorize, you will need a list of precalculated 			prime numbers, which can be achieved using the <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes""> Sieve of Eratosthenes			</a> as discussed in <a href=""http://lvtran.com/p35/"">Problem 35</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem47
{
  static List prime = generatePrimes(100000);

  public static void main(String[] args)
  {
    int count = 0;
	int result = 0;

	for(int i = 647; count != 4; i++)
	{
	  if(numOfDistinctPrimeFactors(i) == 4)
	  {
	    count++;
	    result = i;
	  }
	  else
	    count = 0;
	}
	System.out.println(result - 3);
  }
  
  public static int numOfDistinctPrimeFactors(int n)
  {
    int distinct = 0;
	for(int i = 0;; i++)
	{
      if ((int)prime.get(i) * (int)prime.get(i) > n)
		return ++distinct;
     
	  if(n % (int)prime.get(i) == 0)
	    distinct++;
	  else
	    continue;
		
	  while(n % (int)prime.get(i) == 0 && n > 1)
	  {
	    System.out.println(prime.get(i));
	    n /= (int)prime.get(i);
	  }
	  if(n == 1)
	    break;
	}
	return distinct;
  }
  
  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i <= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j <= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();
 
    for (int i = 2; i <= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 89 ms.[/java]","Problem 47: Distinct Prime Factors",,"publish","closed","closed",,"p47-2",,,"2014-06-15 07:09:52","2014-06-15 07:09:52",,"0","http://euler.lvtran.com/?p=139","0","post",,"0"
"140","1","2014-06-15 06:53:26","2014-06-15 06:53:26","<p style=""margin-right: 30px;"">The first two consecutive numbers to have two distinct prime factors are:
14 = 2 x 7
15 = 3 x 5

<p>The first three consecutive numbers to have three distinct prime factors are:
644 = 2<sup>2</sup> x 7 x 23
645 = 3 x 5 x 43
646 = 2 x 17 x 19.

<p>Find the first four consecutive integers to have four distinct prime factors. What is the first of these numbers?</p><!--more-->



<h2>The Catch</h2>
<p>How to find the number of distinct prime factors.</p>

<h2>The Light</h2>
<p>&clubs; If we use prime factorization as discussed in <a href=""http://lvtran.com/p3/"">Problem 3</a> to find a number's prime factors. Count repeated prime factors once only. This traditional prime factorization algorithm is, however, not as efficient when dealing with large number.

<br>Prime factorize 812:
812 / 2 = 406
406 / 2 = 203
203 % 2 != 0 (skip 2)
203 % 3 != 0 (skip 3)
203 / 7 = 29 
29 % 11 != 0 (skip 11)
29 % 13 != 0 (skip 13)
29 % 17 != 0 (skip 17)
29 % 19 != 0 (skip 19)
29 % 23 != 0 (skip 23)
29 / 29 = 1

<p>There is a series of primes numbers that are being checked unnecessarily after 7. For even larger numbers, this series of skipped primes will greatly slow down the execution time. 
<br>It is important to notice that after 7, there is only 1 prime factor left. Also notice that this last prime factor is greater than sqrt(812) = 28.4956. This is due to the fact that for any given 			integer n, there is only 1 prime factor that is greater than &radic;n. Use this fact to eliminate all unncessary checks.
<p style=""margin-right: 30px;"">&clubs; To prime factorize, you will need a list of precalculated 			prime numbers, which can be achieved using the <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes""> Sieve of Eratosthenes			</a> as discussed in <a href=""http://lvtran.com/p35/"">Problem 35</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem47
{
  static List prime = generatePrimes(100000);

  public static void main(String[] args)
  {
    int count = 0;
	int result = 0;

	for(int i = 647; count != 4; i++)
	{
	  if(numOfDistinctPrimeFactors(i) == 4)
	  {
	    count++;
	    result = i;
	  }
	  else
	    count = 0;
	}
	System.out.println(result - 3);
  }
  
  public static int numOfDistinctPrimeFactors(int n)
  {
    int distinct = 0;
	for(int i = 0;; i++)
	{
      if ((int)prime.get(i) * (int)prime.get(i) > n)
		return ++distinct;
     
	  if(n % (int)prime.get(i) == 0)
	    distinct++;
	  else
	    continue;
		
	  while(n % (int)prime.get(i) == 0 && n > 1)
	  {
	    System.out.println(prime.get(i));
	    n /= (int)prime.get(i);
	  }
	  if(n == 1)
	    break;
	}
	return distinct;
  }
  
  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i <= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j <= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();
 
    for (int i = 2; i <= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 89 ms.[/java]","Problem 47: Distinct Prime Factors",,"inherit","open","open",,"139-revision-v1",,,"2014-06-15 06:53:26","2014-06-15 06:53:26",,"139","http://euler.lvtran.com/139-revision-v1/","0","revision",,"0"
"141","1","2013-11-06 06:53:53","2013-11-06 06:53:53","<p>It was proposed by <a href=""http://en.wikipedia.org/wiki/Christian_Goldbach"">Christian Goldbach</a> that every odd composite number can be written as the sum of a prime and twice a square.

9 = 7 + 2x1<sup>2</sup>
15 = 7 + 2 x 2<sup>2</sup>
21 = 3 + 2 x 3<sup>2</sup>
25 = 7 + 2 x 3<sup>2</sup>
27 = 19 + 2 x 2<sup>2</sup>
33 = 31 + 2 x 1<sup>2</sup></p>
<p>It turns out that the conjecture was false. What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?</p>
<!--more-->


<h2>The Catch</h2>
<p>How to tell when an odd composite number cannot be written as the sum of a prime and twice a square.</p>

<h2>The Light</h2>
<p>To prove <img src=""http://www.lvtran.com/wp-content/uploads/2014/02/cg.jpeg"" alt=""cg"" width=""150"" height=""150"" class=""alignnone size-full wp-image-420"" />wrong, we have to find the first instance where an odd number cannot be written as the sum of a prime and twice a square. The algorithm to check whether an odd number satisfies the above condition is fairly simple: for every odd number <strong>n</strong>, start substracting prime numbers <strong>p</strong> from a list of prime numbers, one at a time (<strong>p</strong> &le; <strong>n</strong>). If the difference is not twice a square, the corresponding number <strong>n </strong>will be the first instance to disprove Goldbach's other conjecture. In order to implement this algorithm, we need to:
&diams; Provide a list of prime numbers. This can be done using the <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" target=""_blank"">Sieve of Eratosthenes</a> 				discussed in <a href=""http://lvtran.com/p35/"">Problem 35</a>.
&diams; Check whether a quantity <strong>x</strong> is twice a square. Utilize the discussion of inverse functions in <a href=""http://lvtran.com/p42"">Problem 42</a>, <strong>x</strong> is twice a square if <strong>sqrt(x/2)</strong> is an integer.
</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem46
{
  public static void main(String[] args)
  {
    List primeList = new ArrayList();
    primeList = generatePrimes(10000);

    for(double i = 33.0;; i += 2.0)
    {
      boolean flag = false;
      for(int index = 0; primeList.get(index) &lt;= i; index++)
      {
        if(isTwiceASquare(i - primeList.get(index)))
        {
          flag = true;
          break;
        }
      }
      if(!flag)
      {
        System.out.println(i);
        break;
      }
    }
  }

  public static boolean isTwiceASquare(double n)
  {
    double square = Math.sqrt(n/2.0);
    return square == (int)square;
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 9 ms.[/java]","Problem 46: Goldbach's other Conjecture",,"publish","closed","closed",,"p46",,,"2014-06-15 07:09:52","2014-06-15 07:09:52",,"0","http://euler.lvtran.com/?p=141","0","post",,"0"
"142","1","2014-06-15 06:53:53","2014-06-15 06:53:53","<p>It was proposed by <a href=""http://en.wikipedia.org/wiki/Christian_Goldbach"">Christian Goldbach</a> that every odd composite number can be written as the sum of a prime and twice a square.

9 = 7 + 2x1<sup>2</sup>
15 = 7 + 2 x 2<sup>2</sup>
21 = 3 + 2 x 3<sup>2</sup>
25 = 7 + 2 x 3<sup>2</sup>
27 = 19 + 2 x 2<sup>2</sup>
33 = 31 + 2 x 1<sup>2</sup></p>
<p>It turns out that the conjecture was false. What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?</p>
<!--more-->


<h2>The Catch</h2>
<p>How to tell when an odd composite number cannot be written as the sum of a prime and twice a square.</p>

<h2>The Light</h2>
<p>To prove <img src=""http://www.lvtran.com/wp-content/uploads/2014/02/cg.jpeg"" alt=""cg"" width=""150"" height=""150"" class=""alignnone size-full wp-image-420"" />wrong, we have to find the first instance where an odd number cannot be written as the sum of a prime and twice a square. The algorithm to check whether an odd number satisfies the above condition is fairly simple: for every odd number <strong>n</strong>, start substracting prime numbers <strong>p</strong> from a list of prime numbers, one at a time (<strong>p</strong> &le; <strong>n</strong>). If the difference is not twice a square, the corresponding number <strong>n </strong>will be the first instance to disprove Goldbach's other conjecture. In order to implement this algorithm, we need to:
&diams; Provide a list of prime numbers. This can be done using the <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" target=""_blank"">Sieve of Eratosthenes</a> 				discussed in <a href=""http://lvtran.com/p35/"">Problem 35</a>.
&diams; Check whether a quantity <strong>x</strong> is twice a square. Utilize the discussion of inverse functions in <a href=""http://lvtran.com/p42"">Problem 42</a>, <strong>x</strong> is twice a square if <strong>sqrt(x/2)</strong> is an integer.
</p>

<h2>The Code</h2>
[java]
import java.util.*;

public class Problem46
{
  public static void main(String[] args)
  {
    List primeList = new ArrayList();
    primeList = generatePrimes(10000);

    for(double i = 33.0;; i += 2.0)
    {
      boolean flag = false;
      for(int index = 0; primeList.get(index) &lt;= i; index++)
      {
        if(isTwiceASquare(i - primeList.get(index)))
        {
          flag = true;
          break;
        }
      }
      if(!flag)
      {
        System.out.println(i);
        break;
      }
    }
  }

  public static boolean isTwiceASquare(double n)
  {
    double square = Math.sqrt(n/2.0);
    return square == (int)square;
  }

  public static List generatePrimes(int max) 
  {
    boolean[] isComposite = new boolean[max + 1];
    for (int i = 2; i * i &lt;= max; i++) 
    {
      if (!isComposite [i]) 
        for (int j = i; i * j &lt;= max; j++) 
        {
          isComposite [i*j] = true;
        }
    }   
    ArrayList list = new ArrayList();

    for (int i = 2; i &lt;= max; i++)  
    {
      if (!isComposite [i]) 
        list.add(new Integer(i));
    }
    return list;
  }
}
[/java]
[java]Execution time: 9 ms.[/java]","Problem 46: Goldbach's other Conjecture",,"inherit","open","open",,"141-revision-v1",,,"2014-06-15 06:53:53","2014-06-15 06:53:53",,"141","http://euler.lvtran.com/141-revision-v1/","0","revision",,"0"
"143","1","2013-11-07 06:54:45","2013-11-07 06:54:45","<p style=""margin-right: 30px;"">Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
Triangle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T<sub><i>n</i></sub> = <i>n</i>(<i>n</i>+1)/2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1, 3, 6, 10, 15, ...
Pentagonal&nbsp;&nbsp;&nbsp;&nbsp;P<sub><i>n</i></sub> = <i>n</i>(3<i>n</i> - 1)/2&nbsp;&nbsp;&nbsp;&nbsp;1, 5, 12, 22, 35, ...
Hexagonal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H<sub><i>n</i></sub> = <i>n</i>(2<i>n</i> - 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1, 6, 15, 28, 45, ...
<p>It can be verified that T<sub>285</sub> = P<sub>165</sub> = H<sub>143</sub> = 40755. Find the next triangle number that is also pentagonal and hexagonal.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to determine if a number is triangular, pentagonal, or hexagonal.</p>

<h2>The Light</h2>
<p>&clubs; Notice that for odd values of <b>n</b>, note that if a number is hexagonal, then it is also triangular. 
<p>Proof: T(2n - 1) = (2n - 1)( (2n - 1) + 1 )/2 = n(2n - 1).
<p>Thus, start generating a sequence of triangular numbers starting with n = 145 and only use odd values for n. Stop generating when the first instance of a pentagonal number appears.
<p>&clubs; Similar to the discussion in <a href=""http://lvtran.com/p42/"">Problem 42</a>, to check if a number is pentagonal, the inverse of P(n) = n(3n - 1)/2,<strong> (1 + sqrt(1 + 24x))/6</strong> must produce an integer.

<p>&clubs; Use type <b>long</b> to hold numbers, since they can get fairly large.</p>

<h2>The Code</h2>
[java]
public class Problem45
{
  public static void main(String[] args)
  {
    int n = 145;

    while(true)
    {
      long num = n * (2 * n - 1);
      if(isPen(num))
      {
        System.out.println(num);
        break;
      }
      n += 2;
    }
  }

  public static boolean isPen(long n)
  {
    double d = (1.0 + Math.sqrt(1 + 24 * n))/6.0;
    return (d == (long)d);
  }
}
[/java]
[java]Execution time: 45 ms.[/java]","Problem 45: Triangular, Pentagonal, and Hexagonal",,"publish","closed","closed",,"p47",,,"2014-06-15 07:09:52","2014-06-15 07:09:52",,"0","http://euler.lvtran.com/?p=143","0","post",,"0"
"144","1","2014-06-15 06:54:45","2014-06-15 06:54:45","<p style=""margin-right: 30px;"">Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
Triangle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T<sub><i>n</i></sub> = <i>n</i>(<i>n</i>+1)/2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1, 3, 6, 10, 15, ...
Pentagonal&nbsp;&nbsp;&nbsp;&nbsp;P<sub><i>n</i></sub> = <i>n</i>(3<i>n</i> - 1)/2&nbsp;&nbsp;&nbsp;&nbsp;1, 5, 12, 22, 35, ...
Hexagonal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H<sub><i>n</i></sub> = <i>n</i>(2<i>n</i> - 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1, 6, 15, 28, 45, ...
<p>It can be verified that T<sub>285</sub> = P<sub>165</sub> = H<sub>143</sub> = 40755. Find the next triangle number that is also pentagonal and hexagonal.</p>
<!--more-->


<h2>The Catch</h2>
<p>How to determine if a number is triangular, pentagonal, or hexagonal.</p>

<h2>The Light</h2>
<p>&clubs; Notice that for odd values of <b>n</b>, note that if a number is hexagonal, then it is also triangular. 
<p>Proof: T(2n - 1) = (2n - 1)( (2n - 1) + 1 )/2 = n(2n - 1).
<p>Thus, start generating a sequence of triangular numbers starting with n = 145 and only use odd values for n. Stop generating when the first instance of a pentagonal number appears.
<p>&clubs; Similar to the discussion in <a href=""http://lvtran.com/p42/"">Problem 42</a>, to check if a number is pentagonal, the inverse of P(n) = n(3n - 1)/2,<strong> (1 + sqrt(1 + 24x))/6</strong> must produce an integer.

<p>&clubs; Use type <b>long</b> to hold numbers, since they can get fairly large.</p>

<h2>The Code</h2>
[java]
public class Problem45
{
  public static void main(String[] args)
  {
    int n = 145;

    while(true)
    {
      long num = n * (2 * n - 1);
      if(isPen(num))
      {
        System.out.println(num);
        break;
      }
      n += 2;
    }
  }

  public static boolean isPen(long n)
  {
    double d = (1.0 + Math.sqrt(1 + 24 * n))/6.0;
    return (d == (long)d);
  }
}
[/java]
[java]Execution time: 45 ms.[/java]","Problem 45: Triangular, Pentagonal, and Hexagonal",,"inherit","open","open",,"143-revision-v1",,,"2014-06-15 06:54:45","2014-06-15 06:54:45",,"143","http://euler.lvtran.com/143-revision-v1/","0","revision",,"0"
"145","1","2014-06-15 07:05:03","2014-06-15 07:05:03","<p>The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.
<p>Let <i>d</i><sub>1</sub> be the 1<sup>st</sup> digit, <i>d</i><sub>2</sub> be the 2<sup>nd</sup> digit, and so on. In this way, we note the following:

<i>d</i><sub>2</sub><i>d</i><sub>3</sub><i>d</i><sub>4</sub>= 406 is divisible by 2
<i>d</i><sub>3</sub><i>d</i><sub>4</sub><i>d</i><sub>5</sub>= 063 is divisible by 3
<i>d</i><sub>4</sub><i>d</i><sub>5</sub><i>d</i><sub>6</sub>= 635 is divisible by 5
<i>d</i><sub>5</sub><i>d</i><sub>6</sub><i>d</i><sub>7</sub>= 357 is divisible by 7
<i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub>= 572 is divisible by 11
<i>d</i><sub>7</sub><i>d</i><sub>8</sub><i>d</i><sub>9</sub>= 728 is divisible by 13
<i>d</i><sub>8</sub><i>d</i><sub>9</sub><i>d</i><sub>10</sub>= 289 is divisible by 17

<p>Find the sum of all 0 to 9 pandigital numbers with this property.</p>
<!--more-->


<h2>The Catch</h2>
<p>If we want to brute force the solution by going through all pandigital numbers, it will require a permutation algorithm (rather difficult to implement and understand) and might take several hundred milliseconds.</p>
			
<h2>The Light and The Code</h2>
<p>To help with the analysis below, it will be useful to have a method that checks whether a number contains repeated digits. The algorithm is fairly simple: parse the number into String and traverse through each character. Keep track of each character and return immediately when a second instance of any character is found.
[java]
public static boolean hasRepeatDigit(int n)
{
  if(n &lt; 10)
    return false;

  char[] found = new char[10];
  String s = Integer.toString(n);
  found[Character.getNumericValue(s.charAt(0))] = s.charAt(0);

  for(int i = 1; i &lt; s.length(); i++)
  {
    if(s.charAt(i) == found[Character.getNumericValue(s.charAt(i))])
      return true;
    else
      found[Character.getNumericValue(s.charAt(i))] = s.charAt(i);  
  }
  return false;
}
[/java]

<p>Analyzing smaller groups of digits using their given divisibility properties:
&diams; <strong><i>d</i><sub>4</sub><i>d</i><sub>5</sub><i>d</i></strong><sub><strong>6</strong> </sub>is divisible by <strong>5</strong>, which means <strong><i>d</i></strong><sub><strong>6</strong> </sub>must be <strong>0</strong> or <strong>5</strong>.
&diams; If <strong><i>d</i></strong><sub><strong>6</strong></sub> is <strong>0</strong>, then <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong> is divisible by <strong>11</strong> if and only if <strong><i>d</i><sub>7 </sub></strong>= <strong><i>d</i><sub>8</sub></strong>, or in another word, <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8 </sub></strong>= {011, 022, 033, 044, 055, 066, 077, 088, 099}. Pandigital numbers cannot have repeated digits, so <i>d</i><sub>6</sub> cannot be 0; <strong><span style=""color: #ff0000;""><i>d</i><sub>6</sub> = 5</span></strong>.
&diams; Since <strong><i>d</i><sub>6</sub> = 5</strong>, we can find all possible values for <strong><i>d</i><sub>7<i> </i></sub></strong>and <strong><i>d</i><sub>8</sub></strong> by looking for all numbers between 501 and 598 that are divisible by 11 and has no repeated digits.

[java]
  //Check d6d7d8 for divisibility by 11
  List d6d7d8 = new ArrayList();
  for(int i = 501; i &lt;= 598; i++)
  {
    if((i % 11 == 0) &amp;&amp; (i % 10 != 5) &amp;&amp; (i % 100/10 != 5) &amp;&amp; (i % 10 != i % 100/10) &amp;&amp; !hasRepeatDigit(i))
    {
      System.out.print(i + "" "");
      d6d7d8.add(i);
    }
  }
  System.out.println();
[/java]

<p>This outputs <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong> = {<span style=""color: #ff0000;""><strong>506, 517, 528, 539, 561, 572, 583, 594</strong><span style=""color: #000000;"">}</span></span>. Now that the sequence <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong> is formulated, limiting the possible values for the sequence <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9 </sub></strong>  by adding <strong><i>d</i><sub>9</sub></strong>
[java]
  //Check d6d7d8d9 
  List d6d7d8d9 = new ArrayList();
  for(int i = 0; i &lt; d6d7d8.size(); i++)
  {
    for( int d9 = 0; d9 &lt;= 9; d9++ )
    {
      int tmp = (d6d7d8.get(i) - 500) * 10 + d9;
      if(tmp % 13 == 0 &amp;&amp; !hasRepeatDigit(tmp + 5000))
      {
        System.out.print((5000 + tmp) + "" "");
        d6d7d8d9.add(5000 + tmp);
      }
    }
  }
  System.out.println();
[/java]

<p>This outputs <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9 </sub></strong>= {<strong><span style=""color: #ff0000;"">5286, 5390, 5728, 5832</span></strong>}. Similarly, add <strong><i>d</i><sub>10 </sub></strong>to find the sequence <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>
[java]
  //Check d8d9d10 for divisibility by 17
  List d6d7d8d9d10 = new ArrayList();
  for(int i = 0; i &lt; d6d7d8d9.size(); i++)
  {
    int d8d9 = d6d7d8d9.get(i) % 100;
    for(int d10 = 0; d10 &lt;= 9; d10++)
    {
      if((d8d9 * 10 + d10) % 17 == 0 &amp;&amp; !hasRepeatDigit(d6d7d8d9.get(i) * 10 + d10))
      {
        System.out.print( (d6d7d8d9.get(i) * 10 + d10) + "" "");
        d6d7d8d9d10.add((d6d7d8d9.get(i) * 10 + d10));
      }
    }
  }
  System.out.println();
[/java]

<p>This outputs <strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>52867, 53901, 57289</strong></span>}. Continue with <strong><i>d</i><sub>5</sub><i></i></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>

[java]
  //Check d5d6d7 for divisibility by 7
  List d5d6d7d8d9d10 = new ArrayList();
  for(int i = 0; i &lt; d6d7d8d9d10.size(); i++)
  {
    int d6d7 = d6d7d8d9d10.get(i)/1000; 
    for(int d5 = 0; d5 &lt;= 9; d5++)
    {
      if((d5 * 100 + d6d7) % 7 == 0 &amp;&amp; !hasRepeatDigit(d5 * 100000 + d6d7d8d9d10.get(i)))
      {
        System.out.print((d5 * 100000 + d6d7d8d9d10.get(i)) + "" "");
        d5d6d7d8d9d10.add((d5 * 100000 + d6d7d8d9d10.get(i)));
      }
    }
  }
  System.out.println();
[/java]
	
<p>This outputs <strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>9</strong><strong>52867, 357289</strong></span>}. <strong><i>d</i><sub>2</sub><i>d</i><sub>3</sub><i>d</i><sub>4 </sub></strong>is divisible by 2, so <strong><i>d</i><sub>4</sub></strong><strong><sub> </sub></strong>must be an even number. Add <strong><i>d</i><sub>4</sub></strong> to the sequence <strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub></sub></strong>
[java]
  //Add (even) d4 to the sequence d5d6d7d8d9d10
  List d4d5d6d7d8d9d10 = new ArrayList();
  for(int i = 0; i &lt; d5d6d7d8d9d10.size(); i++)
  {
    for(int d4 = 0; d4 &lt; 9; d4 += 2)
    {
      if(!hasRepeatDigit((d4 * 1000000 + d5d6d7d8d9d10.get(i))))
      { 
        if(d4 == 0)
        {
          System.out.print(d4 * 1000000);
          System.out.print(d5d6d7d8d9d10.get(i) + "" "");
          d4d5d6d7d8d9d10.add(d4 * 1000000 + d5d6d7d8d9d10.get(i)); //Special leading 0 cases
        }
        else
        {
          System.out.print((d4 * 1000000 + d5d6d7d8d9d10.get(i)) + "" "");
          d4d5d6d7d8d9d10.add(d4 * 1000000 + d5d6d7d8d9d10.get(i));
        }
      }
    }
  }
  System.out.println();
[/java]
	
<p>This outputs <strong><i>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>0952867, 4952867, 0357289, 4357289, 6357289</strong></span>}</p>

<p>Now there are only 3 digits left to determine; we can switch to manual mode! Judging from the set above and the fact that <strong><i>d</i><sub>3 </sub><i>+ d</i><sub>4 </sub><i>+ d</i></strong><sub><strong>5</strong> </sub>must be divisible by <strong>3</strong>:
<p>
0952867 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {1, 3, 4} &rarr; <strong><i>d</i><sub>3 </sub></strong>= 3 is the only candidate that satisfies the divisibility requirement &rarr;<strong><span style=""color: #ff0000;""> 30952867</span></strong>
4952867 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {0, 1, 3} &rarr; Numbers in this set don't satisfy the divisibility requirement &rarr; discard 4952867
0357289 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {1, 4, 6} &rarr; <strong><i>d</i><sub>3 </sub></strong>= 6 is the only candidate that satisfies the divisibility requirement &rarr;<strong> <span style=""color: #ff0000;"">60357289</span></strong>
4357289 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {0, 1, 6} &rarr;   Numbers in this set don't satisfy the divisibility requirement &rarr; discard 4357289
6357289 &rarr; <strong><i>d</i><sub>3</sub></strong> can be from the set {0, 1, 4} &rarr; <strong><i>d</i><sub>3 </sub></strong>= 0 is the only candidate that satisfies the divisibility requirement &rarr;<strong> <span style=""color: #ff0000;"">06357289</span></strong>

<p><strong><i><strong><i>d</i><sub>3</sub></strong>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong><strong><sub> </sub></strong>= {<span style=""color: #ff0000;""><strong>30952867</strong><strong>, <strong>60357289</strong>, <strong>06357289</strong></strong></span>}</p>

<p><strong><i>d</i></strong><sub><strong>1</strong> </sub>and <strong><i>d</i></strong><sub><strong>2</strong> </sub>do not have any restriction except for the fact that they can be either <strong>1</strong> or<strong> 4</strong>, the only 2 digits left from 0 - 9. From the set above, there are only 6 simple permutations left to complete the sequence <strong><i>d</i></strong><sub><strong>1</strong></sub><strong><i>d</i></strong><sub><strong>2</strong></sub><strong><i><strong><i>d</i><sub>3</sub></strong>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>

<div align=""center""><p><b><i> <strong><i>d</i></strong><sub><strong>1</strong></sub><strong><i>d</i></strong><sub><strong>2</strong></sub><strong><i><strong><i>d</i><sub>3</sub></strong>d</i><sub>4</sub></strong><strong><i>d</i><sub>5</sub></strong><strong><i>d</i><sub>6</sub><i>d</i><sub>7</sub><i>d</i><sub>8</sub></strong><strong><i>d</i><sub>9</sub></strong><strong><i>d</i><sub>10</sub></strong>= {<span style=""color: #ff0000;"">1430952867</strong></span><strong><span style=""color: #ff0000;"">, 14<strong>60357289 </strong>, 14</span><strong><span style=""color: #ff0000;"">06357289, 41<strong>30952867</strong><strong>, 41<strong>60357289 </strong>, 41<strong>06357289</strong></strong></span>}</strong></strong></i></b>

Sum = <i>1430952867 + 1460357289 + 1406357289 + 4130952867 + 4160357289 + 4106357289</i><b><i><strong><strong><strong><strong> = <span style=""color: #ff0000;"">16695334890</span></strong></strong></strong></strong></i></b></div>
		
[java]Execution time: 3 ms.[/java]","Problem 43: Sub-string Divisibility",,"inherit","open","open",,"124-revision-v1",,,"2014-06-15 07:05:03","2014-06-15 07:05:03",,"124","http://euler.lvtran.com/124-revision-v1/","0","revision",,"0"
"1","Uncategorized","uncategorized","0"
"2","Menu 1","menu-1","0"
"90","1","0"
"4","1","0"
"15","1","0"
"17","1","0"
"19","1","0"
"22","1","0"
"24","1","0"
"34","2","0"
"37","1","0"
"39","1","0"
"41","1","0"
"43","1","0"
"45","1","0"
"47","1","0"
"49","1","0"
"51","1","0"
"68","1","0"
"70","1","0"
"72","1","0"
"74","1","0"
"76","1","0"
"78","1","0"
"81","1","0"
"88","1","0"
"92","1","0"
"94","1","0"
"96","1","0"
"100","1","0"
"102","1","0"
"104","1","0"
"106","1","0"
"108","1","0"
"110","1","0"
"112","1","0"
"114","1","0"
"116","1","0"
"118","1","0"
"120","1","0"
"122","1","0"
"124","1","0"
"126","1","0"
"128","1","0"
"130","1","0"
"132","1","0"
"135","1","0"
"137","1","0"
"139","1","0"
"141","1","0"
"143","1","0"
"1","1","category",,"0","48"
"2","2","nav_menu",,"0","1"
"1","1","first_name",
"2","1","last_name",
"3","1","nickname","v.long128@gmail.com"
"4","1","description",
"5","1","rich_editing","true"
"6","1","comment_shortcuts","false"
"7","1","admin_color","fresh"
"8","1","use_ssl","0"
"9","1","show_admin_bar_front","true"
"10","1","wp_veqn_capabilities","a:1:{s:13:""administrator"";b:1;}"
"11","1","wp_veqn_user_level","10"
"12","1","dismissed_wp_pointers","wp350_media,wp360_revisions,wp360_locks,wp390_widgets"
"13","1","wp_veqn_dashboard_quick_press_last_post_id","149"
"14","1","wp_veqn_user-settings","editor=html"
"15","1","wp_veqn_user-settings-time","1401938344"
"16","1","managenav-menuscolumnshidden","a:4:{i:0;s:11:""link-target"";i:1;s:11:""css-classes"";i:2;s:3:""xfn"";i:3;s:11:""description"";}"
"17","1","metaboxhidden_nav-menus","a:3:{i:0;s:8:""add-post"";i:1;s:12:""add-post_tag"";i:2;s:15:""add-post_format"";}"
"18","1","meta-box-order_dashboard","a:4:{s:6:""normal"";s:38:""dashboard_right_now,dashboard_activity"";s:4:""side"";s:39:""dashboard_quick_press,dashboard_primary"";s:7:""column3"";s:0:"""";s:7:""column4"";s:0:"""";}"
"19","1","nav_menu_recently_edited","2"
"20","1","default_password_nag",
"1","v.long128@gmail.com","$P$B3Q0Cv6hxWIrd4zfIRSuUbHzV5/6u3.","v-long128gmail-com","v.long128@gmail.com",,"2014-06-04 11:00:26",,"0","v.long128@gmail.com"
